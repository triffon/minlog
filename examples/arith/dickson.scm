;; 2020-08-01.  dickson.scm

;; (load "~/git/minlog/init.scm")

(set! COMMENT-FLAG #f)
(libload "nat.scm")
(set! COMMENT-FLAG #t)

(add-var-name "f" "g" "s" (py "nat=>nat"))
(add-var-name "i" "j" "k" "l" "c" (py "nat"))

(add-program-constant "Maxi" (py "(nat=>nat)=>nat=>nat"))
(add-computation-rules
 "Maxi f 0" "0"
 "Maxi f(Succ n)" "[if (f(Succ n)<=f(Maxi f n)) (Maxi f n) (Succ n)]")

(set-totality-goal "Maxi")
(assume "f^" "Tf" "n^" "Tn")
(elim "Tn")
(use "TotalNatZero")
(assume "n^1" "Tn1" "IH")
(ng #t)
(use "BooleIfTotal")
(use "NatLeTotal")
(use "Tf")
(use "TotalNatSucc")
(use "Tn1")
(use "Tf")
(use "IH")
(use "IH")
(use "TotalNatSucc")
(use "Tn1")
;; Proof finshed.
(save-totality)

;; MaxiBound
(set-goal "all f,n Maxi f n<=n")
(assume "f")
(ind)
(use "Truth")
(assume "n" "IH")
(cases (pt "f(Succ n)<=f(Maxi f n)"))
(assume "LeCase")
(simp "LeCase")
(use "NatLeTrans" (pt "n"))
(use "IH")
(use "Truth")
(assume "NotLeCase")
(simp "NotLeCase")
(use "Truth")
;; Proof faxished.
(save "MaxiBound")

;; MaxiProp
(set-goal "all f,n,i(i<=n -> f i<=f(Maxi f n))")
(assume "f")
(ind)
;; Base
(cases)
(assume "Useless")
(use "Truth")
(assume "n" "Absurd")
(use "EfAtom")
(use "Absurd")
;; Step
(assume "n" "IH" "i" "i<=n+1")
(use "NatLtSuccCases" (pt "i") (pt "Succ n"))
(use "NatLeLtTrans" (pt "Succ n"))
(use "i<=n+1")
(use "Truth")
(assume "i<n+1")
(use "NatLeTrans" (pt "f(Maxi f n)"))
(use "IH")
(use "NatLtSuccToLe")
(use "i<n+1")
;; ?_18:f(Maxi f n)<=f(Maxi f(Succ n))
(cases (pt "f(Succ n)<=f(Maxi f n)"))
(assume "LeCase")
(simp "LeCase")
(use "Truth")
(assume "NotLeCase")
(simp "NotLeCase")
(use "NatLtToLe")
(use "NatNotLeToLt")
(use "NotLeCase")
(assume "i=n+1")
(simp "i=n+1")
;; ?_30:f(Succ n)<=f(Maxi f(Succ n))
(cases (pt "f(Succ n)<=f(Maxi f n)"))
(assume "LeCase")
(simp "LeCase")
(use "LeCase")
(assume "NotLeCase")
(simp "NotLeCase")
(use "Truth")
;; Proof finished.
(save "MaxiProp")

;; Let f_j be maximal among f_0 ... f_{m+1} (j=Maxi f(m+1)).  If
;; m+1<=f_j we are done.  Else we have f_j<=m.  Now we apply the IH on
;; f'=f_0 ... f_{j-1} f_{j+1}...f_{m+1}.  If two of them are equal we
;; are done.  Else m<=f_k for some k=/=j and hence f_j<=f_k.  If
;; f_j=f_k we are done.  Else f_j<f_k contradicting the choice of j.

;; FPHDisj
(set-goal "all m,f(exd i exl j(i<j andi j<=m andi f i=f j) ori
                   exl j(j<=m andi m<=f j))")
(ind)
;; Base
(assume "f")
(intro 1)
(intro 0 (pt "0"))
(split)
(use "Truth")
(use "Truth")
;; Step
(assume "m" "IH" "f")
(cut "exl j j=Maxi f(Succ m)")
(use "Id")
(assume "jEx")
(by-assume "jEx" "j" "jDef")
(cases (pt "Succ m<=f j"))
;; Case m+1<=fj
(assume "m+1<=f j")
(intro 1)
(intro 0 (pt "j"))
(split)
(simp "jDef")
(use "MaxiBound")
(use "m+1<=f j")
;; Case m+1<=fj -> F
(assume "m+1<=fj -> F")
(assert "f j<Succ m")
 (use "NatNotLeToLt")
 (use "m+1<=fj -> F")
 (drop "m+1<=fj -> F")
(assume "fj<m+1")
(inst-with-to "IH" (pt "[n][if (n<j) (f n) (f(Succ n))]") "IHInst")
(drop "IH")
(ng "IHInst")
(elim "IHInst")
(drop "IHInst")
;; Case two are equal
(assume "ExHyp")
(by-assume "ExHyp" "i" "iProp")
(by-assume "iProp" "j1" "ij1Prop")
(intro 0)
(cases (pt "j1<j"))
;; Case j1<j
(assume "j1<j")
(simphyp-with-to "ij1Prop" "j1<j" "ij1PropSimp")
(drop "ij1Prop")
(ng "ij1PropSimp")
(assert "i<j")
 (use "NatLtTrans" (pt "j1"))
 (use "ij1PropSimp")
 (use "j1<j")
(assume "i<j")
(simphyp-with-to "ij1PropSimp" "i<j" "ij1PropSSimp")
(ng "ij1PropSSimp")
;; Take i,j1
(intro 0 (pt "i"))
(intro 0 (pt "j1"))
(msplit)
(use "ij1PropSSimp")
(use "NatLeTrans" (pt "m"))
(use "ij1PropSSimp")
(use "Truth")
(use "ij1PropSSimp")
;; Case j1<j -> F
(assume "j1<j -> F")
(simphyp-with-to "ij1Prop" "j1<j -> F" "ij1PropSimp")
(drop "ij1Prop")
(ng "ij1PropSimp")
(cases (pt "i<j"))
;; Subcase i<j
(assume "i<j")
(simphyp-with-to "ij1PropSimp" "i<j" "ij1PropSSimp")
(ng "ij1PropSSimp")
(drop "ij1PropSimp")
(intro 0 (pt "i"))
(intro 0 (pt "Succ j1"))
(msplit)
(use "ij1PropSSimp")
(use "ij1PropSSimp")
(use "NatLtTrans" (pt "j1"))
(use "ij1PropSimp")
(use "Truth")
;; Subcase i<j -> F
(assume "i<j -> F")
(simphyp-with-to "ij1PropSimp" "i<j -> F" "ij1PropSSimp")
(ng "ij1PropSSimp")
(drop "ij1PropSimp")
(intro 0 (pt "Succ i"))
(intro 0 (pt "Succ j1"))
(msplit)
(use "ij1PropSSimp")
(use "ij1PropSSimp")
(use "ij1PropSSimp")
(drop "IHInst")
;; Case one above
(assume "ExHyp")
(by-assume "ExHyp" "j1" "j1Prop")
(assert "exl k k=[if (j1<j) j1 (Succ j1)]")
 (intro 0 (pt "[if (j1<j) j1 (Succ j1)]"))
 (use "Truth")
(assume "kEx")
(by-assume "kEx" "k" "kDef")
(cases (pt "j1<j"))
;; Case j1<j
(assume "j1<j")
(simphyp-with-to "j1Prop" "j1<j" "j1PropSimp")
(drop "j1Prop")
(ng "j1PropSimp")
(simphyp-with-to "kDef" "j1<j" "kDefSimp")
(drop "kDef")
(ng "kDefSimp")
(simphyp-with-to "j1PropSimp" "<-" "kDefSimp" "j1PropSSimp")
(drop "j1PropSimp")
(assert "f j<=f k")
 (use "NatLeTrans" (pt "m"))
 (use "NatLtSuccToLe")
 (use "fj<m+1")
 (use "j1PropSSimp")
(assume "fj<=fk")
(use "NatLeCases" (pt "f j") (pt "f k"))
(use "fj<=fk")
(drop "fj<=fk")
;; Case fj<fk
(assume "fj<fk")
(assert "f k<=f j")
 (simp "jDef")
 (use "MaxiProp")
 (use "NatLeTrans" (pt "m"))
 (use "j1PropSSimp")
 (use "Truth")
(assume "fk<=fj")
(assert "f j<f j")
 (use "NatLtLeTrans" (pt "f k"))
 (use "fj<fk")
 (use "fk<=fj")
(assume "Absurd")
(use (formula-to-ef-proof (goal-to-formula (current-goal))))
;; (use "Efq")
(use "Absurd")
;; Case fj=fk
(assume "fj=fk")
(intro 0)
(intro 0 (pt "k"))
(intro 0 (pt "j"))
(msplit)
(simp "fj=fk")
(use "Truth")
(simp "jDef")
(use "MaxiBound")
(simp "kDefSimp")
(use "j1<j")
;; Case j1<j -> F
(assume "j1<j -> F")
(simphyp-with-to "j1Prop" "j1<j -> F" "j1PropSimp")
(drop "j1Prop")
(ng "j1PropSimp")
(simphyp-with-to "kDef" "j1<j -> F" "kDefSimp")
(drop "kDef")
(ng "kDefSimp")
(simphyp-with-to "j1PropSimp" "<-" "kDefSimp" "j1PropSSimp")
(drop "j1PropSimp")
(assert "f j<=f k")
 (use "NatLeTrans" (pt "m"))
 (use "NatLtSuccToLe")
 (use "fj<m+1")
 (use "j1PropSSimp")
(assume "fj<=fk")
(use "NatLeCases" (pt "f j") (pt "f k"))
(use "fj<=fk")
(drop "fj<=fk")
;; Case fj<fk
(assume "fj<fk")
(assert "f k<=f j")
 (simp "jDef")
 (use "MaxiProp")
 (simp "kDefSimp")
 (use "j1PropSSimp")
(assume "fk<=fj")
(assert "f j<f j")
 (use "NatLtLeTrans" (pt "f k"))
 (use "fj<fk")
 (use "fk<=fj")
(assume "Absurd")
(use (formula-to-ef-proof (goal-to-formula (current-goal))))
;; (use "Efq")
(use "Absurd")
;; Case fj=fk
(assume "fj=fk")
(intro 0)
;; k<=Succ m by kDefSimp and j1PropSSimp
;; j<=Succ m by MaxiBound
;; j<=j1 and k=Succ j1, hence Succ j<=k and therefore j<k
(intro 0 (pt "j"))
(intro 0 (pt "k"))
(msplit)
(use "fj=fk")
(simp "kDefSimp")
(use "j1PropSSimp")
(assert "j<=j1")
 (use "NatNotLtToLe")
 (use "j1<j -> F")
(assume "j<=j1")
(assert "j<Succ j1")
(use "NatLeToLtSucc")
(use "j<=j1")
(simp "kDefSimp")
(assume "j<j1+1")
(use "j<j1+1")
;; Finally we prove what is left from the cut above
(intro 0 (pt "Maxi f(Succ m)"))
(use "Truth")
;; Proof finished.
(save "FPHDisj")

;; ;; FPHDisj
;; (set-goal "all m,f(exd i exl j(i<j andi j<=m andi f i=f j) ori
;;                    exl j(j<=m andi m<=f j))")
;; (ind)
;; ;; Base
;; (assume "f")
;; (intro 1)
;; (intro 0 (pt "0"))
;; (split)
;; (use "Truth")
;; (use "Truth")
;; ;; Step
;; (assume "m" "IH" "f")
;; (cut "exl j j=Maxi f(Succ m)")
;; (use "Id")
;; (assume "jEx")
;; (by-assume "jEx" "j" "jDef")
;; (cases (pt "Succ m<=f j"))
;; ;; Case m+1<=fj
;; (assume "m+1<=f j")
;; (intro 1)
;; (intro 0 (pt "j"))
;; (split)
;; (simp "jDef")
;; (use "MaxiBound")
;; (use "m+1<=f j")
;; ;; Case m+1<=fj -> F
;; (assume "m+1<=fj -> F")
;; (assert "f j<Succ m")
;;  (use "NatNotLeToLt")
;;  (use "m+1<=fj -> F")
;;  (drop "m+1<=fj -> F")
;; (assume "fj<m+1")
;; (inst-with-to "IH" (pt "[n][if (n<j) (f n) (f(Succ n))]") "IHInst")
;; (drop "IH")
;; (ng "IHInst")
;; (elim "IHInst")
;; (drop "IHInst")
;; ;; Case two are equal
;; (assume "ExHyp")
;; (by-assume "ExHyp" "i" "iProp")
;; (by-assume "iProp" "j1" "ij1Prop")
;; (intro 0)
;; (cases (pt "j1<j"))
;; ;; Case j1<j
;; (assume "j1<j")
;; (simphyp-with-to "ij1Prop" "j1<j" "ij1PropSimp")
;; (drop "ij1Prop")
;; (ng "ij1PropSimp")
;; (assert "i<j")
;;  (use "NatLtTrans" (pt "j1"))
;;  (use "ij1PropSimp")
;;  (use "j1<j")
;; (assume "i<j")
;; (simphyp-with-to "ij1PropSimp" "i<j" "ij1PropSSimp")
;; (ng "ij1PropSSimp")
;; ;; Take i,j1
;; (intro 0 (pt "i"))
;; (intro 0 (pt "j1"))
;; (msplit)
;; (use "ij1PropSSimp")
;; (use "NatLeTrans" (pt "m"))
;; (use "ij1PropSSimp")
;; (use "Truth")
;; (use "ij1PropSSimp")
;; ;; Case j1<j -> F
;; (assume "j1<j -> F")
;; (simphyp-with-to "ij1Prop" "j1<j -> F" "ij1PropSimp")
;; (drop "ij1Prop")
;; (ng "ij1PropSimp")
;; (cases (pt "i<j"))
;; ;; Subcase i<j
;; (assume "i<j")
;; (simphyp-with-to "ij1PropSimp" "i<j" "ij1PropSSimp")
;; (ng "ij1PropSSimp")
;; (drop "ij1PropSimp")
;; (intro 0 (pt "i"))
;; (intro 0 (pt "Succ j1"))
;; (msplit)
;; (use "ij1PropSSimp")
;; (use "ij1PropSSimp")
;; (use "NatLtTrans" (pt "j1"))
;; (use "ij1PropSimp")
;; (use "Truth")
;; ;; Subcase i<j -> F
;; (assume "i<j -> F")
;; (simphyp-with-to "ij1PropSimp" "i<j -> F" "ij1PropSSimp")
;; (ng "ij1PropSSimp")
;; (drop "ij1PropSimp")
;; (intro 0 (pt "Succ i"))
;; (intro 0 (pt "Succ j1"))
;; (msplit)
;; (use "ij1PropSSimp")
;; (use "ij1PropSSimp")
;; (use "ij1PropSSimp")
;; (drop "IHInst")
;; ;; Case one above
;; (assume "ExHyp")
;; (by-assume "ExHyp" "j1" "j1Prop")
;; (assert "exl k k=[if (j1<j) j1 (Succ j1)]")
;;  (intro 0 (pt "[if (j1<j) j1 (Succ j1)]"))
;;  (use "Truth")
;; (assume "kEx")
;; (by-assume "kEx" "k" "kDef")
;; (cases (pt "j1<j"))
;; ;; Case j1<j
;; (assume "j1<j")
;; (simphyp-with-to "j1Prop" "j1<j" "j1PropSimp")
;; (drop "j1Prop")
;; (ng "j1PropSimp")
;; (simphyp-with-to "kDef" "j1<j" "kDefSimp")
;; (drop "kDef")
;; (ng "kDefSimp")
;; (simphyp-with-to "j1PropSimp" "<-" "kDefSimp" "j1PropSSimp")
;; (drop "j1PropSimp")
;; (assert "f j<=f k")
;;  (use "NatLeTrans" (pt "m"))
;;  (use "NatLtSuccToLe")
;;  (use "fj<m+1")
;;  (use "j1PropSSimp")
;; (assume "fj<=fk")
;; (use "NatLeCases" (pt "f j") (pt "f k"))
;; (use "fj<=fk")
;; (drop "fj<=fk")
;; ;; Case fj<fk
;; (assume "fj<fk")
;; (assert "f k<=f j")
;;  (simp "jDef")
;;  (use "MaxiProp")
;;  (use "NatLeTrans" (pt "m"))
;;  (use "j1PropSSimp")
;;  (use "Truth")
;; (assume "fk<=fj")
;; (assert "f j<f j")
;;  (use "NatLtLeTrans" (pt "f k"))
;;  (use "fj<fk")
;;  (use "fk<=fj")
;; (assume "Absurd")
;; (use "Efq")
;; (use "Absurd")
;; ;; Case fj=fk
;; (assume "fj=fk")
;; (intro 0)
;; (intro 0 (pt "k"))
;; (intro 0 (pt "j"))
;; (msplit)
;; (simp "fj=fk")
;; (use "Truth")
;; (simp "jDef")
;; (use "MaxiBound")
;; (simp "kDefSimp")
;; (use "j1<j")
;; ;; Case j1<j -> F
;; (assume "j1<j -> F")
;; (simphyp-with-to "j1Prop" "j1<j -> F" "j1PropSimp")
;; (drop "j1Prop")
;; (ng "j1PropSimp")
;; (simphyp-with-to "kDef" "j1<j -> F" "kDefSimp")
;; (drop "kDef")
;; (ng "kDefSimp")
;; (simphyp-with-to "j1PropSimp" "<-" "kDefSimp" "j1PropSSimp")
;; (drop "j1PropSimp")
;; (assert "f j<=f k")
;;  (use "NatLeTrans" (pt "m"))
;;  (use "NatLtSuccToLe")
;;  (use "fj<m+1")
;;  (use "j1PropSSimp")
;; (assume "fj<=fk")
;; (use "NatLeCases" (pt "f j") (pt "f k"))
;; (use "fj<=fk")
;; (drop "fj<=fk")
;; ;; Case fj<fk
;; (assume "fj<fk")
;; (assert "f k<=f j")
;;  (simp "jDef")
;;  (use "MaxiProp")
;;  (simp "kDefSimp")
;;  (use "j1PropSSimp")
;; (assume "fk<=fj")
;; (assert "f j<f j")
;;  (use "NatLtLeTrans" (pt "f k"))
;;  (use "fj<fk")
;;  (use "fk<=fj")
;; (assume "Absurd")
;; (use "Efq")
;; (use "Absurd")
;; ;; Case fj=fk
;; (assume "fj=fk")
;; (intro 0)
;; ;; k<=Succ m by kDefSimp and j1PropSSimp
;; ;; j<=Succ m by MaxiBound
;; ;; j<=j1 and k=Succ j1, hence Succ j<=k and therefore j<k
;; (intro 0 (pt "j"))
;; (intro 0 (pt "k"))
;; (msplit)
;; (use "fj=fk")
;; (simp "kDefSimp")
;; (use "j1PropSSimp")
;; (assert "j<=j1")
;;  (use "NatNotLtToLe")
;;  (use "j1<j -> F")
;; (assume "j<=j1")
;; (assert "j<Succ j1")
;; (use "NatLeToLtSucc")
;; (use "j<=j1")
;; (simp "kDefSimp")
;; (assume "j<j1+1")
;; (use "j<j1+1")
;; ;; Finally we prove what is left from the cut above
;; (intro 0 (pt "Maxi f(Succ m)"))
;; (use "Truth")
;; ;; Proof finished.
;; (save "FPHDisj")

(define eterm (proof-to-extracted-term))
(add-var-name "ij" (py "nat yprod nat"))
(add-var-name "d" (py "(nat=>nat)=>nat yprod nat ysum nat"))
(define neterm (rename-variables (nt eterm)))
(pp neterm)

;; [n]
;;  (Rec nat=>(nat=>nat)=>nat yprod nat ysum nat)n
;;  ([f](InR nat (nat yprod nat))0)
;;  ([n0,d,f]
;;    [let n1
;;      [if (f(Succ n0)<=f(Maxi f n0)) (Maxi f n0) (Succ n0)]
;;      [if (Succ n0<=f n1)
;;       ((InR nat (nat yprod nat))n1)
;;       [if (d([n2][if (n2<n1) (f n2) (f(Succ n2))]))
;;        ([(nat yprod nat)]
;;         [if (nat yprod nat)
;;           ([n2,n3]
;;            (InL (nat yprod nat) nat)
;;            [if (n3<n1)
;;              (n2 pair n3)
;;              [if (n2<n1) (n2 pair Succ n3) (Succ n2 pair Succ n3)]])])
;;        ([n2]
;;         [if (n2<n1)
;;           [if (f n1<f[if (n2<n1) n2 (Succ n2)])
;;            ((InL (nat yprod nat) nat)(0 pair 0))
;;            ((InL (nat yprod nat) nat)([if (n2<n1) n2 (Succ n2)]pair n1))]
;;           [if (f n1<f[if (n2<n1) n2 (Succ n2)])
;;            ((InL (nat yprod nat) nat)(0 pair 0))
;;            ((InL (nat yprod nat) nat)(n1 pair[if (n2<n1) n2 (Succ n2)]))]])]]])
(define nneterm (term-to-term-without-predecided-ifs neterm))
(pp nneterm)

;; [n]
;;  (Rec nat=>(nat=>nat)=>nat yprod nat ysum nat)n
;;  ([f](InR nat (nat yprod nat))0)
;;  ([n0,d,f]
;;    [let n1
;;      [if (f(Succ n0)<=f(Maxi f n0)) (Maxi f n0) (Succ n0)]
;;      [if (Succ n0<=f n1)
;;       ((InR nat (nat yprod nat))n1)
;;       [if (d([n2][if (n2<n1) (f n2) (f(Succ n2))]))
;;        ([(nat yprod nat)]
;;         [if (nat yprod nat)
;;           ([n2,n3]
;;            (InL (nat yprod nat) nat)
;;            [if (n3<n1)
;;              (n2 pair n3)
;;              [if (n2<n1) (n2 pair Succ n3) (Succ n2 pair Succ n3)]])])
;;        ([n2]
;;         [if (n2<n1)
;;           [if (f n1<f n2)
;;            ((InL (nat yprod nat) nat)(0 pair 0))
;;            ((InL (nat yprod nat) nat)(n2 pair n1))]
;;           [if (f n1<f(Succ n2))
;;            ((InL (nat yprod nat) nat)(0 pair 0))
;;            ((InL (nat yprod nat) nat)(n1 pair Succ n2))]])]]])

;; V n is the integer square root of n

(add-program-constant "V" (py "nat=>nat"))
(add-computation-rules
 "V 0" "0"
 "V(Succ n)" "[if (n<Succ(V n)*V n+V n) (V n) (Succ(V n))]")

(set-totality-goal "V")
(use "AllTotalElim")
(ind)
;; Base
(ng #t)
(use "TotalNatZero")
;; Step
(assume "n" "IH")
(ng #t)
(use "BooleIfTotal")
(use "NatLtTotal")
(use "NatTotalVar")
(use "NatPlusTotal")
(use "NatTimesTotal")
(use "TotalNatSucc")
(use "IH")
(use "IH")
(use "IH")
(use "IH")
(use "TotalNatSucc")
(use "IH")
;; Proof finished.
(save-totality)

;; Code of pairs of natural numbers

;;  12  13  14  15
;;   6   7   8  11
;;   2   3   5  10
;;   0   1   4   9  16

(add-program-constant "Code" (py "nat=>nat=>nat"))
(add-computation-rules "Code n m" "[if (m<n) (n*n+m) (m*m+m+n)]")

(set-totality-goal "Code")
(use "AllTotalElim")
(assume "n")
(use "AllTotalElim")
(assume "m")
(ng #t)
(use "BooleIfTotal")
(use "BooleTotalVar")
(use "NatTotalVar")
(use "NatTotalVar")
;; Proof finished.
(save-totality)

;; L is the left component of a coded pair.

(add-program-constant "L" (py "nat=>nat"))
(add-computation-rules "L c" "[if (c<V c*V c+V c) (V c) (c--(V c*V c+V c))]")

(set-totality-goal "L")
(use "AllTotalElim")
(ng #t)
(assume "n")
(use "BooleIfTotal")
(use "BooleTotalVar")
(use "NatTotalVar")
(use "NatTotalVar")
;; Proof finished.
(save-totality)

(add-program-constant "R" (py "nat=>nat"))
(add-computation-rules "R c" "[if (c<V c*V c+V c) (c--V c*V c) (V c)]")

(set-totality-goal "R")
(use "AllTotalElim")
(assume "n")
(ng)
(use "BooleIfTotal")
(use "BooleTotalVar")
(use "NatTotalVar")
(use "NatTotalVar")
;; Proof finished.
(save-totality)

;; VProp1
(set-goal "all c(V c*V c<=c andnc c<=V c*V c+V c+V c)")
(ind)
(split)
(use "Truth")
(use "Truth")
(assume "c" "IH")
(split)
(ng #t)
(cases (pt "c<V c*V c+V c+V c"))
(assume "c<V c*V c+V c+V c")
(ng #t)
(use "NatLeTrans" (pt "c"))
(use "IH")
(use "Truth")
(assume "c<V c*V c+V c+V c -> F")
(ng #t)
(use "NatNotLtToLe")
(use "c<V c*V c+V c+V c -> F")
(ng #t)
(cases (pt "c<V c*V c+V c+V c"))
(assume "c<V c*V c+V c+V c")
(ng #t)
(use "NatLtToSuccLe")
(use "c<V c*V c+V c+V c")
(assume "c<V c*V c+V c+V c -> F")
(ng #t)
(use "NatLeTrans" (pt "Succ(V c*V c+V c+V c+V c+V c)"))
(use "NatLeTrans" (pt "V c*V c+V c+V c+V c+V c"))
(use "NatLeTrans" (pt "V c*V c+V c+V c+V c"))
(use "NatLeTrans" (pt "V c*V c+V c+V c"))
(use "IH")
(use "Truth")
(use "Truth")
(use "Truth")
(use "Truth")
;; Proof finished.
(save "VProp1")

;; VProp2
(set-goal "all k,c(k*k<=c -> c<=k*k+k+k -> k=V c)")
(assume "k" "c" "k*k<=c" "c<=k*k+k+k")
(use "NatLeAntiSym")
(use "NatNotLtToLe")
(assume "V c<k")
(assert "(V c+1)*(V c+1)<(V c+1)*(V c+1)")
  (use "NatLeLtTrans" (pt "c"))
  (use "NatLeTrans" (pt "k*k"))
  (use "NatLeMonTimes")
  (use "NatLtToSuccLe")
  (use "V c<k")
  (use "NatLtToSuccLe")
  (use "V c<k")
  (use "k*k<=c")
  (ng #t)
  (use "NatLeToLtSucc")
  (use "VProp1")
(assume "Absurd")
(use "Absurd")

(use "NatNotLtToLe")
(assume "k<V c")
(assert "(k+1)*(k+1)<(k+1)*(k+1)")
  (use "NatLeLtTrans" (pt "c"))
  (use "NatLeTrans" (pt "V c*V c"))
  (use "NatLeMonTimes")
  (use "NatLtToSuccLe")
  (use "k<V c")
  (use "NatLtToSuccLe")
  (use "k<V c")
  (use "VProp1")
  (ng #t)
  (use "NatLeToLtSucc")
  (use "c<=k*k+k+k")
(assume "Absurd")
(use "Absurd")
;; Proof finished.
(save "VProp2")

;; LProp
(set-goal "all n,m L(Code n m)=n")
(assume "n" "m")
(cut "all c(c=Code n m -> L c=n)")
 (assume "Hyp")
 (inst-with-to "Hyp" (pt "Code n m") "HypInst")
 (use "HypInst")
 (use "Truth")
(assume "c" "cDef")
(cases (pt "m<n"))
;; Case m<n
(assume "m<n")
(assert "c=n*n+m")
 (simp "cDef")
 (ng #t)
 (simp "m<n")
 (use "Truth")
(assume "c=n*n+m")

(assert "n=V c")
 (use "VProp2")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n")
 (use "Truth")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n")
 (ng #t)
 (use "NatLeTrans" (pt "n*n+n"))
 (use "NatLeMonPlus")
 (use "Truth")
 (use "NatLtToLe")
 (use "m<n")
 (use "Truth")
(assume "n=V c")

(ng #t)
(simp "<-" "n=V c")
(assert "c<n*n+n")
 (simp "c=n*n+m")
 (use "NatLtMonPlus2")
 (use "Truth")
 (use "m<n")
(assume "c<n*n+n")
(simp "c<n*n+n")
(use "Truth")

;; Case m<n -> F
(assume "m<n -> F")
(assert "c=m*m+m+n")
 (simp "cDef")
 (ng #t)
 (simp "m<n -> F")
 (use "Truth")
(assume "c=m*m+m+n")

(assert "m=V c")
 (use "VProp2")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n -> F")
 (ng #t)
 (use "NatLeTrans" (pt "m*m+m"))
 (use "Truth")
 (use "Truth")
 (simp "c=m*m+m+n")
 (use "NatLeMonPlus")
 (use "Truth")
 (use "NatNotLtToLe")
 (use "m<n -> F")
(assume "m=V c")

(ng #t)
(simp "<-" "m=V c")
(assert "c<m*m+m -> F")
 (simp "c=m*m+m+n")
 (assume "m*m+m+n<m*m+m")
 (assert "m*m+m<m*m+m")
  (use "NatLeLtTrans" (pt "m*m+m+n"))
  (use "Truth")
  (use "m*m+m+n<m*m+m")
 (assume "Absurd")
 (use "Absurd")
(assume "c<m*m+m -> F")
(simp "c<m*m+m -> F")
(ng #t)
(simp "c=m*m+m+n")
(ng #t)
(use "Truth")
;; Proof finished.
(save "LProp")

;; RProp
(set-goal "all n,m R(Code n m)=m")
(assume "n" "m")
(cut "all c(c=Code n m -> R c=m)")
 (assume "Hyp")
 (inst-with-to "Hyp" (pt "Code n m") "HypInst")
 (use "HypInst")
 (use "Truth")
(assume "c" "cDef")
(cases (pt "m<n"))
;; Case m<n
(assume "m<n")
(assert "c=n*n+m")
 (simp "cDef")
 (ng #t)
 (simp "m<n")
 (use "Truth")
(assume "c=n*n+m")

(assert "n=V c")
 (use "VProp2")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n")
 (use "Truth")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n")
 (ng #t)
 (use "NatLeTrans" (pt "n*n+n"))
 (use "NatLeMonPlus")
 (use "Truth")
 (use "NatLtToLe")
 (use "m<n")
 (use "Truth")
(assume "n=V c")

(ng #t)
(simp "<-" "n=V c")
(assert "c<n*n+n")
 (simp "c=n*n+m")
 (use "NatLtMonPlus2")
 (use "Truth")
 (use "m<n")
(assume "c<n*n+n")
(simp "c<n*n+n")
(simp "c=n*n+m")
(use "Truth")

;; Case m<n -> F
(assume "m<n -> F")
(assert "c=m*m+m+n")
 (simp "cDef")
 (ng #t)
 (simp "m<n -> F")
 (use "Truth")
(assume "c=m*m+m+n")

(assert "m=V c")
 (use "VProp2")
 (simp "cDef")
 (drop "cDef")
 (ng #t)
 (simp "m<n -> F")
 (ng #t)
 (use "NatLeTrans" (pt "m*m+m"))
 (use "Truth")
 (use "Truth")
 (simp "c=m*m+m+n")
 (use "NatLeMonPlus")
 (use "Truth")
 (use "NatNotLtToLe")
 (use "m<n -> F")
(assume "m=V c")

(ng #t)
(simp "<-" "m=V c")
(assert "c<m*m+m -> F")
 (simp "c=m*m+m+n")
 (assume "m*m+m+n<m*m+m")
 (assert "m*m+m<m*m+m")
  (use "NatLeLtTrans" (pt "m*m+m+n"))
  (use "Truth")
  (use "m*m+m+n<m*m+m")
 (assume "Absurd")
 (use "Absurd")
(assume "c<m*m+m -> F")
(simp "c<m*m+m -> F")
(use "Truth")
;; Proof finished.
(save "RProp")

;; CodeSurj (not needed)
(set-goal "all c Code(L c)(R c)=c")
(assume "c")
(cut "all n,m(n=L c -> m=R c -> Code n m=c)")
 (assume "Hyp")
 (inst-with-to "Hyp" (pt "L c") "HypInst")
 (inst-with-to "HypInst" (pt "R c") "HypInstInst")
 (use "HypInstInst")
 (use "Truth")
 (use "Truth")
(assume "n" "m" "n=L c" "m=R c")
(ng "n=L c" "m=R c")
(cases (pt "c<V c*V c+V c"))
;; Case c<V c*V c+V c
(assume "c<V c*V c+V c")
(simphyp-with-to "n=L c" "c<V c*V c+V c" "n=V c")
(ng "n=V c")
(simphyp-with-to "m=R c" "c<V c*V c+V c" "m=c--V c*V c")
(ng "m=c--V c*V c")
(drop "n=L c" "m=R c")

(assert "all nat1,nat2,nat3(nat1+nat3<nat2+nat3 -> nat1<nat2)")
 (assume "nat1" "nat2")
 (ind)
 ;; Base
 (assume "Hyp")
 (use "Hyp")
 ;; Step
 (assume "nat3" "IH" "Hyp")
 (use "IH")
 (use "Hyp")
(assume "NatLtMonPlusRev")

(assert "c--V c*V c<V c")
 (use "NatLtMonPlusRev" (pt "V c*V c"))
 (assert "c--V c*V c+V c*V c=c")
  (use "NatMinusPlusEq")
  (use "VProp1")
 (assume "EqHyp")
 (simp "EqHyp")
 (simp "NatPlusComm")
 (use "c<V c*V c+V c")
(assume "c--V c*V c<V c")
(assert "m<n")
 (simp "n=V c")
 (simp "m=c--V c*V c")
 (use "c--V c*V c<V c")
(assume "m<n")
(ng #t)
(simp "m<n")
(ng #t)
(simp "n=V c")
(simp "m=c--V c*V c")
(ng #t)
(simp "NatPlusMinus")
(use "Truth")
(use "VProp1")

;; Case "c<V c*V c+V c -> F"
(assume "c<V c*V c+V c -> F")
(simphyp-with-to "n=L c" "c<V c*V c+V c -> F" "n=c--(V c*V c+V c)")
(ng "n=c--(V c*V c+V c)")
(simphyp-with-to "m=R c" "c<V c*V c+V c -> F" "m=V c")
(ng "m=V c")
(drop "n=L c" "m=R c")

(assert "c--(V c*V c+V c)<=V c")
 (assert "c--(V c*V c+V c)<=V c*V c+V c+V c--(V c*V c+V c)")
 (use "NatLeMonMinus")
 (use "VProp1")
 (use "Truth")
(assume "c-(k*k+k)<=k")
(ng "c-(k*k+k)<=k")
(use "c-(k*k+k)<=k")
(assume "c-(k*k+k)<=k")
(assert "m<n -> F")
 (simp "m=V c")
 (simp "n=c--(V c*V c+V c)")
 (assume "k<c-(k*k+k)")
 (assert "V c<V c")
  (use "NatLtLeTrans" (pt "c--(V c*V c+V c)"))
  (use "k<c-(k*k+k)")
  (use "c-(k*k+k)<=k")
 (assume "Absurd")
 (use "Absurd")
(assume "m<n -> F")
(ng #t)
(simp "m<n -> F")
(simp "m=V c")
(simp "n=c--(V c*V c+V c)")
(ng #t)
(simp "NatPlusMinus")
(use "Truth")
(use "NatNotLtToLe")
(use "c<V c*V c+V c -> F")
;; Proof finished.
(save "CodeSurj")

;; CodeInj1
(set-goal "all n1,n2,m1,m2(Code n1 m1=Code n2 m2 -> n1=n2)")
(assume "n1" "n2" "m1" "m2" "c1=c2")
(assert "L(Code n1 m1)=L(Code n2 m2)")
 (simp "c1=c2")
 (use "Truth")
 (simp "LProp")
 (simp "LProp")
(assume "n1=n2")
(use "n1=n2")
;; Proof finished.
(save "CodeInj1")

;; CodeInj2
(set-goal "all n1,n2,m1,m2(Code n1 m1=Code n2 m2 -> m1=m2)")
(assume "n1" "n2" "m1" "m2" "c1=c2")
(assert "R(Code n1 m1)=R(Code n2 m2)")
 (simp "c1=c2")
 (use "Truth")
 (simp "RProp")
 (simp "RProp")
(assume "m1=m2")
(use "m1=m2")
;; Proof finished.
(save "CodeInj2")

;; CodeProp1
(set-goal "all n,m,l(l=n max m ->  Code n m<Succ l*Succ l)")
(assume "n" "m" "l" "EqHyp")
(ng #t)
(cases (pt "m<n"))
;; Case "m<n"
(ng #t)
(assume "m<n") ;will not be used.
(use "NatLeLtTrans" (pt "n*n+l"))
(simp "EqHyp")
(use "NatLeMonPlus")
(use "Truth")
(use "NatMaxUB2")
(use "NatLeLtTrans" (pt "l*l+l"))
(use "NatLeMonPlus")
(use "NatLeMonTimes")
(simp "EqHyp")
(use "NatMaxUB1")
(simp "EqHyp")
(use "NatMaxUB1")
(use "Truth")
(use "NatLeToLtSucc")
(use "Truth")
;; Case "m<n -> F"
(assume "m<n -> F")
(ng #t)
(use "NatLeLtTrans" (pt "m*m+m+l"))
(simp "EqHyp")
(use "NatLeMonPlus")
(use "Truth")
(use "NatMaxUB1")
(use "NatLeLtTrans" (pt "l*l+l+l"))
(use "NatLeMonPlus")
(use "NatLeMonPlus")
(use "NatLeMonTimes")
(simp "EqHyp")
(use "NatMaxUB2")
(simp "EqHyp")
(use "NatMaxUB2")
(simp "EqHyp")
(use "NatMaxUB2")
(use "Truth")
(use "NatLeToLtSucc")
(use "Truth")
;; Proof finished.
(save "CodeProp1")

;; "CodeProp2" (not used)
(set-goal "all n,m,l(l=n max m ->  l*l<=Code n m)")
(assume "n" "m" "l" "l=n max m")
(ng #t)
(assert "all nat1,nat2(nat1 max nat2=nat1 ori nat1 max nat2=nat2)")
 (ind)
 ;; Base
 (assume "nat2")
 (intro 1)
 (use "Truth-Axiom")
 ;; Step
 (assume "nat1" "IH")
 (cases)
 (intro 0)
 (use "Truth-Axiom")
 (use "IH")
(assume "NatMaxOr")
(cases (pt "m<n"))
;; Case "m<n"
(ng #t)
(assume "m<n")
(assert "n max m=n ori n max m=m")
 (use "NatMaxOr")
(assume "Disj")
(elim "Disj")
(assume "n max m=n")
(simp "l=n max m")
(simp "n max m=n")
(use "Truth")
(assume "n max m=m")
(simp "l=n max m")
(simp "n max m=m")
(use "NatLeTrans" (pt "n*n"))
(use "NatLeMonTimes")
(use "NatLtToLe")
(use "m<n")
(use "NatLtToLe")
(use "m<n")
(use "Truth")
;; Case "m<n -> F"
(assume "m<n -> F")
(ng #t)
(assert "n max m=n ori n max m=m")
 (use "NatMaxOr")
(assume "Disj")
(elim "Disj")
(assume "n max m=n")
(simp "l=n max m")
(simp "n max m=n")
(assert "n<=m")
 (use "NatNotLtToLe")
 (use "m<n -> F")
(assume "n<=m")
(use "NatLeTrans" (pt "m*m"))
(use "NatLeMonTimes")
(use "n<=m")
(use "n<=m")
(use "NatLeTrans" (pt "m*m+m"))
(use "Truth")
(use "Truth")
(assume "n max m=m")
(simp "l=n max m")
(simp "n max m=m")
(use "NatLeTrans" (pt "m*m+m"))
(use "Truth")
(use "Truth")
;; Proof finished.
(save "CodeProp2")

;; CodeSqFill
(set-goal "all n,m,k(k*k<=Code n m -> k<=n ori k<=m)")
(assume "n" "m" "k")
(assert "all nat1,nat2(nat1 max nat2=nat1 ori nat1 max nat2=nat2)")
 (ind)
 ;; Base
 (assume "nat2")
 (intro 1)
 (use "Truth-Axiom")
 ;; Step
 (assume "nat1" "IH")
 (cases)
 (intro 0)
 (use "Truth-Axiom")
 (use "IH")
(assume "NatMaxOr")
(cut "all l(l=n max m -> k*k<=Code n m -> k<=n ori k<=m)")
 (assume "Hyp")
 (use "Hyp" (pt "n max m"))
 (use "Truth")
(assume "l" "l=n max m" "LeHyp")
(cut "k<=l")
 (assert "n max m=n ori n max m=m")
  (use "NatMaxOr")
 (assume "Disj")
 (elim "Disj")

 (assume "n max m=n")
 (simp "l=n max m")
 (simp "n max m=n")
 (assume "k<=n")
 (intro 0)
 (use "k<=n")

 (assume "n max m=m")
 (simp "l=n max m")
 (simp "n max m=m")
 (assume "k<=m")
 (intro 1)
 (use "k<=m")

;; ?_9: k<=l
(use "NatNotLtToLe")
(assume "l<k")
(cut "k*k<k*k")
 (assume "Absurd")
 (use "Absurd")
(use "NatLeLtTrans" (pt "Code n m"))
(use "LeHyp")
(use "NatLtLeTrans" (pt "Succ l*Succ l"))
(use "CodeProp1")
(use "l=n max m")
(use "NatLeMonTimes")
(use "NatLtToSuccLe")
(use "l<k")
(use "NatLtToSuccLe")
(use "l<k")
;; Proof finished.
(save "CodeSqFill")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(ppc neterm)
;; [n,n0,n1]
;;  (Rec nat=>nat=>boole)n([n2]False)
;;  ([n2,(nat=>boole),n3][case n3 (0 -> True) (Succ n -> (nat=>boole)n)])
;;  n0

;; FPHDisjTwo
(set-goal "all f,g,k(
 exnc i,j(i<j andi j<=k*k andi f i = f j andi g i = g j) ori
 exl j(j<=k*k andi k<=f j)  ori
 exl j(j<=k*k andi k<=g j))")
(assume "f" "g" "k")
(inst-with-to "FPHDisj" (pt "k*k") (pt "[i]Code(f i)(g i)") "FPHDisjInst")
(elim "FPHDisjInst")
(drop "FPHDisjInst")
;; First case
(assume "ExHyp")
(by-assume "ExHyp" "i" "iProp")
(by-assume "iProp" "j" "ijProp")
(intro 0)
(intro 0 (pt "i"))
(intro 0 (pt "j"))
(assert "Code(f i)(g i)=Code(f j)(g j)")
 (use "ijProp")
(assume "ci=cj")
(msplit)
(use "CodeInj2" (pt "f i") (pt "f j"))
(use "ci=cj")
(use "CodeInj1" (pt "g i") (pt "g j"))
(use "ci=cj")
(use "ijProp")
(use "ijProp")
;; Second case
(drop "FPHDisjInst")
(assume "ExHyp")
(by-assume "ExHyp" "j" "jProp")
(intro 1)
(assert "k*k<=Code(f j)(g j)")
 (use "jProp")
(assume "k*k<=c")
(assert "k<=f j oru k<=g j")
 (use "CodeSqFill")
 (use "k*k<=c")
(assume "Disj")
(elim "Disj")
(drop "Disj")
;; Case k<=f j
(assume "k<=f j")
(intro 0)
(intro 0 (pt "j"))
(split)
(use "jProp")
(use "k<=f j")
;; Case k<=g j
(assume "k<=g j")
(intro 1)
(intro 0 (pt "j"))
(split)
(use "jProp")
(use "k<=g j")
;; Proof finished.
(save "FPHDisjTwo")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(pp neterm)

;; [f,g,n]
;;  [if (cFPHDisj(n*n)
;;        ([n0][if (g n0<f n0)
;;                 (f n0*f n0+g n0)
;;                 (g n0*g n0+g n0+f n0)]))
;;    ([ij](DummyL nat ysum nat))
;;    ([n0]
;;     Inr[if (cCodeSqFill(f n0)(g n0)n)
;;            ((InL nat nat)n0)
;;            ((InR nat nat)n0)])]

;; Key
(set-goal "all f,g,n,k(
 exnc i,j(n<i andi i<j andi j<=Succ n+k*k andi f i = f j andi g i = g j) ori
 exl j(n<j andi j<=Succ n+k*k andi k<=f j)  ori
 exl j(n<j andi j<=Succ n+k*k andi k<=g j))")
(assume "f" "g" "n" "k")
(inst-with-to
 "FPHDisjTwo" (pt "[i]f(Succ n+i)") (pt "[i]g(Succ n+i)") (pt "k")
 "FPHInst")
(elim "FPHInst")
;; First case
(drop "FPHInst")
(assume "ExHyp")
(intro 0)
(by-assume "ExHyp" "i" "iProp")
(by-assume "iProp" "j" "ijProp")
(intro 0 (pt "Succ n+i"))
(intro 0 (pt "Succ n+j"))
(msplit)
(use "ijProp")
(use "ijProp")
(use "NatLeMonPlus")
(use "Truth")
(use "ijProp")
(use "NatLtMonPlus2")
(use "Truth")
(use "ijProp")
(use "NatLeToLtSucc")
(use "Truth")
;; Second or third case
(drop "FPHInst")
(assume "Disj")
(intro 1)
(elim "Disj")
;; Second case
(drop "Disj")
(assume "ExHyp")
(intro 0)
(by-assume "ExHyp" "j" "jProp")
(intro 0 (pt "Succ n+j"))
(msplit)
(use "jProp")
(use "NatLeMonPlus")
(use "Truth")
(use "jProp")
(use "NatLeToLtSucc")
(use "Truth")
;; Third case
(drop "Disj")
(assume "ExHyp")
(intro 1)
(by-assume "ExHyp" "j" "jProp")
(intro 0 (pt "Succ n+j"))
(msplit)
(use "jProp")
(use "NatLeMonPlus")
(use "Truth")
(use "jProp")
(use "NatLeToLtSucc")
(use "Truth")
;; Proof finished.
(save "Key")

(define eterm (proof-to-extracted-term))
(add-var-name "nn" (py "nat ysum nat"))
(define neterm (rename-variables (nt eterm)))
(pp neterm)
;; [f,f0,n,n0]
;;  [if (cFPHDisjTwo([n1]f(Succ(n+n1)))([n1]f0(Succ(n+n1)))n0)
;;    (DummyL nat ysum nat)
;;    ([nn]
;;     Inr[if nn ([n1](InL nat nat)(Succ(n+n1)))
;;               ([n1](InR nat nat)(Succ(n+n1)))])]
(ppc neterm)
;; [f,g,n,n0]
;;  [case (cFPHDisjTwo([n1]f(Succ(n+n1)))([n1]g(Succ(n+n1)))n0)
;;    (DummyL -> DummyL)
;;    (Inr nn -> 
;;    Inr[case nn
;; 	(InL n1 -> InL(Succ(n+n1)))
;; 	(InR n1 -> InR(Succ(n+n1)))])]

(add-program-constant "Mini" (py "(nat=>nat)=>nat=>nat"))
(add-computation-rules
 "Mini f 0" "0"
 "Mini f(Succ n)" "[if (f(Mini f n)<=f(Succ n)) (Mini f n) (Succ n)]")

(set-totality-goal "Mini")
(assume "f^" "Tf" "n^" "Tn")
(elim "Tn")
(use "TotalNatZero")
(assume "n^1" "Tn1" "IH")
(ng #t)
(use "BooleIfTotal")
(use "NatLeTotal")
(use "Tf")
(use "IH")
(use "Tf")
(use "TotalNatSucc")
(use "Tn1")
(use "IH")
(use "TotalNatSucc")
(use "Tn1")
;; Proof finished.
(save-totality)

(add-program-constant "Psi" (py "(nat=>nat)=>(nat=>nat)=>nat=>nat"))
(add-computation-rule "Psi f g n" "f(Mini g n)max g(Mini f n)")

(set-totality-goal "Psi")
(assume "f^" "Tf" "g^" "Tg" "n^" "Tn")
(use "NatMaxTotal")
(use "Tf")
(use "MiniTotal")
(use "Tg")
(use "Tn")
(use "Tg")
(use "MiniTotal")
(use "Tf")
(use "Tn")
;; Proof finished.
(save "PsiTotal")

(add-program-constant "I" (py "(nat=>nat)=>(nat=>nat)=>nat=>nat"))
(add-computation-rule "I f g n" "Succ(n+Psi f g n*Psi f g n)")

(set-totality-goal "I")
(assume "f^" "Tf" "g^" "Tg" "n^" "Tn")
(use "TotalNatSucc")
(use "NatPlusTotal")
(use "Tn")
(use "NatTimesTotal")
(use "NatMaxTotal")
(use "Tf")
(use "MiniTotal")
(use "Tg")
(use "Tn")
(use "Tg")
(use "MiniTotal")
(use "Tf")
(use "Tn")

(use "NatMaxTotal")
(use "Tf")
(use "MiniTotal")
(use "Tg")
(use "Tn")
(use "Tg")
(use "MiniTotal")
(use "Tf")
(use "Tn")
;; Proof finished.
(save-totality)

(add-program-constant "ItI" (py "(nat=>nat)=>(nat=>nat)=>nat=>nat=>nat"))
(add-computation-rules
 "ItI f g 0 n" "n"
 "ItI f g(Succ m)n" "I f g(ItI f g m n)")

(set-totality-goal "ItI")
(assume "f^" "Tf" "g^" "Tg" "m^" "Tm" "n^" "Tn")
(elim "Tm")
(use "Tn")
(assume "n^1" "Tn1" "IH")
(use "ITotal")
(use "Tf")
(use "Tg")
(use "IH")
;; Proof finished.
(save-totality)

(add-program-constant "Phi" (py "(nat=>nat)=>(nat=>nat)=>nat=>nat"))
(add-computation-rule "Phi f g n" "f(Mini f n)+g(Mini g n)")

(set-totality-goal "Phi")
(assume "f^" "Tf" "g^" "Tg" "n^" "Tn")
(use "NatPlusTotal")
(use "Tf")
(use "MiniTotal")
(use "Tf")
(use "Tn")
(use "Tg")
(use "MiniTotal")
(use "Tg")
(use "Tn")
;; Proof finished.
(save-totality)

;; MiniBound (Mini1)
(set-goal "all f,n Mini f n<=n")
(assume "f")
(ind)
(use "Truth")
(assume "n" "IH")
(cases (pt "f(Mini f n)<=f(Succ n)"))
(assume "LeCase")
(simp "LeCase")
(use "NatLeTrans" (pt "n"))
(use "IH")
(use "Truth")
(assume "NotLeCase")
(simp "NotLeCase")
(use "Truth")
;; Proof finished.
(save "MiniBound")

;; MiniProp (Mini3)
(set-goal "all f,n(f(Mini f n)<=f n)")
(assume "f")
(cases)
(use "Truth")
(assume "n")
(cases (pt "f(Mini f n)<=f(Succ n)"))
(assume "LeCase")
(simp "LeCase")
(use "LeCase")
(assume "NotLeCase")
(simp "NotLeCase")
(use "Truth")
;; Proof finished.
(save "MiniProp")

;; fMiniAntiMon
(set-goal (pf "all f,n,m(n<=m -> f(Mini f m)<=f(Mini f n))"))
(assume "f" "n")
(ind)
;; Base m=0
(assume "n<=0")
(assert (pf "n=0"))
 (use "n<=0")
(assume "n=0")
(simp "n=0")
(use "Truth")
;; m->m+1
(assume "m" "IH")
(assume "n<=Sm")
(use "NatLeCases" (pt "n") (pt "Succ m"))
(use "n<=Sm")
(drop "n<=Sm")
(assume "n<Sm")
(use "NatLeTrans" (pt "f(Mini f m)"))
(cases (pt "f(Mini f m)<=f(Succ m)"))
(assume "LeCase")
(simp "LeCase")
(use "Truth")
(assume "NotLeCase")
(simp "NotLeCase")
(use "NatLtToLe")
(use "NatNotLeToLt")
(use "NotLeCase")
(use "IH")
(use "NatLtSuccToLe")
(use "n<Sm")
(assume "n=Sm")
(simp "n=Sm")
(use "Truth")
;; Proof finished.
(save "fMiniAntiMon")

;; PhiAntiMon
(set-goal (pf "all f,g,n,m(n<=m -> Phi f g m<=Phi f g n)"))
(assume "f" "g" "n" "m" "n<=m")
(use "NatLeMonPlus")
(use "fMiniAntiMon")
(use "n<=m")
(use "fMiniAntiMon")
(use "n<=m")
;; Proof finished.
(save "PhiAntiMon")

;; Desc
(set-goal "all f,g,n(
 exnc i,j(i<j andi j<=I f g n andi f i<=f j andi g i<=g j) ori
 Phi f g(I f g n)<Phi f g n)")
(assume "f" "g" "n")
(inst-with-to "Key" (pt "f") (pt "g") (pt "n") (pt "Psi f g n") "KeyInst")
(elim "KeyInst")
;; First case
(drop "KeyInst")
(assume "ExHyp")
(intro 0)
(by-assume "ExHyp" "i" "iProp")
(by-assume "iProp" "j" "ijProp")
(intro 0 (pt "i"))
(intro 0 (pt "j"))
(msplit)
(simp "ijProp")
(use "Truth")
(simp "ijProp")
(simp "ijProp")
(use "Truth")
(use "ijProp")
(use "ijProp")
;; Remaining two cases
(drop "KeyInst")
(assume "Disj")
(elim "Disj")

;; First the case for f
(drop "Disj")
(assume "ExjHyp")
(by-assume "ExjHyp" "j" "jProp")
(assert "f(Mini g n)<=f j")
 (use "NatLeTrans" (pt "Psi f g n"))
 (use "NatMaxUB1")
 (use "jProp")
(assume "f i<=f j")
(use "NatLeLtCases" (pt "g(Mini g n)") (pt "g j"))
;; Case "g i<=g j"
(assume "g i<=g j")
(intro 0)
(intro 0 (pt "Mini g n"))
(intro 0 (pt "j"))
(msplit)
(use "g i<=g j")
(use "f i<=f j")
(use "jProp")
(use "NatLeLtTrans" (pt "n"))
(use "MiniBound")
(use "jProp")
;; Case "g j<g i"
(assume "g j<g i")
(intro 1)
(use "NatLeLtTrans" (pt "Phi f g j"))
(use "PhiAntiMon")
(use "jProp")
(ng #t)
(use "NatLtMonPlus2")
(use "fMiniAntiMon")
(use "NatLtToLe")
(use "jProp")
(use "NatLeLtTrans" (pt "g j"))
(use "MiniProp")
(use "g j<g i")

;; Now the symmetric case with g for f
(drop "Disj")
(assume "ExjHyp")
(by-assume "ExjHyp" "j" "jProp")
(assert "g(Mini f n)<=g j")
 (use "NatLeTrans" (pt "Psi f g n"))
 (use "NatMaxUB2")
 (use "jProp")
(assume "g i<=g j")
(use "NatLeLtCases" (pt "f(Mini f n)") (pt "f j"))
;; Case "f i<=f j"
(assume "f i<=f j")
(intro 0)
(intro 0 (pt "Mini f n"))
(intro 0 (pt "j"))
(msplit)
(use "g i<=g j")
(use "f i<=f j")
(use "jProp")
(use "NatLeLtTrans" (pt "n"))
(use "MiniBound")
(use "jProp")
;; Case "f j<f i"
(assume "f j<f i")
(intro 1)
(use "NatLeLtTrans" (pt "Phi f g j"))
(use "PhiAntiMon")
(use "jProp")
(ng #t)
(simp "NatPlusComm")
(assert "f(Mini f n)+g(Mini g n)=g(Mini g n)+f(Mini f n)")
 (use "NatPlusComm")
(assume "EqHyp")
(simp "EqHyp")
(use "NatLtMonPlus2")
(use "fMiniAntiMon")
(use "NatLtToLe")
(use "jProp")
(use "NatLeLtTrans" (pt "f j"))
(use "MiniProp")
(use "f j<f i")
;; Proof finished.
(save "Desc")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
(ppc neterm)

;; [f,g,n]
;;  [case (cKey f g n(f(Mini g n)max g(Mini f n)))
;;    (DummyL -> True)
;;    (Inr nn -> 
;;    [case nn
;;      (InL n0 -> cNatLeLtCases(g(Mini g n))(g n0)True False)
;;      (InR n0 -> cNatLeLtCases(f(Mini f n))(f n0)True False)])]

;; "LeIncrI"
(set-goal "all f,g,n n<=I f g n")
(assume "f" "g" "n")
(use "NatLeTrans" (pt "Succ n"))
(use "Truth")
(use "Truth")
;; Proof finished.
(save "LeIncrI")

;; DL
(set-goal "all f,g,n exl k(
 I f g n<=k andi exnc i,j(i<j andi j<=k andi f i<=f j andi g i<=g j))")
(assume "f" "g")
(gind (pt "[n]Phi f g n"))
(assume "n" "IH")
(inst-with-to "Desc" (pt "f") (pt "g") (pt "n") "DescInst")
(elim "DescInst")
(drop "DescInst")
(assume "ExHyp")
(by-assume "ExHyp" "i" "iProp")
(by-assume "iProp" "j" "ijProp")
(intro 0 (pt "I f g n"))
(split)
(use "Truth")
(intro 0 (pt "i"))
(intro 0 (pt "j"))
(msplit)
(use "ijProp")
(use "ijProp")
(use "ijProp")
(use "ijProp")

(assume "LtHyp")
(drop "DescInst")
(inst-with-to "IH" (pt "I f g n") "IHInst")
(drop "IH")
(inst-with-to "IHInst" "LtHyp" "IHInstInst")
(drop "IHInst")
(by-assume "IHInstInst" "k" "kProp")
(intro 0 (pt "k"))
(split)
(use "NatLeTrans" (pt "I f g(I f g n)"))
(use "LeIncrI")
(use "kProp")
(use "kProp")
; Proof finished.
(save "DL")

(define eterm (proof-to-extracted-term))
(remove-computation-rules-for (pt "Phi f g n"))
(remove-computation-rules-for (pt "I f g n"))
(set! GRECGUARD-UNFOLDING-FLAG #f)
(define neterm (rename-variables (nt eterm)))
(pp neterm)

;; [f,f0,n]
;;  (GRecGuard nat nat)(Phi f f0)n
;;  ([n0,f1][if (cDesc f f0 n0) (I f f0 n0) (f1(I f f0 n0))])
;;  True

;; Test
;; Let extrbd be the term extracted from the proof of DL

(animate "Desc")
(animate "Key")
(animate "FPHDisjTwo")
(animate "FPHDisj")
(animate "CodeSqFill")
(animate "NatLeLtCases")
(define neterm (rename-variables (nt eterm)))
(pp neterm)

;; [f,f0,n]
;;  (GRecGuard nat nat)(Phi f f0)n
;;  ([n0,f1]
;;    [if ((Rec nat=>(nat=>nat)=>nat@@nat ysum nat)
;;          (f(Mini f0 n0)max f0(Mini f n0)*(f(Mini f0 n0)max f0(Mini f n0)))
;;          ([f2](InR nat nat@@nat)0)
;;          ([n1,d,f2]
;;            [let n2
;;              [if (f2(Succ n1)<=f2(Maxi f2 n1)) (Maxi f2 n1) (Succ n1)]
;;              [if (Succ n1<=f2 n2)
;;               ((InR nat nat@@nat)n2)
;;               [if (d([n3][if (n3<n2) (f2 n3) (f2(Succ n3))]))
;;                ([ij]
;;                 (InL nat@@nat nat)
;;                 [if (right ij<n2)
;;                   ij
;;                   ([if (left ij<n2) (left ij) (Succ left ij)]@Succ right ij)])
;;                ([n3]
;;                 [if (n3<n2)
;;                   ((cNatLeCases nat@@nat ysum nat)(f2 n2)
;;                   (f2[if (n3<n2) n3 (Succ n3)])
;;                   ((InL nat@@nat nat)(0@0))
;;                   ((InL nat@@nat nat)([if (n3<n2) n3 (Succ n3)]@n2)))
;;                   ((cNatLeCases nat@@nat ysum nat)(f2 n2)
;;                   (f2[if (n3<n2) n3 (Succ n3)])
;;                   ((InL nat@@nat nat)(0@0))
;;                   ((InL nat@@nat nat)(n2@[if (n3<n2) n3 (Succ n3)])))])]]])
;;          ([n1]
;;            [if (f0(Succ(n0+n1))<f(Succ(n0+n1)))
;;              (f(Succ(n0+n1))*f(Succ(n0+n1))+f0(Succ(n0+n1)))
;;              (f0(Succ(n0+n1))*f0(Succ(n0+n1))+f0(Succ(n0+n1))+f(Succ(n0+n1)))]))
;;      ([ij]I f f0 n0)
;;      ([n1]
;;       [if [if [if ((Rec nat=>nat=>boole)(f(Succ(n0+n1)))([n2]False)
;;                       ([n2,(nat=>boole),n3][if n3 True (nat=>boole)])
;;                       (f0(Succ(n0+n1))))
;;                   ((InL nat nat)n1)
;;                   ((InR nat nat)n1)]
;;              ([n2](InL nat nat)(Succ(n0+n2)))
;;              ([n2](InR nat nat)(Succ(n0+n2)))]
;;         ([n2][if (f0(Mini f0 n0)<=f0 n2) (I f f0 n0) (f1(I f f0 n0))])
;;         ([n2][if (f(Mini f n0)<=f n2) (I f f0 n0) (f1(I f f0 n0))])])])
;;  True

(animate "NatLeCases")
(define neterm (rename-variables (nt eterm)))
(pp neterm)

;; [f,f0,n]
;;  (GRecGuard nat nat)(Phi f f0)n
;;  ([n0,f1]
;;    [if ((Rec nat=>(nat=>nat)=>nat@@nat ysum nat)
;;          (f(Mini f0 n0)max f0(Mini f n0)*(f(Mini f0 n0)max f0(Mini f n0)))
;;          ([f2](InR nat nat@@nat)0)
;;          ([n1,d,f2]
;;            [let n2
;;              [if (f2(Succ n1)<=f2(Maxi f2 n1)) (Maxi f2 n1) (Succ n1)]
;;              [if (Succ n1<=f2 n2)
;;               ((InR nat nat@@nat)n2)
;;               [if (d([n3][if (n3<n2) (f2 n3) (f2(Succ n3))]))
;;                ([ij]
;;                 (InL nat@@nat nat)
;;                 [if (right ij<n2)
;;                   ij
;;                   ([if (left ij<n2) (left ij) (Succ left ij)]@Succ right ij)])
;;                ([n3]
;;                 [if (n3<n2)
;;                   [if (f2 n2<f2[if (n3<n2) n3 (Succ n3)])
;;                    ((InL nat@@nat nat)(0@0))
;;                    ((InL nat@@nat nat)([if (n3<n2) n3 (Succ n3)]@n2))]
;;                   [if (f2 n2<f2[if (n3<n2) n3 (Succ n3)])
;;                    ((InL nat@@nat nat)(0@0))
;;                    ((InL nat@@nat nat)(n2@[if (n3<n2) n3 (Succ n3)]))]])]]])
;;          ([n1]
;;            [if (f0(Succ(n0+n1))<f(Succ(n0+n1)))
;;              (f(Succ(n0+n1))*f(Succ(n0+n1))+f0(Succ(n0+n1)))
;;              (f0(Succ(n0+n1))*f0(Succ(n0+n1))+f0(Succ(n0+n1))+f(Succ(n0+n1)))]))
;;      ([ij]I f f0 n0)
;;      ([n1]
;;       [if [if [if ((Rec nat=>nat=>boole)(f(Succ(n0+n1)))([n2]False)
;;                       ([n2,(nat=>boole),n3][if n3 True (nat=>boole)])
;;                       (f0(Succ(n0+n1))))
;;                   ((InL nat nat)n1)
;;                   ((InR nat nat)n1)]
;;              ([n2](InL nat nat)(Succ(n0+n2)))
;;              ([n2](InR nat nat)(Succ(n0+n2)))]
;;         ([n2][if (f0(Mini f0 n0)<=f0 n2) (I f f0 n0) (f1(I f f0 n0))])
;;         ([n2][if (f(Mini f n0)<=f n2) (I f f0 n0) (f1(I f f0 n0))])])])
;;  True

(add-computation-rule "I f g n" "Succ(n+Psi f g n*Psi f g n)")
(add-computation-rule "Phi f g n" "f(Mini f n)+g(Mini g n)")

;; We define two example functions
;; f=(1,0,1,0,0...)
;; g=(1,1,0,0,0...)

(add-program-constant "ExOne" (py "nat=>nat"))
(add-computation-rules
 "ExOne 0" "1"
 "ExOne 1" "0"
 "ExOne 2" "1"
 "ExOne(Succ(Succ(Succ n)))" "0")

(add-program-constant "ExTwo" (py "nat=>nat"))
(add-computation-rules
 "ExTwo 0" "1"
 "ExTwo 1" "1"
 "ExTwo(Succ(Succ 0))" "0")

(set! GRECGUARD-UNFOLDING-FLAG #t)
(animate "Id")

(pp (nt (mk-term-in-app-form neterm (pt "ExOne") (pt "ExTwo") (pt "0"))))
;; 4

