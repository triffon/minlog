;; 2020-08-14.  examplesanalysisgraycode.scm

;; (load "~/git/minlog/init.scm")

;; (set! COMMENT-FLAG #f)
;; (libload "nat.scm")
;; (libload "list.scm")
;; (libload "str.scm")
;; (libload "pos.scm")
;; (libload "int.scm")
;; (libload "rat.scm")
;; (remove-var-name "x" "y" "z")
;; (libload "rea.scm")
;; ;; (set! COMMENT-FLAG #t)

;; (load "~/git/minlog/examples/analysis/digits.scm")
;; (load "~/git/minlog/examples/analysis/sdcode.scm")

(display "loading graycode.scm ...") (newline)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Inductive predicates G and H
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(add-algs (list "ag" "ah")
	  '("boole=>ag=>ag" "LR") ;for left/right
	  '("ah=>ag" "U") ;for undefined
	  '("boole=>ag=>ah" "Fin") ;for finally
	  '("ah=>ah" "D")) ;for delay

;; (display-alg "ag" "ah")
;; ag
;; 	LR:	boole=>ag=>ag
;; 	U:	ah=>ag
;; ah
;; 	Fin:	boole=>ag=>ah
;; 	D:	ah=>ah

(add-eqpnc "ag")

;; ok, inductively defined predicate constant EqPAgNc added
;; ok, inductively defined predicate constant EqPAhNc added

(add-co "EqPAgNc")
;; ok, coinductively defined predicate constant CoEqPAgNc added

;; (display-idpc "CoEqPAgNc")
;; (display-idpc "CoEqPAhNc")

;; (pp (term-to-type (pt "(CoRec gamma1=>ag gamma2=>ah)")))

;; gamma1=>
;; (gamma1=>boole yprod(ag ysum gamma1)ysum ah ysum gamma2)=>
;; (gamma2=>boole yprod(ag ysum gamma1)ysum ah ysum gamma2)=>ag

;; This type can be explicitly generated by

(pp 
(mk-arrow
 (py "gamma1")
 (make-arrow
  (py "gamma1")
  (make-alg "ysum"
	    (make-alg "yprod"
		      (py "boole")
		      (make-alg "ysum" (make-alg "ag") (py "gamma1")))
	    (make-alg "ysum" (make-alg "ah") (py "gamma2"))))
 (make-arrow
  (py "gamma2")
  (make-alg "ysum"
	    (make-alg "yprod"
		      (py "boole")
		      (make-alg "ysum" (make-alg "ag") (py "gamma1")))
	    (make-alg "ysum" (make-alg "ah") (py "gamma2"))))

 (make-alg "ag")))

;; To create the cotype with coag coah instead of ag ah we use

(mk-arrow
 (py "gamma1")
 (make-arrow
  (py "gamma1")
  (make-alg "ysum"
	    (make-alg "yprod"
		      (py "boole")
		      (make-alg "ysum" (make-alg "coag") (py "gamma1")))
	    (make-alg "ysum" (make-alg "coah") (py "gamma2"))))
 (make-arrow
  (py "gamma2")
  (make-alg "ysum"
	    (make-alg "yprod"
		      (py "boole")
		      (make-alg "ysum" (make-alg "coag") (py "gamma1")))
	    (make-alg "ysum" (make-alg "coah") (py "gamma2"))))

 (make-alg "coag"))

(add-ids
  (list (list "G" (make-arity (py "rea")) "ag")
       (list "H" (make-arity (py "rea")) "ah"))
 '("allnc d,x,y(Psd d -> Real x -> abs x<<=1 -> G x ->
                y===(1#2)*(x+IntN 1)* ~d -> G y)" "GenLR")
 '("allnc x,y(Real x -> abs x<<=1 -> H x -> y===(1#2)*x -> G y)" "GenU")
 '("allnc d,x,y(Psd d -> Real x -> abs x<<=1 -> G x ->
                y===(1#2)*(x+1)*d -> H y)" "GenFin")
 '("allnc x,y(Real x -> abs x<<=1 -> H x -> y===(1#2)*x -> H y)" "GenD"))

(add-mr-ids "G")

;; ok, inductively defined predicate constant GMR added
;; ok, inductively defined predicate constant HMR added

(add-co "GMR")

;; ok, coinductively defined predicate constant CoGMR added
;; ok, coinductively defined predicate constant CoHMR added
;; ok, CoGMRClause has been added as a new theorem.
;; ok, CoHMRClause has been added as a new theorem.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; General properties of G
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; We add the companion predicate CoG for G, meant to be the
;; greatest-fixed-point of the G clauses.

(add-co "G" (list "RealEq") (list "RealEq"))
;; (pp "CoGClause")

;; allnc x(
;;  CoG x -> 
;;  exr d,x0,y(
;;   Psd d andd 
;;   Real x0 andr 
;;   abs x0<<=1 andr CoG x0 andl y===(1#2)*(x0+IntN 1)* ~d andnc x===y) ord 
;;  exr x0,y(Real x0 andr abs x0<<=1 andr CoH x0 andl y===(1#2)*x0 andnc x===y))

;; (pp "CoHClause")

;; allnc x(
;;  CoH x -> 
;;  exr d,x0,y(
;;   Psd d andd Real x0 andr CoG x0 andl y===(1#2)*(x0+1)*d andnc x===y) ord 
;;  exr x0,y(Real x0 andr CoH x0 andl y===(1#2)*x0 andnc x===y))

;; Preparations for AgCoRecExtNc and GfpCoGMR

(pp (term-to-type (pt "(CoRec gamma1=>ag gamma2=>ah)")))

;; gamma1=>
;; (gamma1=>boole yprod(ag ysum gamma1)ysum ah ysum gamma2)=>
;; (gamma2=>boole yprod(ag ysum gamma1)ysum ah ysum gamma2)=>ag

(remove-pvar-name "X" "XMR")

(add-pvar-name "X" (make-arity (py "rea")))
(set! PVAR-TO-TVAR-ALIST
      (cons (list (predicate-form-to-predicate (pf "X rea")) (py "gamma1"))
	     PVAR-TO-TVAR-ALIST))
(add-pvar-name "XMR" (make-arity (py "rea") (py "gamma1")))
(set! PVAR-TO-MR-PVAR-ALIST
      (cons (list (predicate-form-to-predicate (pf "X rea"))
		  (predicate-form-to-predicate (pf "XMR^ rea gamma1")))
	    PVAR-TO-MR-PVAR-ALIST))

(add-pvar-name "Y" (make-arity (py "rea")))
(set! PVAR-TO-TVAR-ALIST
      (cons (list (predicate-form-to-predicate (pf "Y rea")) (py "gamma2"))
	     PVAR-TO-TVAR-ALIST))
(add-pvar-name "YMR" (make-arity (py "rea") (py "gamma2")))
(set! PVAR-TO-MR-PVAR-ALIST
      (cons (list (predicate-form-to-predicate (pf "Y rea"))
		  (predicate-form-to-predicate (pf "YMR^ rea gamma2")))
	    PVAR-TO-MR-PVAR-ALIST))

;; Introduce new var-names, as in soundext.scm
;; (display-default-varnames)
(remove-var-name "u")
(remove-var-name "v")

(add-var-name "u" (py "gamma1"))
(add-var-name "v" (py "gamma2"))
(add-var-name
 "gu" (py "gamma1=>boole yprod(ag ysum gamma1)ysum ah ysum gamma2"))
(add-var-name
 "gv" (py "gamma2=>boole yprod(ag ysum gamma1)ysum ah ysum gamma2"))
(add-var-name "bgsu" (py "boole yprod(ag ysum gamma1)"))
(add-var-name "gsu" (py "ag ysum gamma1"))
(add-var-name "hsv" (py "ah ysum gamma2"))

(animate "Lft")
(animate "Rht")

;; Preparations for GfpCoGMR

;; AgCoRecLL
(set-goal "allnc gu^,u^,boole^,ag^,gv^(
     gu^ u^ eqd
     (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
     (boole^ pair(InL ag gamma1)ag^) -> 
     (CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^ eqd LR boole^ ag^)") 
(assume "gu^" "u^" "boole^" "ag^" "gv^" "EqHyp")
(simp-with (make-proof-in-aconst-form
	    (alg-or-arrow-types-to-corec-aconst
	     (py "gamma1=>ag") (py "gamma2=>ah"))))
(ng)
(simp-with "EqHyp")
(ng)
(use "InitEqD")
;; Proof finished.
;; (cdp)
(save "AgCoRecLL")

;; AgCoRecLR
(set-goal "allnc gu^,u^,boole^,u^1,gv^(
     gu^ u^ eqd
     (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
     (boole^ pair(InR gamma1 ag)u^1) -> 
     (CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^ eqd 
     LR boole^((CoRec gamma1=>ag gamma2=>ah)u^1 gu^ gv^))")
(assume "gu^" "u^" "boole^" "u^1" "gv^" "EqHyp")
(assert "allnc ag^(
 LR boole^((CoRec gamma1=>ag gamma2=>ah)u^1 gu^ gv^)eqd ag^ ->
 (CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^ eqd ag^)")
(assume "ag^" "EqHyp1")
(simp-with (make-proof-in-aconst-form
	    (alg-or-arrow-types-to-corec-aconst
	     (py "gamma1=>ag") (py "gamma2=>ah"))))
(ng)
(simp "EqHyp")
(ng)
(use "EqHyp1")
;; Assertion proved.
(assume "Assertion")
(use "Assertion")
(use "InitEqD")
;; Proof finished.
;; (cdp)
(save "AgCoRecLR")

;; AgCoRecRL
(set-goal "allnc gu^,u^,ah^,gv^(
     gu^ u^ eqd
     (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))
     ((InL ah gamma2)ah^) -> 
     (CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^ eqd U ah^)")
(assume "gu^" "u^" "ah^" "gv^" "EqHyp")
(simp-with (make-proof-in-aconst-form
	    (alg-or-arrow-types-to-corec-aconst
	     (py "gamma1=>ag") (py "gamma2=>ah"))))
(ng)
(simp-with "EqHyp")
(ng)
(use "InitEqD")
;; Proof finished.
;; (cdp)
(save "AgCoRecRL")

;; AgCoRecRR
(set-goal "allnc gu^,u^,gv^,v^(
  gu^ u^ eqd
     (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))
     ((InR gamma2 ah)v^) -> 
     (CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^ eqd
     U((CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^))")
(assume "gu^" "u^" "gv^" "v^" "EqHyp")
(assert "allnc ag^(
 U((CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^)eqd ag^ ->
 (CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^ eqd ag^)")
(assume "ag^" "EqHyp1")
(simp-with (make-proof-in-aconst-form
	    (alg-or-arrow-types-to-corec-aconst
	     (py "gamma1=>ag") (py "gamma2=>ah"))))
(ng)
(simp "EqHyp")
(ng)
(use "EqHyp1")
;; Assertion proved.
(assume "Assertion")
(use "Assertion")
(use "InitEqD")
;; Proof finished.
;; (cdp)
(save "AgCoRecRR")

;; AhCoRecLL
(set-goal "allnc gv^,v^,boole^,ag^,gu^(
 gv^ v^ eqd
 (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
 (boole^ pair(InL ag gamma1)ag^) ->
 (CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^ eqd Fin boole^ ag^)")
(assume "gv^" "v^" "boole^" "ag^" "gu^" "EqHyp")
(simp-with (make-proof-in-aconst-form
	    (alg-or-arrow-types-to-corec-aconst
	     (py "gamma2=>ah") (py "gamma1=>ag"))))
(ng)
(simp-with "EqHyp")
(ng)
(use "InitEqD")
;; Proof finished.
;; (cdp)
(save "AhCoRecLL")

;; AhCoRecLR
(set-goal "allnc gv^,v^,boole^,u^,gu^(
 gv^ v^ eqd
 (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
 (boole^ pair(InR gamma1 ag)u^) ->
 (CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^ eqd
 Fin boole^((CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^))")
(assume "gv^" "v^" "boole^" "u^" "gu^" "EqHyp")
(assert "allnc ah^(
 Fin boole^((CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^)eqd ah^ ->
 (CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^ eqd ah^)")
(assume "ah^" "EqHyp1")
(simp-with (make-proof-in-aconst-form
	    (alg-or-arrow-types-to-corec-aconst
	     (py "gamma2=>ah") (py "gamma1=>ag"))))
(ng)
(simp-with "EqHyp")
(ng)
(use "EqHyp1")
;; Assertion proved.
(assume "Assertion")
(use "Assertion")
(use "InitEqD")
;; Proof finished.
;; (cdp)
(save "AhCoRecLR")

;; AhCoRecRL
(set-goal "allnc gv^,v^,ah^,gu^(
 gv^ v^ eqd
 (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1))) ((InL ah gamma2)ah^) ->
 (CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^ eqd D ah^)")
(assume "gv^" "v^" "ah^" "gu^" "EqHyp")
(simp-with (make-proof-in-aconst-form
	    (alg-or-arrow-types-to-corec-aconst
	     (py "gamma2=>ah") (py "gamma1=>ag"))))
(ng)
(simp-with "EqHyp")
(ng)
(use "InitEqD")
;; Proof finished.
(save "AhCoRecRL")

;; AhCoRecRR
(set-goal "allnc gv^,v^,v^1,gu^(
 gv^ v^ eqd
 (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1))) ((InR gamma2 ah)v^1) ->
 (CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^ eqd 
 D((CoRec gamma2=>ah gamma1=>ag)v^1 gu^ gv^))")
(assume "gv^" "v^" "v^1" "gu^" "EqHyp")
(assert "allnc ah^(
 D((CoRec gamma2=>ah gamma1=>ag)v^1 gu^ gv^)eqd ah^ ->
 (CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^ eqd ah^)")
(assume "ah^" "EqHyp1")
(simp-with (make-proof-in-aconst-form
	    (alg-or-arrow-types-to-corec-aconst
	     (py "gamma2=>ah") (py "gamma1=>ag"))))
(ng)
(simp "EqHyp")
(ng)
(use "EqHyp1")
;; Assertion proved.
(assume "Assertion")
(use "Assertion")
(use "InitEqD")
;; Proof finished.
;; (cdp)
(save "AhCoRecRR")

;; 2020-06-27.  For AgCoRecExtNc we apply term-to-pure-extnc-formula
;; to the term (CoRec gamma1=>ag gamma2=>ah) and the cotype obtained
;; from the type of (CoRec gamma1=>ag gamma2=>ah) by changing the ag
;; ah to coag coah.  Then the conclusion has CoEqPAgNc with two
;; arguments (CoRec gamma1=>ag gamma2=>ah).  This blocks the
;; application of coinduction, which needs variable arguments.  We
;; therefore prove AgCoRecExtNcAux first where this does not happen,
;; and from it the original goal.

;; AgCoRecExtNcAux
(set-goal "allnc gu^1,gu^2(
     allnc u^1,u^2(
      EqPNc u^1 u^2 -> 
      exnc boole^1,ag^1,boole^2,ag^2(
       gu^1 u^1 eqd
       (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
       (boole^1 pair(InL ag gamma1)ag^1) andnc 
       gu^2 u^2 eqd
       (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
       (boole^2 pair(InL ag gamma1)ag^2) andnc 
       EqPBooleNc boole^1 boole^2 andnc CoEqPAgNc ag^1 ag^2) ornc 
      exnc boole^1,u^3,boole^2,u^4(
       gu^1 u^1 eqd
       (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
       (boole^1 pair(InR gamma1 ag)u^3) andnc 
       gu^2 u^2 eqd
       (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
       (boole^2 pair(InR gamma1 ag)u^4) andnc 
       EqPBooleNc boole^1 boole^2 andnc EqPNc u^3 u^4) ornc 
      exnc ah^1,ah^2(
       gu^1 u^1 eqd
       (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))
       ((InL ah gamma2)ah^1) andnc 
       gu^2 u^2 eqd
       (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))
       ((InL ah gamma2)ah^2) andnc 
       CoEqPAhNc ah^1 ah^2) ornc 
      exnc v^1,v^2(
       gu^1 u^1 eqd
       (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))
       ((InR gamma2 ah)v^1) andnc 
       gu^2 u^2 eqd
       (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))
       ((InR gamma2 ah)v^2) andnc 
       EqPNc v^1 v^2)) -> 
     allnc gv^1,gv^2(
      allnc v^1,v^2(
       EqPNc v^1 v^2 -> 
       exnc boole^1,ag^1,boole^2,ag^2(
        gv^1 v^1 eqd
        (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
        (boole^1 pair(InL ag gamma1)ag^1) andnc 
        gv^2 v^2 eqd
        (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
        (boole^2 pair(InL ag gamma1)ag^2) andnc 
        EqPBooleNc boole^1 boole^2 andnc CoEqPAgNc ag^1 ag^2) ornc 
       exnc boole^1,u^1,boole^2,u^2(
        gv^1 v^1 eqd
        (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
        (boole^1 pair(InR gamma1 ag)u^1) andnc 
        gv^2 v^2 eqd
        (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
        (boole^2 pair(InR gamma1 ag)u^2) andnc 
        EqPBooleNc boole^1 boole^2 andnc EqPNc u^1 u^2) ornc 
       exnc ah^1,ah^2(
        gv^1 v^1 eqd
        (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))
        ((InL ah gamma2)ah^1) andnc 
        gv^2 v^2 eqd
        (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))
        ((InL ah gamma2)ah^2) andnc 
        CoEqPAhNc ah^1 ah^2) ornc 
       exnc v^3,v^4(
        gv^1 v^1 eqd
        (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))
        ((InR gamma2 ah)v^3) andnc 
        gv^2 v^2 eqd
        (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))
        ((InR gamma2 ah)v^4) andnc 
        EqPNc v^3 v^4)) -> 
      allnc ag^1,ag^2(
       exnc u^1,u^2(
        ag^1 eqd(CoRec gamma1=>ag gamma2=>ah)u^1 gu^1 gv^1 andnc 
        ag^2 eqd(CoRec gamma1=>ag gamma2=>ah)u^2 gu^2 gv^2 andnc 
        EqPNc u^1 u^2) -> 
       CoEqPAgNc ag^1 ag^2)))")
(assume "gu^1" "gu^2" "gu1=gu2" "gv^1" "gv^2" "gv1=gv2" "ag^1" "ag^2")
(use (imp-formulas-to-coind-proof
      (pf "exnc u^,u^0(
     ag^1 eqd(CoRec gamma1=>ag gamma2=>ah)u^ gu^1 gv^1 andnc 
     ag^2 eqd(CoRec gamma1=>ag gamma2=>ah)u^0 gu^2 gv^2 andnc EqPNc u^ u^0) -> 
     CoEqPAgNc ag^1 ag^2")
      (pf "exnc v^,v^0(
     ah^1 eqd(CoRec gamma2=>ah gamma1=>ag)v^ gu^1 gv^1 andnc 
     ah^2 eqd(CoRec gamma2=>ah gamma1=>ag)v^0 gu^2 gv^2 andnc EqPNc v^ v^0) -> 
     CoEqPAhNc ah^1 ah^2")))
;; 3,4
(drop "gv1=gv2")
(assume "ag^3" "ag^4" "ExHyp")
(by-assume "ExHyp" "u^1" "u1Prop")
(by-assume "u1Prop" "u^2" "u1u2Prop")
(assert "EqPNc u^1 u^2")
(use "u1u2Prop")
(assume "u1=u2")
(inst-with-to "gu1=gu2" (pt "u^1") (pt "u^2") "u1=u2" "gu1=gu2Inst")
(drop "gu1=gu2")
(elim "gu1=gu2Inst")
;; 19,20
(drop "gu1=gu2Inst")
(assume "ExHypLL")
(intro 0)
(by-assume "ExHypLL" "boole^1" "b1Prop")
(by-assume "b1Prop" "ag^5" "b1ag5Prop")
(by-assume "b1ag5Prop" "boole^2" "b1ag5b2Prop")
(by-assume  "b1ag5b2Prop" "ag^6" "Conj")
(intro 0 (pt "boole^1"))
(intro 0 (pt "boole^2"))
(split)
(use "Conj")
(simp "u1u2Prop")
(simp "u1u2Prop")
(intro 0 (pt "ag^5"))
(intro 0 (pt "ag^6"))
(split)
(intro 0)
(use "Conj")
(split)
(use "AgCoRecLL")
(use "Conj")
(use "AgCoRecLL")
(use "Conj")
;; 20
(drop "gu1=gu2Inst")
(assume "Disj")
(elim "Disj")
;; 53,54
(drop "Disj")
(assume "ExHypLR")
(intro 0)
(by-assume "ExHypLR" "boole^1" "b1Prop")
(by-assume "b1Prop" "u^3" "b1u3Prop")
(by-assume "b1u3Prop" "boole^2" "b1u3b2Prop")
(by-assume  "b1u3b2Prop" "u^4" "Conj")
(simp "u1u2Prop")
(simp "u1u2Prop")
(intro 0 (pt "boole^1"))
(intro 0 (pt "boole^2"))
(split)
(use "Conj")
(intro 0 (pt "(CoRec gamma1=>ag gamma2=>ah)u^3 gu^1 gv^1"))
(intro 0 (pt "(CoRec gamma1=>ag gamma2=>ah)u^4 gu^2 gv^2"))
(split)
(intro 1)
(intro 0 (pt "u^3"))
(intro 0 (pt "u^4"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "Conj")
(split)
(use "AgCoRecLR")
(use "Conj")
(use "AgCoRecLR")
(use "Conj")
;; 54
(drop "Disj")
(assume "Disj1")
(elim "Disj1")
;; 93,94
(drop "Disj1")
(assume "ExHyp1")
(intro 1)
(by-assume "ExHyp1" "ah^1" "ah1Prop")
(by-assume "ah1Prop" "ah^2" "Conj")
(simp "u1u2Prop")
(simp "u1u2Prop")
(intro 0 (pt "ah^1"))
(intro 0 (pt "ah^2"))
(split)
(intro 0)
(use "Conj")
(split)
(use "AgCoRecRL")
(use "Conj")
(use "AgCoRecRL")
(use "Conj")
;; 94
(drop "Disj1")
(assume "ExHyp1")
(intro 1)
(by-assume "ExHyp1" "v^1" "v1Prop")
(by-assume "v1Prop" "v^2" "Conj")
(simp "u1u2Prop")
(simp "u1u2Prop")
(intro 0 (pt "(CoRec gamma2=>ah gamma1=>ag)v^1 gu^1 gv^1"))
(intro 0 (pt "(CoRec gamma2=>ah gamma1=>ag)v^2 gu^2 gv^2"))
(split)
(intro 1)
(intro 0 (pt "v^1"))
(intro 0 (pt "v^2"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "Conj")
(split)
(use "AgCoRecRR")
(use "Conj")
(use "AgCoRecRR")
(use "Conj")
;; 4
(drop "gu1=gu2")
(assume "ah^3" "ah^4" "ExHyp")
(by-assume "ExHyp" "v^1" "v1Prop")
(by-assume "v1Prop" "v^2" "v1v2Prop")
(assert "EqPNc v^1 v^2")
(use "v1v2Prop")
(assume "v1=v2")
(inst-with-to "gv1=gv2" (pt "v^1") (pt "v^2") "v1=v2" "gv1=gv2Inst")
(drop "gv1=gv2")
(elim "gv1=gv2Inst")
;; 155,156
(drop "gv1=gv2Inst") ;Here we have an implication
;; (intro 0)
(assume "ExHypLL")
(by-assume "ExHypLL" "boole^1" "b1Prop")
(by-assume "b1Prop" "ag^5" "b1ag5Prop")
(by-assume "b1ag5Prop" "boole^2" "b1ag5b2Prop")
(by-assume  "b1ag5b2Prop" "ag^6" "Conj")
(intro 0)
(intro 0 (pt "boole^1"))
(intro 0 (pt "boole^2"))
(split)
(use "Conj")
(simp "v1v2Prop")
(simp "v1v2Prop")
(intro 0 (pt "ag^5"))
(intro 0 (pt "ag^6"))
(split)
(intro 0)
(use "Conj")
(split)
(use "AhCoRecLL")
(use "Conj")
(use "AhCoRecLL")
(use "Conj")
;; 156
(drop "gv1=gv2Inst")
(assume "Disj")
(elim "Disj")
;; 189,190
(drop "Disj")
(assume "ExHypLR")
(intro 0)
(by-assume "ExHypLR" "boole^1" "b1Prop")
(by-assume "b1Prop" "u^3" "b1u3Prop")
(by-assume "b1u3Prop" "boole^2" "b1u3b2Prop")
(by-assume  "b1u3b2Prop" "u^4" "Conj")
(simp "v1v2Prop")
(simp "v1v2Prop")
(intro 0 (pt "boole^1"))
(intro 0 (pt "boole^2"))
(split)
(use "Conj")
(intro 0 (pt "(CoRec gamma1=>ag gamma2=>ah)u^3 gu^1 gv^1"))
(intro 0 (pt "(CoRec gamma1=>ag gamma2=>ah)u^4 gu^2 gv^2"))
(split)
(intro 1)
(intro 0 (pt "u^3"))
(intro 0 (pt "u^4"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "Conj")
(split)
(use "AhCoRecLR")
(use "Conj")
(use "AhCoRecLR")
(use "Conj")
;; 190
(drop "Disj")
(assume "Disj1")
(elim "Disj1")
;; 229,230
(drop "Disj1")
(assume "ExHyp1")
(intro 1)
(by-assume "ExHyp1" "ah^1" "ah1Prop")
(by-assume "ah1Prop" "ah^2" "Conj")
(simp "v1v2Prop")
(simp "v1v2Prop")
(intro 0 (pt "ah^1"))
(intro 0 (pt "ah^2"))
(split)
(intro 0)
(use "Conj")
(split)
(use "AhCoRecRL")
(use "Conj")
(use "AhCoRecRL")
(use "Conj")
;; 230
(drop "Disj1")
(assume "ExHypRR")
(intro 1)
(by-assume "ExHypRR" "v^3" "v3Prop")
(by-assume "v3Prop" "v^4" "Conj")
(simp "v1v2Prop")
(simp "v1v2Prop")
(intro 0 (pt "(CoRec gamma2=>ah gamma1=>ag)v^3 gu^1 gv^1"))
(intro 0 (pt "(CoRec gamma2=>ah gamma1=>ag)v^4 gu^2 gv^2"))
(split)
(intro 1)
(intro 0 (pt "v^3"))
(intro 0 (pt "v^4"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "Conj")
(split)
(use "AhCoRecRR")
(use "Conj")
(use "AhCoRecRR")
(use "Conj")
;; Proof finished.
;; (cdp)
(save "AgCoRecExtNcAux")

;; AgCoRecExtNc
(set-goal (rename-variables
	   (term-to-pure-extnc-formula
	    (pt "(CoRec gamma1=>ag gamma2=>ah)")
	    (mk-arrow
	     (py "gamma1")
	     (make-arrow
	      (py "gamma1")
	      (make-alg
	       "ysum"
	       (make-alg "yprod"
			 (py "boole")
			 (make-alg "ysum" (make-alg "coag") (py "gamma1")))
	       (make-alg "ysum" (make-alg "coah") (py "gamma2"))))
	     (make-arrow
	      (py "gamma2")
	      (make-alg
	       "ysum"
	       (make-alg "yprod"
			 (py "boole")
			 (make-alg "ysum" (make-alg "coag") (py "gamma1")))
	       (make-alg "ysum" (make-alg "coah") (py "gamma2"))))
	     (make-alg "coag")))))
;; ?^1:allnc u^,u^0(
;;      EqPNc u^ u^0 -> 
;;      allnc gu^,gu^0(
;;       allnc u^1,u^2(
;;        EqPNc u^1 u^2 -> 
;;        (REqPYsumNc (cterm (bgsu^,bgsu^0) 
;;                      (REqPYprodNc (cterm (boole^,boole^0) 
;;                                     EqPBooleNc boole^ boole^0)
;;                        (cterm (gsu^,gsu^0) 
;;                        (REqPYsumNc (cterm (ag^1,ag^2) CoEqPAgNc ag^1 ag^2)
;;                          (cterm (u^3,u^4) EqPNc u^3 u^4))
;;                        gsu^
;;                        gsu^0))
;;                      bgsu^ 
;;                      bgsu^0)
;;          (cterm (hsv^,hsv^0) 
;;          (REqPYsumNc (cterm (ah^,ah^0) CoEqPAhNc ah^ ah^0)
;;            (cterm (v^,v^0) EqPNc v^ v^0))
;;          hsv^ 
;;          hsv^0))
;;        (gu^ u^1)
;;        (gu^0 u^2)) -> 
;;       allnc gv^,gv^0(
;;        allnc v^,v^0(
;;         EqPNc v^ v^0 -> 
;;         (REqPYsumNc (cterm (bgsu^,bgsu^0) 
;;                       (REqPYprodNc (cterm (boole^,boole^0) 
;;                                      EqPBooleNc boole^ boole^0)
;;                         (cterm (gsu^,gsu^0) 
;;                         (REqPYsumNc (cterm (ag^1,ag^2) CoEqPAgNc ag^1 ag^2)
;;                           (cterm (u^1,u^2) EqPNc u^1 u^2))
;;                         gsu^
;;                         gsu^0))
;;                       bgsu^ 
;;                       bgsu^0)
;;           (cterm (hsv^,hsv^0) 
;;           (REqPYsumNc (cterm (ah^,ah^0) CoEqPAhNc ah^ ah^0)
;;             (cterm (v^1,v^2) EqPNc v^1 v^2))
;;           hsv^ 
;;           hsv^0))
;;         (gv^ v^)
;;         (gv^0 v^0)) -> 
;;        CoEqPAgNc((CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^)
;;        ((CoRec gamma1=>ag gamma2=>ah)u^0 gu^0 gv^0))))
(assert "allnc gu^,gu^0(
     allnc u^,u^0(
      EqPNc u^ u^0 -> 
      (REqPYsumNc (cterm (bgsu^,bgsu^0) 
                    (REqPYprodNc (cterm (boole^,boole^0) 
                                   EqPBooleNc boole^ boole^0)
                      (cterm (gsu^,gsu^0) 
                      (REqPYsumNc (cterm (ag^,ag^0) CoEqPAgNc ag^ ag^0)
                        (cterm (u^1,u^2) EqPNc u^1 u^2))
                      gsu^ 
                      gsu^0))
                    bgsu^ 
                    bgsu^0)
        (cterm (hsv^,hsv^0) 
        (REqPYsumNc (cterm (ah^,ah^0) CoEqPAhNc ah^ ah^0)
          (cterm (v^,v^0) EqPNc v^ v^0))
        hsv^ 
        hsv^0))
      (gu^ u^)
      (gu^0 u^0)) -> 
     allnc gv^,gv^0(
      allnc v^,v^0(
       EqPNc v^ v^0 -> 
       (REqPYsumNc (cterm (bgsu^,bgsu^0) 
                     (REqPYprodNc (cterm (boole^,boole^0) 
                                    EqPBooleNc boole^ boole^0)
                       (cterm (gsu^,gsu^0) 
                       (REqPYsumNc (cterm (ag^,ag^0) CoEqPAgNc ag^ ag^0)
                         (cterm (u^,u^0) EqPNc u^ u^0))
                       gsu^ 
                       gsu^0))
                     bgsu^ 
                     bgsu^0)
         (cterm (hsv^,hsv^0) 
         (REqPYsumNc (cterm (ah^,ah^0) CoEqPAhNc ah^ ah^0)
           (cterm (v^1,v^2) EqPNc v^1 v^2))
         hsv^ 
         hsv^0))
       (gv^ v^)
       (gv^0 v^0)) -> 
      allnc ag^,ag^0(
       exnc u^,u^0(
        ag^ eqd(CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^ andnc 
        ag^0 eqd(CoRec gamma1=>ag gamma2=>ah)u^0 gu^0 gv^0 andnc 
        EqPNc u^ u^0) -> 
       CoEqPAgNc ag^ ag^0)))")
(assume "gu^1" "gu^2" "gu1=gu2" "gv^1" "gv^2" "gv1=gv2" "ag^1" "ag^2")
(use "AgCoRecExtNcAux")
(assume "u^1" "u^2" "u1=u2")
(inst-with-to "gu1=gu2" (pt "u^1") (pt "u^2") "u1=u2" "Inst")
(drop "gu1=gu2" "gv1=gv2")
(elim "Inst")
;; 11,12
(drop "Inst")
(assume "bgsu^1" "bgsu^2" "YProdHyp")
(elim "YProdHyp")
(drop "YProdHyp")
(assume "boole^1" "boole^2" "b1=b2" "gsu^1" "gsu^2" "YsumHyp")
(elim "YsumHyp")
;; 18,19
(drop "YsumHyp")
(assume "ag^3" "ag^4" "ag3=ag4")
(intro 0)
(intro 0 (pt "boole^1"))
(intro 0 (pt "ag^3"))
(intro 0 (pt "boole^2"))
(intro 0 (pt "ag^4"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(split)
(use "b1=b2")
(use "ag3=ag4")
;; 19
(drop "YsumHyp")
(assume "u^3" "u^4" "u3=u4")
(intro 1)
(intro 0)
(intro 0 (pt "boole^1"))
(intro 0 (pt "u^3"))
(intro 0 (pt "boole^2"))
(intro 0 (pt "u^4"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(split)
(use "b1=b2")
(use "u3=u4")
;; 12
(drop "Inst")
(assume "hsv^1" "hsv^2" "YsumHyp")
(elim "YsumHyp")
;; 49,50
(drop "YsumHyp")
(assume "ah^1" "ah^2" "ah1=ah2")
(intro 1)
(intro 1)
(intro 0)
(intro 0 (pt "ah^1"))
(intro 0 (pt "ah^2"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "ah1=ah2")
;; 50
(drop "YsumHyp")
(assume "v^1" "v^2" "v1=v2")
(intro 1)
(intro 1)
(intro 1)
(intro 0 (pt "v^1"))
(intro 0 (pt "v^2"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "v1=v2")
;; 6
(assume "v^1" "v^2" "v1=v2")
(inst-with-to "gv1=gv2" (pt "v^1") (pt "v^2") "v1=v2" "Inst")
(drop "gu1=gu2" "gv1=gv2")
(elim "Inst")
;; 77,78
(drop "Inst")
(assume "bgsu^1" "bgsu^2" "YProdHyp")
(elim "YProdHyp")
(drop "YProdHyp")
(assume "boole^1" "boole^2" "b1=b2" "gsu^1" "gsu^2" "YsumHyp")
(elim "YsumHyp")
;; 84,85
(drop "YsumHyp")
(assume "ag^3" "ag^4" "ag3=ag4")
(intro 0)
(intro 0 (pt "boole^1"))
(intro 0 (pt "ag^3"))
(intro 0 (pt "boole^2"))
(intro 0 (pt "ag^4"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(split)
(use "b1=b2")
(use "ag3=ag4")
;; 85
(drop "YsumHyp")
(assume "u^3" "u^4" "u3=u4")
(intro 1)
(intro 0)
(intro 0 (pt "boole^1"))
(intro 0 (pt "u^3"))
(intro 0 (pt "boole^2"))
(intro 0 (pt "u^4"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(split)
(use "b1=b2")
(use "u3=u4")
;; 78
(drop "Inst")
(assume "hsv^1" "hsv^2" "YsumHyp")
(elim "YsumHyp")
;; 115,116
(drop "YsumHyp")
(assume "ah^1" "ah^2" "ah1=ah2")
(intro 1)
(intro 1)
(intro 0)
(intro 0 (pt "ah^1"))
(intro 0 (pt "ah^2"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "ah1=ah2")
;; 116
(drop "YsumHyp")
(assume "v^3" "v^4" "v3=v4")
(intro 1)
(intro 1)
(intro 1)
(intro 0 (pt "v^3"))
(intro 0 (pt "v^4"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "v3=v4")
;; 2
;; Assertion proved.
(assume "Assertion"
	"u^1" "u^2" "u1=u2" "gu^1" "gu^2" "gu1=gu2"  "gv^1" "gv^2" "gv1=gv2")
(inst-with-to
 "Assertion"
 (pt "gu^1") (pt "gu^2") "gu1=gu2"
 (pt "gv^1") (pt "gv^2") "gv1=gv2" "AInst")
(drop "gu1=gu2" "gv1=gv2" "Assertion")
(use "AInst")
(intro 0 (pt "u^1"))
(intro 0 (pt "u^2"))
(split)
(use "InitEqD")
(split)
(use "InitEqD")
(use "u1=u2")
;; Proof finished.
;; (cdp)
(save "AgCoRecExtNc")

;; 2020-08-08.  It turns out that each of following theorems GfpCoGMR
;; and GfpCoHMR uses the same lengthy lemmas GfpCoGHMRAuxG and
;; GfpCoGHMRAuxH.  We therefore prove them first.

;; (set! COMMENT-FLAG #f)
;; GfpCoGHMRAuxG
(set-goal "allnc gu^(
      allnc x,u^(
       XMR^ x u^ -> 
       (OrDMR (cterm (bgsu^) 
                (ExRTMR int
                  boole yprod(ag ysum gamma1)
                  (cterm (d,bgsu^0) 
                  (ExRTMR rea
                    boole yprod(ag ysum gamma1)
                    (cterm (x0,bgsu^1) 
                    (ExRTMR rea
                      boole yprod(ag ysum gamma1)
                      (cterm (y,bgsu^2) 
                      (AndDMR (cterm (boole^) PsdMR d boole^)
                        (cterm (gsu^) 
                        (AndRMR (cterm () Real x0)
                          (cterm (gsu^0) 
                          (AndRMR (cterm () abs x0<<=1)
                            (cterm (gsu^1) 
                            (AndLMR (cterm (gsu^2) 
                                      (OrDMR (cterm (ag^) CoGMR x0 ag^)
                                        (cterm (u^0) XMR^ x0 u^0))
                                      gsu^2)
                              (cterm () 
                              y===(1#2)*(x0+IntN 1)* ~d andnc x===y))
                            gsu^1))
                          gsu^0))
                        gsu^))
                      bgsu^2))
                    bgsu^1))
                  bgsu^0))
                bgsu^)
         (cterm (hsv^) 
         (ExRTMR rea
           ah ysum gamma2
           (cterm (x0,hsv^0) 
           (ExRTMR rea
             ah ysum gamma2
             (cterm (y,hsv^1) 
             (AndRMR (cterm () Real x0)
               (cterm (hsv^2) 
               (AndRMR (cterm () abs x0<<=1)
                 (cterm (hsv^3) 
                 (AndLMR (cterm (hsv^4) 
                           (OrDMR (cterm (ah^) CoHMR x0 ah^)
                             (cterm (v^) YMR^ x0 v^))
                           hsv^4)
                   (cterm () y===(1#2)*x0 andnc x===y))
                 hsv^3))
               hsv^2))
             hsv^1))
           hsv^0))
         hsv^))
       (gu^ u^)) -> 
      allnc gv^,x,ag^(
       exnc u^(
        XMR^ x u^ andnc ag^ eqd(CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^) -> 
       exnc d,x0,y,boole^0(
        PsdMR d boole^0 andnc 
        Real x0 andnc 
        abs x0<<=1 andnc 
        exnc ag^1(
         (CoGMR x0 ag^1 ornc 
          exnc u^(
           XMR^ x0 u^ andnc ag^1 eqd(CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^)) andnc 
         y===(1#2)*(x0+IntN 1)* ~d andnc 
         x eqd y andnc ag^ eqd LR boole^0 ag^1)) ornc 
       exnc x0,y(
        Real x0 andnc 
        abs x0<<=1 andnc 
        exnc ah^0(
         (CoHMR x0 ah^0 ornc 
          exnc v^(
           YMR^ x0 v^ andnc ah^0 eqd(CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^)) andnc 
         y===(1#2)*x0 andnc x eqd y andnc ag^ eqd U ah^0))))")
(assume "gu^" "Step1" "gv^" "x1" "ag^1" "u1Ex")
(by-assume "u1Ex" "u^1" "x1u1Prop")
(elim "x1u1Prop")
(drop "x1u1Prop")
(assume "XMRx1u1" "ag1Def")
(inst-with-to "Step1" (pt "x1") (pt "u^1") "XMRx1u1" "Step1Inst")
(drop "Step1")
;; 11
;; Step1Inst is an OrDMR-formula with realizer (gu^ u^1) of sum type.
;; We assert the implied disjunction.
(assert "exnc bgsu^(
 (ExRTMR int
   boole yprod(ag ysum gamma1)
   (cterm (d,bgsu^0) 
   (ExRTMR rea
     boole yprod(ag ysum gamma1)
     (cterm (x,bgsu^1) 
     (ExRTMR rea
       boole yprod(ag ysum gamma1)
       (cterm (y,bgsu^2) 
       (AndDMR (cterm (boole^) PsdMR d boole^)
         (cterm (gsu^) 
         (AndRMR (cterm () Real x)
           (cterm (gsu^0) 
           (AndRMR (cterm () abs x<<=1)
             (cterm (gsu^1) 
             (AndLMR (cterm (gsu^2) 
                       (OrDMR (cterm (ag^) CoGMR x ag^)
                         (cterm (u^) XMR^ x u^))
                       gsu^2)
               (cterm () y===(1#2)*(x+IntN 1)* ~d andnc x1===y))
             gsu^1))
           gsu^0))
         gsu^))
       bgsu^2))
     bgsu^1))
   bgsu^0))
 bgsu^ andnc 
 gu^ u^1 eqd(InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))bgsu^) ornc 
exnc hsv^(
 (ExRTMR rea
   ah ysum gamma2
   (cterm (x,hsv^0) 
   (ExRTMR rea
     ah ysum gamma2
     (cterm (y,hsv^1) 
     (AndRMR (cterm () Real x)
       (cterm (hsv^2) 
       (AndRMR (cterm () abs x<<=1)
         (cterm (hsv^3) 
         (AndLMR (cterm (hsv^4) 
                   (OrDMR (cterm (ah^) CoHMR x ah^) (cterm (v^) YMR^ x v^))
                   hsv^4)
           (cterm () y===(1#2)*x andnc x1===y))
         hsv^3))
       hsv^2))
     hsv^1))
   hsv^0))
 hsv^ andnc 
 gu^ u^1 eqd(InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))hsv^)")
;; We prove this asserted disjunction from Step1Inst
(elim "Step1Inst")
;; 14,15
(drop "Step1Inst")
(assume "bgsu^" "bgsuProp")
(intro 0)
(intro 0 (pt "bgsu^"))
(split)
(use "bgsuProp")
(use "InitEqD")
;; 15
(drop "Step1Inst")
(assume "hsv^" "hsvProp")
(intro 1)
(intro 0 (pt "hsv^"))
(split)
(use "hsvProp")
(use "InitEqD")
;; Assertion proved.
;; 12
(drop "Step1Inst")
(assume "Disj")
(elim "Disj")
;; 30,31
(drop "Disj")
(assume "bgsuEx")
(by-assume "bgsuEx" "bgsu^" "Conj")
(elim "Conj")
(assume "bgsuProp" "InLEq")
(drop "Conj")
(assert "exnc d((ExRTMR rea
                        boole yprod(ag ysum gamma1)
                        (cterm (x,bgsu^1) 
                        (ExRTMR rea
                          boole yprod(ag ysum gamma1)
                          (cterm (y,bgsu^2) 
                          (AndDMR (cterm (boole^) PsdMR d boole^)
                            (cterm (gsu^) 
                            (AndRMR (cterm () Real x)
                              (cterm (gsu^0) 
                              (AndRMR (cterm () abs x<<=1)
                                (cterm (gsu^1) 
                                (AndLMR (cterm (gsu^2) 
                                          (OrDMR (cterm (ag^) CoGMR x ag^)
                                            (cterm (u^) XMR^ x u^))
                                          gsu^2)
                                  (cterm () 
                                  y===(1#2)*(x+IntN 1)* ~d andnc x1===y))
                                gsu^1))
                              gsu^0))
                            gsu^))
                          bgsu^2))
                        bgsu^1))bgsu^)")
(elim "bgsuProp")
(assume "d" "bgsu^1" "bgsu1Prop")
(intro 0 (pt "d"))
(use "bgsu1Prop")
;; Assertion proved.
(drop "bgsuProp")
(assume "dEx")
(by-assume "dEx" "d" "dProp")
(intro 0) ;here we take the lhs of the initial disjunction
(intro 0 (pt "d"))
(assert "exnc x((ExRTMR rea
                 boole yprod(ag ysum gamma1)
                 (cterm (y,bgsu^1) 
                 (AndDMR (cterm (boole^) PsdMR d boole^)
                   (cterm (gsu^) 
                   (AndRMR (cterm () Real x)
                     (cterm (gsu^0) 
                     (AndRMR (cterm () abs x<<=1)
                       (cterm (gsu^1) 
                       (AndLMR (cterm (gsu^2) 
                                 (OrDMR (cterm (ag^) CoGMR x ag^)
                                   (cterm (u^) XMR^ x u^))
                                 gsu^2)
                         (cterm () y===(1#2)*(x+IntN 1)* ~d andnc x1===y))
                       gsu^1))
                     gsu^0))
                   gsu^))
                 bgsu^1))bgsu^)")
(elim "dProp")
(drop "dProp")
(assume "x2" "bgsu^2" "bgsu2Prop")
(intro 0 (pt "x2"))
(use "bgsu2Prop")
;; Assertion proved.
(drop "dProp")
(assume "x2Ex")
(by-assume "x2Ex" "x2" "x2Prop")
(intro 0 (pt "x2"))
(assert "exnc y((AndDMR (cterm (boole^) PsdMR d boole^)
                        (cterm (gsu^) 
                        (AndRMR (cterm () Real x2)
                          (cterm (gsu^0) 
                          (AndRMR (cterm () abs x2<<=1)
                            (cterm (gsu^1) 
                            (AndLMR (cterm (gsu^2) 
                                      (OrDMR (cterm (ag^) CoGMR x2 ag^)
                                        (cterm (u^) XMR^ x2 u^))
                                      gsu^2)
                              (cterm () 
                              y===(1#2)*(x2+IntN 1)* ~d andnc x1===y))
                            gsu^1))
                          gsu^0))
                        gsu^))bgsu^)")
(elim "x2Prop")
(drop "x2Prop")
(assume "y" "bgsu^3" "bgsu3Prop")
(intro 0 (pt "y"))
(use "bgsu3Prop")
;; Assertion proved.
(assume "ExNcHypy")
(by-assume "ExNcHypy" "y" "yProp")
(intro 0 (pt "x1"))
;; (intro 0 (pt "y"))
(drop "x2Prop")
(assert "bgsu^ eqd clft bgsu^ pair(crht bgsu^) andnc
 PsdMR d(clft bgsu^) andnc
 (AndRMR (cterm () Real x2)
                            (cterm (gsu^0) 
                            (AndRMR (cterm () abs x2<<=1)
                              (cterm (gsu^1) 
                              (AndLMR (cterm (gsu^2) 
                                        (OrDMR (cterm (ag^) CoGMR x2 ag^)
                                          (cterm (u^) XMR^ x2 u^))
                                        gsu^2)
                                (cterm () 
                                y===(1#2)*(x2+IntN 1)* ~d andnc x1===y))
                              gsu^1))
                            gsu^0))(crht bgsu^)")
(elim "yProp")
(drop "yProp")
(assume "boole^" "PsdMRdb" "gsu^" "AndRMRgsu")
(ng #t)
(split)
(use "InitEqD")
(split)
(use "PsdMRdb")
(use "AndRMRgsu")
;; Assertion proved.
(drop "yProp")
(assume "Conj1")
(inst-with-to "Conj1" 'left "bgsuPair")
(inst-with-to "Conj1" 'right 'left "PsdMRdlftbgsu")
(inst-with-to "Conj1" 'right 'right "AndRMRgsu")
(drop "Conj1")
(assert "Real x2 andnc (AndRMR (cterm () abs x2<<=1)
                (cterm (gsu^0) 
                (AndLMR (cterm (gsu^1) 
                          (OrDMR (cterm (ag^) CoGMR x2 ag^)
                            (cterm (u^) XMR^ x2 u^))
                          gsu^1)
                  (cterm () y===(1#2)*(x2+IntN 1)* ~d andnc x1===y))
                gsu^0))(crht bgsu^)")
(elim "AndRMRgsu")
(drop "AndRMRgsu")
(assume "Rx2" "gsu^" "AndRMR1gsu")
(split)
(use "Rx2")
(use "AndRMR1gsu")
;; Assertion proved.
(drop "AndRMRgsu")
(assume "Conj2")
(inst-with-to "Conj2" 'left "Rx2")
(inst-with-to "Conj2" 'right "AndRMRcrhtbgsu")
(drop "Conj2")
(assert "abs x2<<=1 andnc (AndLMR (cterm (gsu^0) 
                             (OrDMR (cterm (ag^) CoGMR x2 ag^)
                               (cterm (u^) XMR^ x2 u^))
                             gsu^0)
                (cterm () y===(1#2)*(x2+IntN 1)* ~d andnc x1===y))(crht bgsu^)")
(elim "AndRMRcrhtbgsu")
(drop "AndRMRcrhtbgsu")
(assume "x2Bd" "gsu^" "AndLMRgsu")
(split)
(use "x2Bd")
(use "AndLMRgsu")
;; Assertion proved.
(drop "AndRMRcrhtbgsu")
(assume "Conj3")
(inst-with-to "Conj3" 'left "x2Bd")
(inst-with-to "Conj3" 'right "AndLMRcrhtbgsu")
(drop "Conj3")
(assert "(OrDMR (cterm (ag^) CoGMR x2 ag^)
                (cterm (u^) XMR^ x2 u^))(crht bgsu^)
 andnc
 y===(1#2)*(x2+IntN 1)* ~d andnc x1===y")
(elim "AndLMRcrhtbgsu")
(drop "AndLMRcrhtbgsu")
(assume "gsu^" "OrDMRgsu" "Conj4")
(split)
(use "OrDMRgsu")
(use "Conj4")
;; Assertion proved.
(drop "AndLMRcrhtbgsu")
(assume "Conj5")
(inst-with-to "Conj5" 'left "OrDMRcrhtbgsu")
(inst-with-to "Conj5" 'right "Conj6")
(elim "Conj6")
(drop "Conj6")
(assume "yDef" "x1=y")
(drop "Conj5")
(intro 0 (pt "(clft bgsu^)"))
(split)
(use "PsdMRdlftbgsu")
(split)
(use "Rx2")
(split)
(use "x2Bd")
;; Inserted 2020-08-02
(assert "exnc ag^(CoGMR x2 ag^ andnc crht bgsu^ eqd(InL ag gamma1)ag^) ornc 
         exnc u^(XMR^ x2 u^ andnc crht bgsu^ eqd(InR gamma1 ag)u^)")
(elim "OrDMRcrhtbgsu")
;; 149,150
(drop "OrDMRcrhtbgsu")
(assume "ag^2" "CoGMRx2ag2")
(intro 0)
(intro 0 (pt "ag^2"))
(split)
(use "CoGMRx2ag2")
(use "InitEqD")
;; 150
(drop "OrDMRcrhtbgsu")
(assume "u^2" "XMRx2u2")
(intro 1)
(intro 0 (pt "u^2"))
(split)
(use "XMRx2u2")
(use "InitEqD")
;; Assertion proved.
;; 147
(drop "OrDMRcrhtbgsu")
(assume "Disj1")
(elim "Disj1")
;; 165,166
(drop "Disj1")
(assume "agEx")
(by-assume "agEx" "ag^2" "ag2Prop")
(intro 0 (pt "ag^2"))
(split)
(intro 0)
(use "ag2Prop")
(split)
(simpreal "x1=y")
(use "yDef")
(split)
(use "InitEqD")
;; ?^180:ag^1 eqd LR clft bgsu^ ag^2
(simp "ag1Def")
;; (pp "AgCoRecLL")

;; allnc gu^,u^,boole^,ag^0,gv^(
;;  gu^ u^ eqd
;;  (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
;;  (boole^ pair(InL ag gamma1)ag^0) -> 
;;  (CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^ eqd LR boole^ ag^0)

(use "AgCoRecLL")
(simp "InLEq")
(simp "bgsuPair")
(simp "<-" "bgsuPair")
(simp "<-" "ag2Prop")
(simp "<-" "bgsuPair")
(use "InitEqD")
;; 166
(drop "Disj1")
(assume "uEx")
(by-assume "uEx" "u^2" "u2Prop")
;; (pp "AgCoRecLR")

;; allnc gu^,u^,boole^,u^0,gv^(
;;  gu^ u^ eqd
;;  (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
;;  (boole^ pair(InR gamma1 ag)u^0) -> 
;;  (CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^ eqd 
;;  LR boole^((CoRec gamma1=>ag gamma2=>ah)u^0 gu^ gv^))

(intro 0 (pt "(CoRec gamma1=>ag gamma2=>ah)u^2 gu^ gv^"))
(split)
(intro 1)
(intro 0 (pt "u^2"))
(split)
(use "u2Prop")
(use "InitEqD")
(split)
(simpreal "x1=y")
(use "yDef")
(split)
(use "InitEqD")
(simp "ag1Def")
(use "AgCoRecLR")
(simp "<-" "u2Prop")
(simp "<-" "bgsuPair")
(use "InLEq")
;; 31
(drop "Disj")
(assume "hsvEx")
(by-assume "hsvEx" "hsv^" "Conj")
(elim "Conj")
(assume "hsvProp" "InREq")
(drop "Conj")
(assert "exnc x((ExRTMR rea
                      ah ysum gamma2
                      (cterm (y,hsv^1) 
                      (AndRMR (cterm () Real x)
                        (cterm (hsv^2) 
                        (AndRMR (cterm () abs x<<=1)
                          (cterm (hsv^3) 
                          (AndLMR (cterm (hsv^4) 
                                    (OrDMR (cterm (ah^) CoHMR x ah^)
                                      (cterm (v^) YMR^ x v^))
                                    hsv^4)
                            (cterm () y===(1#2)*x andnc x1===y))
                          hsv^3))
                        hsv^2))
                      hsv^1))hsv^)")
(elim "hsvProp")
(assume "x2" "hsv^2" "hsv2Prop")
(intro 0 (pt "x2"))
(use "hsv2Prop")
;; Assertion proved.
(drop "hsvProp")
(assume "x2Ex")
(by-assume "x2Ex" "x2" "x2Prop")
(intro 1) ;here we take the rhs of the initial disjunction
(intro 0 (pt "x2"))
(assert "exnc y((AndRMR (cterm () Real x2)
                   (cterm (hsv^1) 
                   (AndRMR (cterm () abs x2<<=1)
                     (cterm (hsv^2) 
                     (AndLMR (cterm (hsv^3) 
                               (OrDMR (cterm (ah^) CoHMR x2 ah^)
                                 (cterm (v^) YMR^ x2 v^))
                               hsv^3)
                       (cterm () y===(1#2)*x2 andnc x1===y))
                     hsv^2))
                   hsv^1))hsv^)")
(elim "x2Prop")
(drop "x2Prop")
(assume "y" "hsv^3" "hsv3Prop")
(intro 0 (pt "y"))
(use "hsv3Prop")
;; Assertion proved.
(drop "x2Prop")
(assume "yEx")
(by-assume "yEx" "y" "yProp")
(intro 0 (pt "x1"))
(assert "Real x2 andnc (AndRMR (cterm () abs x2<<=1)
                       (cterm (hsv^1) 
                       (AndLMR (cterm (hsv^2) 
                                 (OrDMR (cterm (ah^) CoHMR x2 ah^)
                                   (cterm (v^) YMR^ x2 v^))
                                 hsv^2)
                         (cterm () y===(1#2)*x2 andnc x1===y))
                       hsv^1))hsv^")
(elim "yProp")
(drop "yProp")
(assume "Rx2" "hsv^1" "hsv1Prop")
(split)
(use "Rx2")
(use "hsv1Prop")
;; Assertion proved.
(drop "yProp")
(assume "Conj1")
(inst-with-to "Conj1" 'left "Rx2")
(inst-with-to "Conj1" 'right "AndRMRhsv")
(drop "Conj1")
(assert "abs x2<<=1 andnc (AndLMR (cterm (hsv^1) 
                        (OrDMR (cterm (ah^) CoHMR x2 ah^)
                          (cterm (v^) YMR^ x2 v^))
                        hsv^1)
                (cterm () y===(1#2)*x2 andnc x1===y))hsv^")
(elim "AndRMRhsv")
(drop "AndRMRhsv")
(assume "x2Bd" "hsv^1" "AndLMRhsv1")
(split)
(use "x2Bd")
(use "AndLMRhsv1")
;; Assertion proved.
(drop "AndRMRhsv")
(assume "Conj2")
(inst-with-to "Conj2" 'left "x2Bd")
(inst-with-to "Conj2" 'right "AndLMRhsv")
(drop "Conj2")
(assert "(OrDMR (cterm (ah^) CoHMR x2 ah^) (cterm (v^) YMR^ x2 v^))hsv^ andnc
         y===(1#2)*x2 andnc x1===y")
(elim "AndLMRhsv")
(drop "AndLMRhsv")
(assume "hsv^1" "OrDMRhsv1" "Conj3")
(inst-with-to "Conj3" 'left "yDef")
(inst-with-to "Conj3" 'right "x1=y")
(drop "Conj3")
(split)
(use "OrDMRhsv1")
(split)
(use "yDef")
(use "x1=y")
;; Assertion proved.
(drop "AndLMRhsv")
(assume "Conj4")
(inst-with-to "Conj4" 'left "OrDMRhsv")
(inst-with-to "Conj4" 'right "Conj5")
(drop "Conj4")
(inst-with-to "Conj5" 'left "yDef")
(inst-with-to "Conj5" 'right "x1=y")
(drop "Conj5")
(split)
(use "Rx2")
(split)
(use "x2Bd")
(assert "exnc ah^(CoHMR x2 ah^ andnc hsv^ eqd(InL ah gamma2)ah^) ornc
         exnc v^(YMR^ x2 v^ andnc hsv^ eqd(InR gamma2 ah)v^)")
(elim "OrDMRhsv")
;; 301,302
(drop "OrDMRhsv")
(assume "ah^" "CoHMRx2ah")
(intro 0)
(intro 0 (pt "ah^"))
(split)
(use "CoHMRx2ah")
(use "InitEqD")
;; 302
(drop "OrDMRhsv")
(assume "v^2" "YMRx2v2")
(intro 1)
(intro 0 (pt "v^2"))
(split)
(use "YMRx2v2")
(use "InitEqD")
;; Assertion proved.
(drop "OrDMRhsv")
(assume "Disj1")
(elim "Disj1")
;; 317,318
(drop "Disj1")
(assume "ahEx")
(by-assume "ahEx" "ah^" "ahProp")
(intro 0 (pt "ah^"))
(split)
(intro 0)
(use "ahProp")
(split)
(simpreal "x1=y")
(use "yDef")
(split)
(use "InitEqD")
(simp "ag1Def")
;; (pp "AgCoRecRL")

;; (simpreal "x1=y")
;; (use "yDef")
;; (split)
;; (use "InitEqD")

(use "AgCoRecRL")
(simp "InREq")
(simp "<-" "ahProp")
(use "InitEqD")
;; 318
(drop "Disj1")
(assume "vEx")
(by-assume "vEx" "v^2" "v2Prop")
;; (pp "AgCoRecRR")

;; allnc gu^,u^,gv^,v^(
;;  gu^ u^ eqd
;;  (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))((InR gamma2 ah)v^) -> 
;;  (CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^ eqd 
;;  U((CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^))

(intro 0 (pt "(CoRec gamma2=>ah gamma1=>ag)v^2 gu^ gv^"))
(split)
(intro 1)
(intro 0 (pt "v^2"))
(split)
(use "v2Prop")
(use "InitEqD")
(split)
(simpreal "x1=y")
(use "yDef")
(split)
(use "InitEqD")
(simp "ag1Def")
(use "AgCoRecRR")
(simp "<-" "v2Prop")
(use "InREq")
;; Proof finished.
;; (cp)
(save "GfpCoGHMRAuxG")
;; (set! COMMENT-FLAG #t)

;; (set! COMMENT-FLAG #f)
;; GfpCoGHMRAuxH
(set-goal "allnc gv^(
     allnc x,v^(
      YMR^ x v^ -> 
      (OrDMR (cterm (bgsu^) 
               (ExRTMR int
                 boole yprod(ag ysum gamma1)
                 (cterm (d,bgsu^0) 
                 (ExRTMR rea
                   boole yprod(ag ysum gamma1)
                   (cterm (x0,bgsu^1) 
                   (ExRTMR rea
                     boole yprod(ag ysum gamma1)
                     (cterm (y,bgsu^2) 
                     (AndDMR (cterm (boole^) PsdMR d boole^)
                       (cterm (gsu^) 
                       (AndRMR (cterm () Real x0)
                         (cterm (gsu^0) 
                         (AndRMR (cterm () abs x0<<=1)
                           (cterm (gsu^1) 
                           (AndLMR (cterm (gsu^2) 
                                     (OrDMR (cterm (ag^) CoGMR x0 ag^)
                                       (cterm (u^) XMR^ x0 u^))
                                     gsu^2)
                             (cterm () y===(1#2)*(x0+1)*d andnc x===y))
                           gsu^1))
                         gsu^0))
                       gsu^))
                     bgsu^2))
                   bgsu^1))
                 bgsu^0))
               bgsu^)
        (cterm (hsv^) 
        (ExRTMR rea
          ah ysum gamma2
          (cterm (x0,hsv^0) 
          (ExRTMR rea
            ah ysum gamma2
            (cterm (y,hsv^1) 
            (AndRMR (cterm () Real x0)
              (cterm (hsv^2) 
              (AndRMR (cterm () abs x0<<=1)
                (cterm (hsv^3) 
                (AndLMR (cterm (hsv^4) 
                          (OrDMR (cterm (ah^) CoHMR x0 ah^)
                            (cterm (v^0) YMR^ x0 v^0))
                          hsv^4)
                  (cterm () y===(1#2)*x0 andnc x===y))
                hsv^3))
              hsv^2))
            hsv^1))
          hsv^0))
        hsv^))
      (gv^ v^)) -> 
     allnc gu^,x,ah^(
      exnc v^(
       YMR^ x v^ andnc ah^ eqd(CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^) -> 
      exnc d,x0,y,boole^0(
       PsdMR d boole^0 andnc 
       Real x0 andnc 
       abs x0<<=1 andnc 
       exnc ag^1(
        (CoGMR x0 ag^1 ornc 
         exnc u^(
          XMR^ x0 u^ andnc ag^1 eqd(CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^)) andnc 
        y===(1#2)*(x0+1)*d andnc x eqd y andnc ah^ eqd Fin boole^0 ag^1)) ornc 
      exnc x0,y(
       Real x0 andnc 
       abs x0<<=1 andnc 
       exnc ah^0(
        (CoHMR x0 ah^0 ornc 
         exnc v^(
          YMR^ x0 v^ andnc ah^0 eqd(CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^)) andnc 
        y===(1#2)*x0 andnc x eqd y andnc ah^ eqd D ah^0))))")
(assume "gv^" "Step2" "gu^" "x1" "ah^1" "v1Ex")
(by-assume "v1Ex" "v^1" "x1v1Prop")
(elim "x1v1Prop")
(drop "x1v1Prop")
(assume "YMRx1v1" "ah1Def")
(inst-with-to "Step2" (pt "x1") (pt "v^1") "YMRx1v1" "Step2Inst")
(drop "Step2")
;; 11
;; Step2Inst is an OrDMR-formula with realizer (gv^ v^1) of sum type.
;; We assert the implied disjunction.
(assert "exnc bgsu^(
 (ExRTMR int boole yprod(ag ysum gamma1)
   (cterm (d,bgsu^0) 
   (ExRTMR rea
     boole yprod(ag ysum gamma1)
     (cterm (x,bgsu^1) 
     (ExRTMR rea
       boole yprod(ag ysum gamma1)
       (cterm (y,bgsu^2) 
       (AndDMR (cterm (boole^) PsdMR d boole^)
         (cterm (gsu^) 
         (AndRMR (cterm () Real x)
           (cterm (gsu^0) 
           (AndRMR (cterm () abs x<<=1)
             (cterm (gsu^1) 
             (AndLMR (cterm (gsu^2) 
                       (OrDMR (cterm (ag^) CoGMR x ag^)
                         (cterm (u^) XMR^ x u^))
                       gsu^2)
               (cterm () y===(1#2)*(x+1)*d andnc x1===y))
             gsu^1))
           gsu^0))
         gsu^))
       bgsu^2))
     bgsu^1))
   bgsu^0))
  bgsu^ andnc
  gv^ v^1 eqd(InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))bgsu^) ornc
 exnc hsv^(
  (ExRTMR rea ah ysum gamma2
    (cterm (x,hsv^0) 
    (ExRTMR rea
      ah ysum gamma2
      (cterm (y,hsv^1) 
      (AndRMR (cterm () Real x)
        (cterm (hsv^2) 
        (AndRMR (cterm () abs x<<=1)
          (cterm (hsv^3) 
          (AndLMR (cterm (hsv^4) 
                    (OrDMR (cterm (ah^) CoHMR x ah^)
                      (cterm (v^) YMR^ x v^))
                    hsv^4)
            (cterm () y===(1#2)*x andnc x1===y))
          hsv^3))
        hsv^2))
      hsv^1))
    hsv^0))
  hsv^ andnc 
  gv^ v^1 eqd(InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))hsv^)")
;; We prove this asserted disjunction from Step2Inst
(elim "Step2Inst")
;;14,15
(drop "Step2Inst")
(assume "bgsu^" "bgsuProp")
(intro 0)
(intro 0 (pt "bgsu^"))
(split)
(use "bgsuProp")
(use "InitEqD")
;; 15
(drop "Step2Inst")
(assume "hsv^" "hsvProp")
(intro 1)
(intro 0 (pt "hsv^"))
(split)
(use "hsvProp")
(use "InitEqD")
;; Assertion proved.
;; 12
(drop "Step2Inst")
(assume "Disj")
(elim "Disj")
;; 30,31
(drop "Disj")
(assume "bgsuEx")
(by-assume "bgsuEx" "bgsu^" "Conj")
(elim "Conj")
(assume "bgsuProp" "InLEq")
(drop "Conj")
(assert "exnc d((ExRTMR rea
                        boole yprod(ag ysum gamma1)
                        (cterm (x,bgsu^1) 
                        (ExRTMR rea
                          boole yprod(ag ysum gamma1)
                          (cterm (y,bgsu^2) 
                          (AndDMR (cterm (boole^) PsdMR d boole^)
                            (cterm (gsu^) 
                            (AndRMR (cterm () Real x)
                              (cterm (gsu^0) 
                              (AndRMR (cterm () abs x<<=1)
                                (cterm (gsu^1) 
                                (AndLMR (cterm (gsu^2) 
                                          (OrDMR (cterm (ag^) CoGMR x ag^)
                                            (cterm (u^) XMR^ x u^))
                                          gsu^2)
                                  (cterm () y===(1#2)*(x+1)*d andnc x1===y))
                                gsu^1))
                              gsu^0))
                            gsu^))
                          bgsu^2))
                        bgsu^1))bgsu^)")
(elim "bgsuProp")
(assume "d" "bgsu^1" "bgsu1Prop")
(intro 0 (pt "d"))
(use "bgsu1Prop")
;; Assertion proved.
(drop "bgsuProp")
(assume "dEx")
(by-assume "dEx" "d" "dProp")
(intro 0) ;here we take the lhs of the initial disjunction
(intro 0 (pt "d"))
(assert "exnc x((ExRTMR rea
                 boole yprod(ag ysum gamma1)
                 (cterm (y,bgsu^1) 
                 (AndDMR (cterm (boole^) PsdMR d boole^)
                   (cterm (gsu^) 
                   (AndRMR (cterm () Real x)
                     (cterm (gsu^0) 
                     (AndRMR (cterm () abs x<<=1)
                       (cterm (gsu^1) 
                       (AndLMR (cterm (gsu^2) 
                                 (OrDMR (cterm (ag^) CoGMR x ag^)
                                   (cterm (u^) XMR^ x u^))
                                 gsu^2)
                         (cterm () y===(1#2)*(x+1)*d andnc x1===y))
                       gsu^1))
                     gsu^0))
                   gsu^))
                 bgsu^1))bgsu^)")
(elim "dProp")
(drop "dProp")
(assume "x2" "bgsu^2" "bgsu2Prop")
(intro 0 (pt "x2"))
(use "bgsu2Prop")
;; Assertion proved.
(drop "dProp")
(assume "x2Ex")
(by-assume "x2Ex" "x2" "x2Prop")
(intro 0 (pt "x2"))
(assert "exnc y((AndDMR (cterm (boole^) PsdMR d boole^)
                        (cterm (gsu^) 
                        (AndRMR (cterm () Real x2)
                          (cterm (gsu^0) 
                          (AndRMR (cterm () abs x2<<=1)
                            (cterm (gsu^1) 
                            (AndLMR (cterm (gsu^2) 
                                      (OrDMR (cterm (ag^) CoGMR x2 ag^)
                                        (cterm (u^) XMR^ x2 u^))
                                      gsu^2)
                              (cterm () y===(1#2)*(x2+1)*d andnc x1===y))
                            gsu^1))
                          gsu^0))
                        gsu^))bgsu^)")
(elim "x2Prop")
(drop "x2Prop")
(assume "y" "bgsu^3" "bgsu3Prop")
(intro 0 (pt "y"))
(use "bgsu3Prop")
;; Assertion proved.
(assume "ExNcHypy")
(by-assume "ExNcHypy" "y" "yProp")
(intro 0 (pt "x1"))
(drop "x2Prop")
(assert "bgsu^ eqd clft bgsu^ pair(crht bgsu^) andnc
 PsdMR d(clft bgsu^) andnc
 (AndRMR (cterm () Real x2)
                            (cterm (gsu^0) 
                            (AndRMR (cterm () abs x2<<=1)
                              (cterm (gsu^1) 
                              (AndLMR (cterm (gsu^2) 
                                        (OrDMR (cterm (ag^) CoGMR x2 ag^)
                                          (cterm (u^) XMR^ x2 u^))
                                        gsu^2)
                                (cterm () y===(1#2)*(x2+1)*d andnc x1===y))
                              gsu^1))
                            gsu^0))(crht bgsu^)")
(elim "yProp")
(drop "yProp")
(assume "boole^" "PsdMRdb" "gsu^" "AndRMRgsu")
(ng #t)
(split)
(use "InitEqD")
(split)
(use "PsdMRdb")
(use "AndRMRgsu")
;; Assertion proved.
(drop "yProp")
(assume "Conj1")
(inst-with-to "Conj1" 'left "bgsuPair")
(inst-with-to "Conj1" 'right 'left "PsdMRdlftbgsu")
(inst-with-to "Conj1" 'right 'right "AndRMRgsu")
(drop "Conj1")
(assert "Real x2 andnc (AndRMR (cterm () abs x2<<=1)
                (cterm (gsu^0) 
                (AndLMR (cterm (gsu^1) 
                          (OrDMR (cterm (ag^) CoGMR x2 ag^)
                            (cterm (u^) XMR^ x2 u^))
                          gsu^1)
                  (cterm () y===(1#2)*(x2+1)*d andnc x1===y))
                gsu^0))(crht bgsu^)")
(elim "AndRMRgsu")
(drop "AndRMRgsu")
(assume "Rx2" "gsu^" "AndRMR1gsu")
(split)
(use "Rx2")
(use "AndRMR1gsu")
;; Assertion proved.
(drop "AndRMRgsu")
(assume "Conj2")
(inst-with-to "Conj2" 'left "Rx2")
(inst-with-to "Conj2" 'right "AndRMRcrhtbgsu")
(drop "Conj2")
(assert "abs x2<<=1 andnc (AndLMR (cterm (gsu^0) 
                             (OrDMR (cterm (ag^) CoGMR x2 ag^)
                               (cterm (u^) XMR^ x2 u^))
                             gsu^0)
                     (cterm () y===(1#2)*(x2+1)*d andnc x1===y))(crht bgsu^)")
(elim "AndRMRcrhtbgsu")
(drop "AndRMRcrhtbgsu")
(assume "x2Bd" "gsu^" "AndLMRgsu")
(split)
(use "x2Bd")
(use "AndLMRgsu")
;; Assertion proved.
(drop "AndRMRcrhtbgsu")
(assume "Conj3")
(inst-with-to "Conj3" 'left "x2Bd")
(inst-with-to "Conj3" 'right "AndLMRcrhtbgsu")
(drop "Conj3")
(assert "(OrDMR (cterm (ag^) CoGMR x2 ag^)
                (cterm (u^) XMR^ x2 u^))(crht bgsu^)
 andnc
 y===(1#2)*(x2+1)*d andnc x1===y")
(elim "AndLMRcrhtbgsu")
(drop "AndLMRcrhtbgsu")
(assume "gsu^" "OrDMRgsu" "Conj4")
(split)
(use "OrDMRgsu")
(use "Conj4")
;; Assertion proved.
(drop "AndLMRcrhtbgsu")
(assume "Conj5")
(inst-with-to "Conj5" 'left "OrDMRcrhtbgsu")
(inst-with-to "Conj5" 'right "Conj6")
(elim "Conj6")
(drop "Conj6")
(assume "yDef" "x1=y")
(drop "Conj5")
(intro 0 (pt "(clft bgsu^)"))
(split)
(use "PsdMRdlftbgsu")
(split)
(use "Rx2")
(split)
(use "x2Bd")
(assert "exnc ag^(CoGMR x2 ag^ andnc crht bgsu^ eqd(InL ag gamma1)ag^) ornc 
         exnc u^(XMR^ x2 u^ andnc crht bgsu^ eqd(InR gamma1 ag)u^)")
(elim "OrDMRcrhtbgsu")
;; 149,150
(drop "OrDMRcrhtbgsu")
(assume "ag^2" "CoGMRx2ag2")
(intro 0)
(intro 0 (pt "ag^2"))
(split)
(use "CoGMRx2ag2")
(use "InitEqD")
;; 150
(drop "OrDMRcrhtbgsu")
(assume "u^2" "XMRx2u2")
(intro 1)
(intro 0 (pt "u^2"))
(split)
(use "XMRx2u2")
(use "InitEqD")
;; Assertion proved.
;; 147
(drop "OrDMRcrhtbgsu")
(assume "Disj1")
(elim "Disj1")
;; 165,166
(drop "Disj1")
(assume "agEx")
(by-assume "agEx" "ag^2" "ag2Prop")
(intro 0 (pt "ag^2"))
(split)
(intro 0)
(use "ag2Prop")
(split)
(simpreal "x1=y")
(use "yDef")
(split)
(use "InitEqD")
;; ?^180:ah^1 eqd Fin clft bgsu^ ag^2
(simp "ah1Def")
;; (pp "AhCoRecLL")

;; allnc gv^,v^,boole^,ag^0,gu^(
;;  gv^ v^ eqd
;;  (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
;;  (boole^ pair(InL ag gamma1)ag^0) -> 
;;  (CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^ eqd Fin boole^ ag^0)

(use "AhCoRecLL")
(simp "InLEq")
(simp "<-" "ag2Prop")
(simp "<-" "bgsuPair")
(use "InitEqD")
;; 166
(drop "Disj1")
(assume "uEx")
(by-assume "uEx" "u^2" "u2Prop")
;; (pp "AhCoRecLR")

;; allnc gv^,v^,boole^,u^,gu^(
;;  gv^ v^ eqd
;;  (InL (boole yprod(ag ysum gamma1)) (ah ysum gamma2))
;;  (boole^ pair(InR gamma1 ag)u^) -> 
;;  (CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^ eqd 
;;  Fin boole^((CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^))

(intro 0 (pt "(CoRec gamma1=>ag gamma2=>ah)u^2 gu^ gv^"))
(split)
(intro 1)
(intro 0 (pt "u^2"))
(split)
(use "u2Prop")
(use "InitEqD")
(split)
(simpreal "x1=y")
(use "yDef")
(split)
(use "InitEqD")
(simp "ah1Def")
(use "AhCoRecLR")
(simp "<-" "u2Prop")
(simp "<-" "bgsuPair")
(use "InLEq")
;; 31
(drop "Disj")
(assume "hsvEx")
(by-assume "hsvEx" "hsv^" "Conj")
(elim "Conj")
(assume "hsvProp" "InREq")
(drop "Conj")
(assert "exnc x((ExRTMR rea
                      ah ysum gamma2
                      (cterm (y,hsv^1) 
                      (AndRMR (cterm () Real x)
                        (cterm (hsv^2) 
                        (AndRMR (cterm () abs x<<=1)
                          (cterm (hsv^3) 
                          (AndLMR (cterm (hsv^4) 
                                    (OrDMR (cterm (ah^) CoHMR x ah^)
                                      (cterm (v^) YMR^ x v^))
                                    hsv^4)
                            (cterm () y===(1#2)*x andnc x1===y))
                          hsv^3))
                        hsv^2))
                      hsv^1))hsv^)")
(elim "hsvProp")
(assume "x2" "hsv^2" "hsv2Prop")
(intro 0 (pt "x2"))
(use "hsv2Prop")
;; Assertion proved.
(drop "hsvProp")
(assume "x2Ex")
(by-assume "x2Ex" "x2" "x2Prop")
(intro 1) ;here we take the rhs of the initial disjunction
(intro 0 (pt "x2"))
(assert "exnc y((AndRMR (cterm () Real x2)
                   (cterm (hsv^1) 
                   (AndRMR (cterm () abs x2<<=1)
                     (cterm (hsv^2) 
                     (AndLMR (cterm (hsv^3) 
                               (OrDMR (cterm (ah^) CoHMR x2 ah^)
                                 (cterm (v^) YMR^ x2 v^))
                               hsv^3)
                       (cterm () y===(1#2)*x2 andnc x1===y))
                     hsv^2))
                   hsv^1))hsv^)")
(elim "x2Prop")
(drop "x2Prop")
(assume "y" "hsv^1" "hsv1Prop")
(intro 0 (pt "y"))
(use "hsv1Prop")
;; Assertion proved.
(drop "x2Prop")
(assume "yEx")
(by-assume "yEx" "y" "yProp")
(intro 0 (pt "x1"))
(assert "Real x2 andnc ((AndRMR (cterm () abs x2<<=1)
                        (cterm (hsv^1) 
                        (AndLMR (cterm (hsv^2) 
                                  (OrDMR (cterm (ah^) CoHMR x2 ah^)
                                    (cterm (v^) YMR^ x2 v^))
                                  hsv^2)
                          (cterm () y===(1#2)*x2 andnc x1===y))
                        hsv^1))hsv^)")
(elim "yProp")
(drop "yProp")
(assume "Rx2" "hsv^1" "hsv1Prop")
(split)
(use "Rx2")
(use "hsv1Prop")
;; Assertion proved.
(drop "yProp")
(assume "Conj1")
(inst-with-to "Conj1" 'left "Rx2")
(inst-with-to "Conj1" 'right "AndRMRhsv")
(drop "Conj1")
(assert "abs x2<<=1 andnc (AndLMR (cterm (hsv^1) 
                        (OrDMR (cterm (ah^) CoHMR x2 ah^)
                          (cterm (v^) YMR^ x2 v^))
                        hsv^1)
                (cterm () y===(1#2)*x2 andnc x1===y))hsv^")
(elim "AndRMRhsv")
(drop "AndRMRhsv")
(assume "x2Bd" "hsv^1" "AndLMRhsv1")
(split)
(use "x2Bd")
(use "AndLMRhsv1")
;; Assertion proved.
(drop "AndRMRhsv")
(assume "Conj2")
(inst-with-to "Conj2" 'left "x2Bd")
(inst-with-to "Conj2" 'right "AndLMRhsv")
(drop "Conj2")
(assert "(OrDMR (cterm (ah^) CoHMR x2 ah^) (cterm (v^) YMR^ x2 v^))hsv^ andnc
         y===(1#2)*x2 andnc x1===y")
(elim "AndLMRhsv")
(drop "AndLMRhsv")
(assume "hsv^1" "OrDMRhsv1" "Conj3")
(inst-with-to "Conj3" 'left "yDef")
(inst-with-to "Conj3" 'right "x1=y")
(drop "Conj3")
(split)
(use "OrDMRhsv1")
(split)
(use "yDef")
(use "x1=y")
;; Assertion proved.
(drop "AndLMRhsv")
(assume "Conj4")
(inst-with-to "Conj4" 'left "OrDMRhsv")
(inst-with-to "Conj4" 'right "Conj5")
(drop "Conj4")
(inst-with-to "Conj5" 'left "yDef")
(inst-with-to "Conj5" 'right "x1=y")
(drop "Conj5")
(split)
(use "Rx2")
(split)
(use "x2Bd")
(assert "exnc ah^(CoHMR x2 ah^ andnc hsv^ eqd(InL ah gamma2)ah^) ornc
         exnc v^(YMR^ x2 v^ andnc hsv^ eqd(InR gamma2 ah)v^)")
(elim "OrDMRhsv")
;; 299,230
(drop "OrDMRhsv")
(assume "ah^" "CoHMRx2ah")
(intro 0)
(intro 0 (pt "ah^"))
(split)
(use "CoHMRx2ah")
(use "InitEqD")
;; 300
(drop "OrDMRhsv")
(assume "v^2" "YMRx2v2")
(intro 1)
(intro 0 (pt "v^2"))
(split)
(use "YMRx2v2")
(use "InitEqD")
;; Assertion proved.
(drop "OrDMRhsv")
(assume "Disj1")
(elim "Disj1")
;; 315,316
(drop "Disj1")
(assume "ahEx")
(by-assume "ahEx" "ah^" "ahProp")
(intro 0 (pt "ah^"))
(split)
(intro 0)
(use "ahProp")
(split)
(simpreal "x1=y")
(use "yDef")
(split)
(use "InitEqD")
(simp "ah1Def")
;; (pp "AhCoRecRL")

;; allnc gv^,v^,ah^,gu^(
;;  gv^ v^ eqd
;;  (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))((InL ah gamma2)ah^) -> 
;;  (CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^ eqd D ah^)

(use "AhCoRecRL")
(simp "InREq")
(simp "<-" "ahProp")
(use "InitEqD")
;; 316
(drop "Disj1")
(assume "vEx")
(by-assume "vEx" "v^2" "v2Prop")
;; (pp "AhCoRecRR")

;; allnc gv^,v^,v^0,gu^(
;;  gv^ v^ eqd
;;  (InR (ah ysum gamma2) (boole yprod(ag ysum gamma1)))((InR gamma2 ah)v^0) -> 
;;  (CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^ eqd 
;;  D((CoRec gamma2=>ah gamma1=>ag)v^0 gu^ gv^))
(intro 0 (pt "(CoRec gamma2=>ah gamma1=>ag)v^2 gu^ gv^"))
(split)
(intro 1)
(intro 0 (pt "v^2"))
(split)
(use "v2Prop")
(use "InitEqD")
(split)
(simpreal "x1=y")
(use "yDef")
(split)
(use "InitEqD")
(simp "ah1Def")
(use "AhCoRecRR")
(simp "<-" "v2Prop")
(use "InREq")
;; Proof finished.
;; (cp)
(save "GfpCoGHMRAuxH")
;; (set! COMMENT-FLAG #t)

;; GfpCoGMR
(set-goal (rename-variables
	   (real-and-formula-to-mr-formula
	    (pt "(CoRec gamma1=>ag gamma2=>ah)")
	    (aconst-to-formula
	     (imp-formulas-to-gfp-aconst
	      (pf "X x -> CoG x") (pf "Y x -> CoH x"))))))
(assume "x" "u^" "XMRxu" "gu^" "Step1" "gv^" "Step2")
(use-with
 (make-proof-in-aconst-form
  (imp-formulas-to-gfp-aconst
   (pf "(Pvar rea ag)^1 x ag^ -> CoGMR x ag^")
   (pf "(Pvar rea ah)^2 x ah^ -> CoHMR x ah^")))
 (make-cterm
  (pv "x1") (pv "ag^")
  (pf "exnc u^(XMR^ x1 u^ andnc ag^ eqd
                                  ((CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^))"))
 (make-cterm
  (pv "x1") (pv "ah^")
  (pf "exnc v^(YMR^ x1 v^ andnc ah^ eqd
                                  ((CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^))"))
 (pt "x") (pt "((CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^)") (pt "gu^") (pt "gv^")
 "?" "?" "?")
;; 3-5
(drop "Step1" "Step2")
(intro 0 (pt "u^"))
(split)
(use "XMRxu")
(use "InitEqD")
;; 4
(drop "Step2")
(use "GfpCoGHMRAuxG")
(use "Step1")
;; 5
(drop "Step1")
(use "GfpCoGHMRAuxH")
(use "Step2")
;; Proof finished.
;; (cp)
(save "GfpCoGMR")

;; GfpCoHMR
(set-goal (rename-variables
	   (real-and-formula-to-mr-formula
	    (pt "(CoRec gamma2=>ah gamma1=>ag)")
	    (aconst-to-formula
	     (imp-formulas-to-gfp-aconst
	      (pf "Y x -> CoH x") (pf "X x -> CoG x"))))))
(assume "x" "v^" "YMRxv" "gu^" "Step1" "gv^" "Step2")
(use-with
 (make-proof-in-aconst-form
  (imp-formulas-to-gfp-aconst
   (pf "(Pvar rea ah)^2 x ah^ -> CoHMR x ah^")
   (pf "(Pvar rea ag)^1 x ag^ -> CoGMR x ag^")))
 (make-cterm
  (pv "x1") (pv "ah^")
  (pf "exnc v^(YMR^ x1 v^ andnc ah^ eqd
                                  ((CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^))"))
 (make-cterm
  (pv "x1") (pv "ag^")
  (pf "exnc u^(XMR^ x1 u^ andnc ag^ eqd
                                  ((CoRec gamma1=>ag gamma2=>ah)u^ gu^ gv^))"))
 (pt "x") (pt "((CoRec gamma2=>ah gamma1=>ag)v^ gu^ gv^)") (pt "gu^") (pt "gv^")
 "?" "?" "?")
;; 3-5
(drop "Step1" "Step2")
(intro 0 (pt "v^"))
(split)
(use "YMRxv")
(use "InitEqD")
;; 4
(drop "Step2")
(use "GfpCoGHMRAuxG")
(use "Step1")
;; 5
(drop "Step1")
(use "GfpCoGHMRAuxH")
(use "Step2")
;; Proof finished.
;; (cp)
(save "GfpCoHMR")

(deanimate "Lft")
(deanimate "Rht")

;; Similarly we prove ClauseCoGMR and ClauseCoHMR

;; ClauseCoGMR
(set-goal (rename-variables
	   (real-and-formula-to-mr-formula
	    (pt "(Destr ag)")
	    (aconst-to-formula
	     (theorem-name-to-aconst "CoGClause")))))
(assume "x" "ag^" "CoGMRxag")
(inst-with-to "CoGMRClause" (pt "x") (pt "ag^") "CoGMRxag" "CoGMRClauseInst")
(elim "CoGMRClauseInst")
;; 5,6
(drop "CoGMRClauseInst")
(assume "dExHyp")
(by-assume "dExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(by-assume "dx1yProp" "boole^" "dx1ybProp")
(elim "dx1ybProp")
(drop "dx1ybProp")
(assume "PsdMRdb" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "Rx1" "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "x1Bd" "agEx")
(by-assume "agEx" "ag^1" "ag1Prop")
(elim "ag1Prop")
(drop "ag1Prop")
(assume "CoGMRx1ag1" "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "yDef" "Conj4")
(elim "Conj4")
(drop "Conj4")
(assume "x=y" "agDef")
(simp "agDef")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(intro 0 (pt "y"))
(intro 0)
(use "PsdMRdb")
(intro 0)
(use "Rx1")
(intro 0)
(use "x1Bd")
(intro 0)
(use "CoGMRx1ag1")
(split)
(use "yDef")
(simp "x=y")
(use "RealEqRefl")
(autoreal)
;; 6
(drop "CoGMRClauseInst")
(assume "x1ExHyp")
(by-assume "x1ExHyp" "x1" "x1Prop")
(by-assume "x1Prop" "y" "x1yProp")
(elim "x1yProp" )
(drop "x1yProp" )
(assume "Rx1" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "x1Bd" "ahExHyp")
(by-assume "ahExHyp" "ah^" "ahProp")
(elim "ahProp")
(drop "ahProp")
(assume "CoHMRx1ah" "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "yDef" "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "x=y" "agDef")
(simp "agDef")
(ng #t)
(intro 1)
(intro 0 (pt "x1"))
(intro 0 (pt "y"))
(intro 0)
(use "Rx1")
(intro 0)
(use "x1Bd")
(intro 0)
(use "CoHMRx1ah")
(split)
(use "yDef")
(simp "x=y")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "ClauseCoGMR")

(add-sound "CoGClause")

;; > ok, CoGClauseSound has been added as a new theorem:

;; allnc x,ag^(
;;  CoGMR x ag^ -> 
;;  (OrDMR (cterm ((boole yprod ag)^0) 
;;           (ExRTMR int
;;             boole yprod ag
;;             (cterm (d,(boole yprod ag)^1) 
;;             (ExRTMR rea
;;               boole yprod ag
;;               (cterm (x0,(boole yprod ag)^2) 
;;               (ExRTMR rea
;;                 boole yprod ag
;;                 (cterm (y,(boole yprod ag)^3) 
;;                 (AndDMR (cterm (boole^4) PsdMR d boole^4)
;;                   (cterm (ag^4) 
;;                   (AndRMR (cterm () Real x0)
;;                     (cterm (ag^5) 
;;                     (AndRMR (cterm () abs x0<<=1)
;;                       (cterm (ag^6) 
;;                       (AndLMR (cterm (ag^7) CoGMR x0 ag^7)
;;                         (cterm () y===(1#2)*(x0+IntN 1)* ~d andnc x===y))
;;                       ag^6))
;;                     ag^5))
;;                   ag^4))
;;                 (boole yprod ag)^3))
;;               (boole yprod ag)^2))
;;             (boole yprod ag)^1))
;;           (boole yprod ag)^0)
;;    (cterm (ah^0) 
;;    (ExRTMR rea
;;      ah
;;      (cterm (x0,ah^1) 
;;      (ExRTMR rea
;;        ah
;;        (cterm (y,ah^2) 
;;        (AndRMR (cterm () Real x0)
;;          (cterm (ah^3) 
;;          (AndRMR (cterm () abs x0<<=1)
;;            (cterm (ah^4) 
;;            (AndLMR (cterm (ah^5) CoHMR x0 ah^5)
;;              (cterm () y===(1#2)*x0 andnc x===y))
;;            ah^4))
;;          ah^3))
;;        ah^2))
;;      ah^1))
;;    ah^0))
;;  (cCoGClause ag^))

;; with computation rule

;; cCoGClause eqd(Destr ag)

;; (cdp "CoGClauseSound")

;; Here we do not deanimate CoGClause, since we do not want to use
;; cCoGClause as an abbreviation.

;; ClauseCoHMR
(set-goal (rename-variables
	   (real-and-formula-to-mr-formula
	    (pt "(Destr ah)")
	    (aconst-to-formula
	     (theorem-name-to-aconst "CoHClause")))))
(assume "x" "ah^" "CoHMRxah")
(inst-with-to "CoHMRClause" (pt "x") (pt "ah^") "CoHMRxah" "CoHMRClauseInst")
(elim "CoHMRClauseInst")
;; 5,6
(drop "CoHMRClauseInst")
(assume "dExHyp")
(by-assume "dExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(by-assume "dx1yProp" "boole^" "dx1ybProp")
(elim "dx1ybProp")
(drop "dx1ybProp")
(assume "PsdMRdb" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "Rx1" "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "x1Bd" "agEx")
(by-assume "agEx" "ag^1" "ag1Prop")
(elim "ag1Prop")
(drop "ag1Prop")
(assume "CoGMRx1ag1" "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "yDef" "Conj4")
(elim "Conj4")
(drop "Conj4")
(assume "x=y" "ahDef")
(simp "ahDef")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(intro 0 (pt "y"))
(intro 0)
(use "PsdMRdb")
(intro 0)
(use "Rx1")
(intro 0)
(use "x1Bd")
(intro 0)
(use "CoGMRx1ag1")
(split)
(use "yDef")
(simp "x=y")
(use "RealEqRefl")
(autoreal)
;; 6
(drop "CoHMRClauseInst")
(assume "x1ExHyp")
(by-assume "x1ExHyp" "x1" "x1Prop")
(by-assume "x1Prop" "y" "x1yProp")
(elim "x1yProp" )
(drop "x1yProp" )
(assume "Rx1" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "x1Bd" "ahExHyp")
(by-assume "ahExHyp" "ah^1" "ah1Prop")
(elim "ah1Prop")
(drop "ah1Prop")
(assume "CoHMRx1ah1" "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "yDef" "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "x=y" "ahDef")
(simp "ahDef")
(ng #t)
(intro 1)
(intro 0 (pt "x1"))
(intro 0 (pt "y"))
(intro 0)
(use "Rx1")
(intro 0)
(use "x1Bd")
(intro 0)
(use "CoHMRx1ah1")
(split)
(use "yDef")
(simp "x=y")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "ClauseCoHMR")

(add-sound "CoHClause")

;; ok, CoHClauseSound has been added as a new theorem:

;; allnc x,ah^(
;;  CoHMR x ah^ -> 
;;  (OrDMR (cterm (bg^) 
;;           (ExRTMR int
;;             boole yprod ag
;;             (cterm (d,bg^0) 
;;             (ExRTMR rea
;;               boole yprod ag
;;               (cterm (x0,bg^1) 
;;               (ExRTMR rea
;;                 boole yprod ag
;;                 (cterm (y,bg^2) 
;;                 (AndDMR (cterm (boole^0) PsdMR d boole^0)
;;                   (cterm (ag^0) 
;;                   (AndRMR (cterm () Real x0)
;;                     (cterm (ag^1) 
;;                     (AndRMR (cterm () abs x0<<=1)
;;                       (cterm (ag^2) 
;;                       (AndLMR (cterm (ag^3) CoGMR x0 ag^3)
;;                         (cterm () y===(1#2)*(x0+1)*d andnc x===y))
;;                       ag^2))
;;                     ag^1))
;;                   ag^0))
;;                 bg^2))
;;               bg^1))
;;             bg^0))
;;           bg^)
;;    (cterm (ah^0) 
;;    (ExRTMR rea
;;      ah
;;      (cterm (x0,ah^1) 
;;      (ExRTMR rea
;;        ah
;;        (cterm (y,ah^2) 
;;        (AndRMR (cterm () Real x0)
;;          (cterm (ah^3) 
;;          (AndRMR (cterm () abs x0<<=1)
;;            (cterm (ah^4) 
;;            (AndLMR (cterm (ah^5) CoHMR x0 ah^5)
;;              (cterm () y===(1#2)*x0 andnc x===y))
;;            ah^4))
;;          ah^3))
;;        ah^2))
;;      ah^1))
;;    ah^0))
;;  (cCoHClause ah^))

;; with computation rule

;; cCoHClause eqd(Destr ah)

;; (cdp "CoHClauseSound")

;; Here we do not deanimate CoHClause, since we do not want to use
;; cCoHClause as an abbreviation.

;; By the greatest-fixed-point (or coinduction) axiom CoG is a fixed
;; point.  Hence the inverse implication holds as well.

;; CoGClauseInv
(set-goal "allnc x(
 exr d,x0,y(Psd d andd Real x0 andi abs x0<<=1 
            andr CoG x0 andl y===(1#2)*(x0+IntN 1)* ~d andnc x===y) ord 
 exr x0,y(Real x0 andi abs x0<<=1 andr CoH x0 andl
          y===(1#2)*x0 andnc x===y) -> CoG x)")
(assume "x" "Disj")
(coind
 "Disj"
 (pf "exr d,x0,y(
  Psd d andd Real x0 andi abs x0<<=1 andr CoG x0 andl
  y===(1#2)*(x0+1)*d andnc x===y) ord 
  exr x0,y(Real x0 andi abs x0<<=1 andr CoH x0 andl
           y===(1#2)*x0 andnc x===y) -> CoH x"))
;; 3,4
(drop "Disj")
(assume "x1" "x1Prop")
(elim "x1Prop")
;; 7,8
(drop "x1Prop")
;; LR initial case
(assume "ExHypLR")
(by-assume "ExHypLR" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(by-assume "dx2Prop" "y2" "dx2y2Prop")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x2"))
(intro 0 (pt "y2"))
(split)
(use "dx2y2Prop")
(split)
(use "dx2y2Prop")
(split)
(use "dx2y2Prop")
(split)
(intro 0)
(use "dx2y2Prop")
(use "dx2y2Prop")
;; 8
(drop "x1Prop")
;; generating case
(assume "ExHypU")
(by-assume "ExHypU" "x2" "x2Prop")
(by-assume "x2Prop" "y2" "x2y2Prop")
(intro 1)
(intro 0 (pt "x2"))
(intro 0 (pt "y2"))
(split)
(use "x2y2Prop")
(split)
(use "x2y2Prop")
(split)
(intro 0)
(use "x2y2Prop")
(use "x2y2Prop")
;; 4
(drop "Disj")
(assume "x1" "x1Prop")
(elim "x1Prop")
;; 49,50
(drop "x1Prop")
;; LR
(assume "ExHypLR")
(by-assume "ExHypLR" "d" "dProp")
(by-assume "dProp" "x2" "x2dProp")
(by-assume "x2dProp" "y2" "x2dy2Prop")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x2"))
(intro 0 (pt "y2"))
(split)
(use "x2dy2Prop")
(split)
(use "x2dy2Prop")
(split)
(use "x2dy2Prop")
(split)
(intro 0)
(use "x2dy2Prop")
(use "x2dy2Prop")
;; 50
(drop "x1Prop")
;; SdM
(assume "ExHypD")
(by-assume "ExHypD" "x2" "x2Prop")
(by-assume "x2Prop" "y2" "x2y2Prop")
(intro 1)
(intro 0 (pt "x2"))
(intro 0 (pt "y2"))
(split)
(use "x2y2Prop")
(split)
(use "x2y2Prop")
(split)
(intro 0)
(use "x2y2Prop")
(use "x2y2Prop")
;; Proof finished.
;; (cdp)
(save "CoGClauseInv")

(define eterm (proof-to-extracted-term))
(add-var-name "bgh" (py "boole yprod ag ysum ah"))
(add-var-name "bg" (py "boole yprod ag"))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [bgh]
;;  (CoRec boole yprod ag ysum ah=>ag boole yprod ag ysum ah=>ah)bgh
;;  ([bgh0]
;;    [case bgh0
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah -> InR(InL ah))])
;;  ([bgh0]
;;    [case bgh0
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah -> InR(InL ah))])

(add-sound "CoGClauseInv")

;; ok, CoGClauseInvSound has been added as a new theorem:

;; allnc x,bgh^(
;;  (OrDMR (cterm (bg^) 
;;           (ExRTMR int
;;             boole yprod ag
;;             (cterm (d,bg^0) 
;;             (ExRTMR rea
;;               boole yprod ag
;;               (cterm (x0,bg^1) 
;;               (ExRTMR rea
;;                 boole yprod ag
;;                 (cterm (y,bg^2) 
;;                 (AndDMR (cterm (boole^) PsdMR d boole^)
;;                   (cterm (ag^) 
;;                   (AndRMR (cterm () Real x0)
;;                     (cterm (ag^0) 
;;                     (AndRMR (cterm () abs x0<<=1)
;;                       (cterm (ag^1) 
;;                       (AndLMR (cterm (ag^2) CoGMR x0 ag^2)
;;                         (cterm () y===(1#2)*(x0+IntN 1)* ~d andnc x===y))
;;                       ag^1))
;;                     ag^0))
;;                   ag^))
;;                 bg^2))
;;               bg^1))
;;             bg^0))
;;           bg^)
;;    (cterm (ah^) 
;;    (ExRTMR rea
;;      ah
;;      (cterm (x0,ah^0) 
;;      (ExRTMR rea
;;        ah
;;        (cterm (y,ah^1) 
;;        (AndRMR (cterm () Real x0)
;;          (cterm (ah^2) 
;;          (AndRMR (cterm () abs x0<<=1)
;;            (cterm (ah^3) 
;;            (AndLMR (cterm (ah^4) CoHMR x0 ah^4)
;;              (cterm () y===(1#2)*x0 andnc x===y))
;;            ah^3))
;;          ah^2))
;;        ah^1))
;;      ah^0))
;;    ah^))
;;  bgh^ -> 
;;  CoGMR x(cCoGClauseInv bgh^))

;; with computation rule

;; cCoGClauseInv eqd
;; ([bgh]
;;   (CoRec boole yprod ag ysum ah=>ag boole yprod ag ysum ah=>ah)bgh
;;   ([bgh0]
;;     [if bgh0
;;       ([bg]
;;        (InL (boole yprod(ag ysum boole yprod ag ysum ah))
;; 	    (ah ysum boole yprod ag ysum ah))
;;        (clft bg pair(InL ag (boole yprod ag ysum ah))crht bg))
;;       ([ah]
;;        (InR (ah ysum boole yprod ag ysum ah)
;; 	    (boole yprod(ag ysum boole yprod ag ysum ah)))
;;        ((InL ah (boole yprod ag ysum ah))ah))])
;;   ([bgh0]
;;     [if bgh0
;;       ([bg]
;;        (InL (boole yprod(ag ysum boole yprod ag ysum ah))
;; 	    (ah ysum boole yprod ag ysum ah))
;;        (clft bg pair(InL ag (boole yprod ag ysum ah))crht bg))
;;       ([ah]
;;        (InR (ah ysum boole yprod ag ysum ah)
;; 	    (boole yprod(ag ysum boole yprod ag ysum ah)))
;;        ((InL ah (boole yprod ag ysum ah))ah))]))

;; (ppc "cCoGClauseInv0CompRule")

;; cCoGClauseInv eqd
;; ([bgh]
;;   (CoRec boole yprod ag ysum ah=>ag boole yprod ag ysum ah=>ah)bgh
;;   ([bgh0]
;;     [case bgh0
;;       (InL bg -> InL(clft bg pair InL crht bg))
;;       (InR ah -> InR(InL ah))])
;;   ([bgh0]
;;     [case bgh0
;;       (InL bg -> InL(clft bg pair InL crht bg))
;;       (InR ah -> InR(InL ah))]))

(deanimate "CoGClauseInv")

;; CoHClauseInv
(set-goal "allnc x(
 exr d,x0,y(
  Psd d andd Real x0 andi abs x0<<=1 andr CoG x0 andl
  y===(1#2)*(x0+1)*d andnc x===y) ord 
 exr x0,y(Real x0 andi abs x0<<=1 andr CoH x0 andl
 y===(1#2)*x0 andnc x===y) ->  CoH x)")
(assume "x" "Disj")
(coind
 "Disj"
 (pf "exr d,x0,y(Psd d andd Real x0 andi abs x0<<=1 andr
  CoG x0 andl y===(1#2)*(x0+IntN 1)* ~d andnc x===y) ord 
 exr x0,y(Real x0 andi abs x0<<=1 andr CoH x0 andl
 y===(1#2)*x0 andnc x===y) -> CoG x"))
;; 3,4
(drop "Disj")
(assume "x1" "x1Prop")
(elim "x1Prop")
;; 7,8
(drop "x1Prop")
;; LR initial case
(assume "ExHypLR")
(by-assume "ExHypLR" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(by-assume "dx2Prop" "y2" "dx2y2Prop")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x2"))
(intro 0 (pt "y2"))
(split)
(use "dx2y2Prop")
(split)
(use "dx2y2Prop")
(split)
(use "dx2y2Prop")
(split)
(intro 0)
(use "dx2y2Prop")
(use "dx2y2Prop")
;; 8
(drop "x1Prop")
;; generating case
(assume "ExHypU")
(by-assume "ExHypU" "x2" "x2Prop")
(by-assume "x2Prop" "y2" "x2y2Prop")
(intro 1)
(intro 0 (pt "x2"))
(intro 0 (pt "y2"))
(split)
(use "x2y2Prop")
(split)
(use "x2y2Prop")
(split)
(intro 0)
(use "x2y2Prop")
(use "x2y2Prop")
;; 4
(drop "Disj")
(assume "x1" "x1Prop")
(elim "x1Prop")
;; 53,54
(drop "x1Prop")
;; LR
(assume "ExHypLR")
(by-assume "ExHypLR" "d" "dProp")
(by-assume "dProp" "x2" "x2dProp")
(by-assume "x2dProp" "y2" "x2dy2Prop")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x2"))
(intro 0 (pt "y2"))
(split)
(use "x2dy2Prop")
(split)
(use "x2dy2Prop")
(split)
(use "x2dy2Prop")
(split)
(intro 0)
(use "x2dy2Prop")
(use "x2dy2Prop")
;; 54
(drop "x1Prop")
;; Mid
(assume "ExHypD")
(by-assume "ExHypD" "x2" "x2Prop")
(by-assume "x2Prop" "y2" "x2y2Prop")
(intro 1)
(intro 0 (pt "x2"))
(intro 0 (pt "y2"))
(split)
(use "x2y2Prop")
(split)
(use "x2y2Prop")
(split)
(intro 0)
(use "x2y2Prop")
(use "x2y2Prop")
;; Proof finished.
;; (cdp)
(save "CoHClauseInv")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [bgh]
;;  (CoRec boole yprod ag ysum ah=>ah boole yprod ag ysum ah=>ag)bgh
;;  ([bgh0]
;;    [case bgh0
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah -> InR(InL ah))])
;;  ([bgh0]
;;    [case bgh0
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah -> InR(InL ah))])

(add-sound "CoHClauseInv")

;; ok, CoHClauseInvSound has been added as a new theorem:

;; allnc x,bgh^(
;;  (OrDMR (cterm (bg^) 
;;           (ExRTMR int
;;             boole yprod ag
;;             (cterm (d,bg^0) 
;;             (ExRTMR rea
;;               boole yprod ag
;;               (cterm (x0,bg^1) 
;;               (ExRTMR rea
;;                 boole yprod ag
;;                 (cterm (y,bg^2) 
;;                 (AndDMR (cterm (boole^) PsdMR d boole^)
;;                   (cterm (ag^) 
;;                   (AndRMR (cterm () Real x0)
;;                     (cterm (ag^0) 
;;                     (AndRMR (cterm () abs x0<<=1)
;;                       (cterm (ag^1) 
;;                       (AndLMR (cterm (ag^2) CoGMR x0 ag^2)
;;                         (cterm () y===(1#2)*(x0+1)*d andnc x===y))
;;                       ag^1))
;;                     ag^0))
;;                   ag^))
;;                 bg^2))
;;               bg^1))
;;             bg^0))
;;           bg^)
;;    (cterm (ah^) 
;;    (ExRTMR rea
;;      ah
;;      (cterm (x0,ah^0) 
;;      (ExRTMR rea
;;        ah
;;        (cterm (y,ah^1) 
;;        (AndRMR (cterm () Real x0)
;;          (cterm (ah^2) 
;;          (AndRMR (cterm () abs x0<<=1)
;;            (cterm (ah^3) 
;;            (AndLMR (cterm (ah^4) CoHMR x0 ah^4)
;;              (cterm () y===(1#2)*x0 andnc x===y))
;;            ah^3))
;;          ah^2))
;;        ah^1))
;;      ah^0))
;;    ah^))
;;  bgh^ -> 
;;  CoHMR x(cCoHClauseInv bgh^))

;; with computation rule

;; cCoHClauseInv eqd
;; ([bgh]
;;   (CoRec boole yprod ag ysum ah=>ah boole yprod ag ysum ah=>ag)bgh
;;   ([bgh0]
;;     [if bgh0
;;       ([bg]
;;        (InL (boole yprod(ag ysum boole yprod ag ysum ah))
;; 	    (ah ysum boole yprod ag ysum ah))
;;        (clft bg pair(InL ag (boole yprod ag ysum ah))crht bg))
;;       ([ah]
;;        (InR (ah ysum boole yprod ag ysum ah)
;; 	    (boole yprod(ag ysum boole yprod ag ysum ah)))
;;        ((InL ah (boole yprod ag ysum ah))ah))])
;;   ([bgh0]
;;     [if bgh0
;;       ([bg]
;;        (InL (boole yprod(ag ysum boole yprod ag ysum ah))
;; 	    (ah ysum boole yprod ag ysum ah))
;;        (clft bg pair(InL ag (boole yprod ag ysum ah))crht bg))
;;       ([ah]
;;        (InR (ah ysum boole yprod ag ysum ah)
;; 	    (boole yprod(ag ysum boole yprod ag ysum ah)))
;;        ((InL ah (boole yprod ag ysum ah))ah))]))

;; (ppc "cCoHClauseInv0CompRule")

;; cCoHClauseInv eqd
;; ([bgh]
;;   (CoRec boole yprod ag ysum ah=>ah boole yprod ag ysum ah=>ag)bgh
;;   ([bgh0]
;;     [case bgh0
;;       (InL bg -> InL(clft bg pair InL crht bg))
;;       (InR ah -> InR(InL ah))])
;;   ([bgh0]
;;     [case bgh0
;;       (InL bg -> InL(clft bg pair InL crht bg))
;;       (InR ah -> InR(InL ah))]))

(deanimate "CoHClauseInv")

;; CoGCompat
(set-goal "allnc x,y(x===y -> CoG x -> CoG y)")
(assume "x" "y" "x===y" "CoGx")
(inst-with-to "CoGClause" (pt "x") "CoGx" "CoGClauseInst")
(elim "CoGClauseInst")
(drop "CoGClauseInst")
;; LR case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y1" "dx1y1Prop")
(use "CoGClauseInv")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(intro 0 (pt "y1"))
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(use "RealEqTrans" (pt "x"))
(use "RealEqSym")
(use "x===y")
(use "dx1y1Prop")
(drop "CoGClauseInst")
;; U case
(assume "ExHyp")
(use "CoGClauseInv")
(intro 1)
(by-assume "ExHyp" "x1" "x1Prop")
(by-assume "x1Prop" "y1" "x1y1Prop")
(intro 0 (pt "x1"))
(intro 0 (pt "y1"))
(split)
(use "x1y1Prop")
(split)
(use "x1y1Prop")
(split)
(use "x1y1Prop")
(split)
(use "x1y1Prop")
(use "RealEqTrans" (pt "x"))
(use "RealEqSym")
(use "x===y")
(use "x1y1Prop")
;; Proof finished.
;; (cdp)
(save "CoGCompat")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ag]
;;  [case (DesYprod ag)
;;    (InL bg -> cCoGClauseInv(InL bg))
;;    (InR ah -> cCoGClauseInv(InR ah))]

(animate "CoGClauseInv")

(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ag]
;;  [case (DesYprod ag)
;;    (InL bg -> 
;;    (CoRec boole yprod ag ysum ah=>ag boole yprod ag ysum ah=>ah)(InL bg)
;;    ([bgh]
;;      [case bgh
;;        (InL bg0 -> InL(clft bg0 pair InL crht bg0))
;;        (InR ah -> InR(InL ah))])
;;    ([bgh]
;;      [case bgh
;;        (InL bg0 -> InL(clft bg0 pair InL crht bg0))
;;        (InR ah -> InR(InL ah))]))
;;    (InR ah -> 
;;    (CoRec boole yprod ag ysum ah=>ag boole yprod ag ysum ah=>ah)(InR ah)
;;    ([bgh]
;;      [case bgh
;;        (InL bg -> InL(clft bg pair InL crht bg))
;;        (InR ah0 -> InR(InL ah0))])
;;    ([bgh]
;;      [case bgh
;;        (InL bg -> InL(clft bg pair InL crht bg))
;;        (InR ah0 -> InR(InL ah0))]))]

(define nneterm (rename-variables (nt (undelay-delayed-corec neterm 1))))
;; (pp (rename-variables nneterm))

;; [ag][if (DesYprod ag) ([bg]LR clft bg crht bg) U]

;; (ppc (rename-variables nneterm))

;; [ag][case (DesYprod ag) (InL bg -> LR clft bg crht bg) (InR ah -> U ah)]

;; This is the identity on CoG

(deanimate "CoGClauseInv")

(add-sound "CoGCompat")

;; ok, CoGCompatSound has been added as a new theorem:

;; allnc x,y(x===y -> allnc ag^(CoGMR x ag^ -> CoGMR y(cCoGCompat ag^)))

;; with computation rule

;; cCoGCompat eqd
;; ([ag]
;;   [if (DesYprod ag)
;;     ([bg]cCoGClauseInv((InL (boole yprod ag) ah)bg))
;;     ([ah]cCoGClauseInv((InR ah (boole yprod ag))ah))])

;; (ppc "cCoGCompat0CompRule")

;; cCoGCompat eqd
;; ([ag]
;;   [case (DesYprod ag)
;;     (InL bg -> cCoGClauseInv(InL bg))
;;     (InR ah -> cCoGClauseInv(InR ah))])

(deanimate "CoGCompat")

;; CoHCompat
(set-goal "allnc x,y(x===y -> CoH x -> CoH y)")
(assume "x" "y" "x=y" "CoHx")
(inst-with-to "CoHClause" (pt "x") "CoHx" "CoHClauseInst")
(elim "CoHClauseInst")
(drop "CoHClauseInst")
;; LR case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y1" "dx1y1Prop")
(use "CoHClauseInv")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(intro 0 (pt "y1"))
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(split)
(use "dx1y1Prop")
(use "RealEqTrans" (pt "x"))
(use "RealEqSym")
(use "x=y")
(use "dx1y1Prop")
(drop "CoHClauseInst")
;; U case
(assume "ExHyp")
(use "CoHClauseInv")
(intro 1)
(by-assume "ExHyp" "x1" "x1Prop")
(by-assume "x1Prop" "y1" "x1y1Prop")
(intro 0 (pt "x1"))
(intro 0 (pt "y1"))
(split)
(use "x1y1Prop")
(split)
(use "x1y1Prop")
(split)
(use "x1y1Prop")
(split)
(use "x1y1Prop")
(use "RealEqTrans" (pt "x"))
(use "RealEqSym")
(use "x=y")
(use "x1y1Prop")
;; Proof finished.
;; (cdp)
(save "CoHCompat")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ah]
;;  [case (DesYprod ah)
;;    (InL bg -> cCoHClauseInv(InL bg))
;;    (InR ah0 -> cCoHClauseInv(InR ah0))]

(animate "CoHClauseInv")

(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ah]
;;  [case (DesYprod ah)
;;    (InL bg -> 
;;    (CoRec boole yprod ag ysum ah=>ah boole yprod ag ysum ah=>ag)(InL bg)
;;    ([bgh]
;;      [case bgh
;;        (InL bg0 -> InL(clft bg0 pair InL crht bg0))
;;        (InR ah0 -> InR(InL ah0))])
;;    ([bgh]
;;      [case bgh
;;        (InL bg0 -> InL(clft bg0 pair InL crht bg0))
;;        (InR ah0 -> InR(InL ah0))]))
;;    (InR ah0 -> 
;;    (CoRec boole yprod ag ysum ah=>ah boole yprod ag ysum ah=>ag)(InR ah0)
;;    ([bgh]
;;      [case bgh
;;        (InL bg -> InL(clft bg pair InL crht bg))
;;        (InR ah1 -> InR(InL ah1))])
;;    ([bgh]
;;      [case bgh
;;        (InL bg -> InL(clft bg pair InL crht bg))
;;        (InR ah1 -> InR(InL ah1))]))]

(define nneterm (rename-variables (nt (undelay-delayed-corec neterm 1))))
;; (pp (rename-variables nneterm))

;; [ah][if (DesYprod ah) ([bg]Fin clft bg crht bg) D]

;; (ppc (rename-variables nneterm))

;; [ah][case (DesYprod ah) (InL bg -> Fin clft bg crht bg) (InR ah -> D ah)]

;; This is the identity on CoH

(deanimate "CoHClauseInv")

(add-sound "CoHCompat")

;; ok, CoHCompatSound has been added as a new theorem:

;; allnc x,y(x===y -> allnc ah^(CoHMR x ah^ -> CoHMR y(cCoHCompat ah^)))

;; with computation rule

;; cCoHCompat eqd
;; ([ah]
;;   [if (DesYprod ah)
;;     ([bg]cCoHClauseInv((InL (boole yprod ag) ah)bg))
;;     ([ah0]cCoHClauseInv((InR ah (boole yprod ag))ah0))])

;; (ppc "cCoHCompat0CompRule")

;; cCoHCompat eqd
;; ([ah]
;;   [case (DesYprod ah)
;;     (InL bg -> cCoHClauseInv(InL bg))
;;     (InR ah0 -> cCoHClauseInv(InR ah0))])

(deanimate "CoHCompat")

;; CoGToReal
(set-goal "all x(CoG x -> Real x)")
(assume "x" "CoGx")
(inst-with-to "CoGClause" (pt "x") "CoGx" "CoGClauseInst")
(elim "CoGClauseInst")
(drop "CoGClauseInst")
;; LR case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(use "RealEqElim0" (pt "y"))
(use "dx1yProp")
;; U case
(drop "CoGClauseInst")
(assume "ExHyp")
(by-assume "ExHyp" "x1" "x1Prop")
(by-assume "x1Prop" "y" "x1yProp")
(use "RealEqElim0" (pt "y"))
(use "x1yProp")
;; Proof finished.
;; (cdp)
(save "CoGToReal")

;; CoHToReal
(set-goal "all x(CoH x -> Real x)")
(assume "x" "CoHx")
(inst-with-to "CoHClause" (pt "x") "CoHx" "CoHClauseInst")
(elim "CoHClauseInst")
(drop "CoHClauseInst")
;; LR case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(use "RealEqElim0" (pt "y"))
(use "dx1yProp")
;; U case
(drop "CoHClauseInst")
(assume "ExHyp")
(by-assume "ExHyp" "x1" "x1Prop")
(by-assume "x1Prop" "y" "x1yProp")
(use "RealEqElim0" (pt "y"))
(use "x1yProp")
;; Proof finished.
;; (cdp)
(save "CoHToReal")

;; CoGToBd
(set-goal "all x(CoG x -> abs x<<=1)")
(assume "x" "CoGx")
(inst-with-to "CoGClause" (pt "x") "CoGx" "CoGClauseInst")
(elim "CoGClauseInst")
;; 5,6
(drop "CoGClauseInst")
;; LR case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(simpreal "dx1yProp")
(simpreal "dx1yProp")
(assert "Real x1")
(use "dx1yProp")
(assume "Rx1")
(simpreal "RealAbsTimes")
(simpreal "RealAbsTimes")
(simpreal (pf "RealConstr([n](1#1))([p]Zero)===
               abs(RealConstr([n](1#2))([p]Zero))*
               abs(RealConstr([n](1#1))([p]Zero)+1)*
               abs(RealConstr([n]~d)([p]Zero))"))
(use "RealLeMonTimesTwo")
(simpreal "<-" "RealAbsTimes")
(use "RealNNegAbs")
(autoreal)
(use "RealNNegAbs")
(use "RealRat")
(use "RealLeMonTimesTwo")
(use "RealNNegAbs")
(use "RealRat")
(use "RealNNegAbs")
(autoreal)
(use "RealLeRefl")
(use "RealRat")
;; ?^43:abs(x1+IntN 1)<<=abs(RealPlus 1 1) from abs x1<<=1
(use "RealLeTrans" (pt "abs x1+abs(RealConstr([n](IntN 1#1))([p]Zero))"))
(use "RealLeAbsPlus")
(use "Rx1")
(use "RealRat")
(use "RealLeTrans" (pt "RealConstr([n](1#1))([p]Zero)+1"))
(use "RealLeMonPlus")
(use "dx1yProp")
(ng #t)
(use "RealLeRefl")
(use "RealRat")
(use "RealLeAbsId")
(autoreal)
(use "RealLeRefl")
(autoreal)
;; ?^30:1===abs(1#2)*abs(RealPlus 1 1)*abs~d
(ng #t)
(use "RealSeqEqToEq" (pt "Zero"))
(use "RealRat")
(autoreal)
(assume "n" "Useless")
(ng #t)
(simp "PsdToAbsOne")
(use "Truth")
(use "dx1yProp")
(autoreal)
;; ?^6:exr x0,y(
;;      Real x0 andr abs x0<<=1 andr CoH x0 andl y===(1#2)*x0 andnc x===y) -> 
;;     abs x<<=1
(drop "CoGClauseInst")
;; U case
(assume "ExHyp")
(by-assume "ExHyp" "x1" "x1Prop")
(by-assume "x1Prop" "y" "x1yProp")
(simpreal "x1yProp")
(simpreal "x1yProp")
(assert "Real x1")
(use "x1yProp")
(assume "Rx1")
(simpreal "RealAbsTimes")
(simpreal (pf "RealConstr([n](1#1))([p]Zero)===
               abs(RealConstr([n](1#2))([p]Zero))*
               abs(RealConstr([n](1#1))([p]Zero)+1)"))
(use "RealLeMonTimesTwo")
(use "RealNNegAbs")
(use "RealRat")
(use "RealNNegAbs")
(use "Rx1")
(use "RealLeRefl")
(autoreal)
(use "RealLeTrans" (pt "RealConstr([n](1#1))([p]Zero)"))
(use "x1yProp")
(ng #t)
(use "RatLeToRealLe")
(use "Truth")
(ng #t)
(use "RealEqRefl")
(use "RealRat")
(use "Rx1")
(use "RealRat")
;; Proof finished.
;; (cdp)
(save "CoGToBd")

;; (ppn "RealLeAbsPlus")
;; (ppn (goal-to-formula (current-goal)))

;; CoHToBd
(set-goal "all x(CoH x -> abs x<<=1)")
(assume "x" "CoHx")
(inst-with-to "CoHClause" (pt "x") "CoHx" "CoHClauseInst")
(elim "CoHClauseInst")
;; 5,6
(drop "CoHClauseInst")
;; LR case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(simpreal "dx1yProp")
(simpreal "dx1yProp")
(assert "Real x1")
 (use "dx1yProp")
(assume "Rx1")
(simpreal "RealAbsTimes")
(simpreal "RealAbsTimes")
(use "RealLeTrans" (pt "abs(RealConstr([n](1#2))([p]Zero))*
                        abs(RealConstr([n](1#1))([p]Zero)+1)*
                        abs(RealConstr([n](d#1))([p]Zero))"))
(use "RealLeMonTimesL")
(use "RealNNegAbs")
(use "RealRat")
(use "RealLeMonTimes")
(use "RealNNegAbs")
(use "RealRat")
;; ?^35:abs(x1+1)<<=abs(RealPlus 1 1) from abs x1<<=1
(use "RealLeTrans" (pt "abs x1+abs(RealConstr([n](1#1))([p]Zero))"))
(use "RealLeAbsPlus")
(use "Rx1")
(use "RealRat")
(use "RealLeTrans" (pt "RealConstr([n](1#1))([p]Zero)+1"))
(use "RealLeMonPlus")
(use "dx1yProp")
(ng #t)
(use "RealLeRefl")
(use "RealRat")
(use "RealLeAbsId")
(autoreal)
(ng #t)
(simp "PsdToAbsOne")
(use "RealLeRefl")
(use "RealRat")
(use "dx1yProp")
(autoreal)
;; ?^6:exr x0,y(
;;      Real x0 andr abs x0<<=1 andr CoH x0 andl y===(1#2)*x0 andnc x===y) -> 
;;     abs x<<=1
(drop "CoHClauseInst")
;; U case
(assume "ExHyp")
(by-assume "ExHyp" "x1" "x1Prop")
(by-assume "x1Prop" "y" "x1yProp")
(simpreal "x1yProp")
(simpreal "x1yProp")
(assert "Real x1")
 (use "x1yProp")
(assume "Rx1")
(simpreal "RealAbsTimes")
(simpreal (pf "RealConstr([n](1#1))([p]Zero)===
               abs(RealConstr([n](1#2))([p]Zero))*
               abs(RealConstr([n](1#1))([p]Zero)+1)"))
(use "RealLeMonTimesTwo")
(use "RealNNegAbs")
(use "RealRat")
(use "RealNNegAbs")
(use "Rx1")
(use "RealLeRefl")
(autoreal)
(use "RealLeTrans" (pt "RealConstr([n](1#1))([p]Zero)"))
(use "x1yProp")
(ng #t)
(use "RatLeToRealLe")
(use "Truth")
(ng #t)
(use "RealEqRefl")
(use "RealRat")
(use "Rx1")
(use "RealRat")
;; Proof finished.
;; (cdp)
(save "CoHToBd")

;; We provide a simplified variant of CoGClause.

;; CoGClosure
(set-goal "allnc x(CoG x ->
 exr d,x1(Psd d andd CoG x1 andl x===(1#2)*(x1+IntN 1)* ~d) ord 
 exr x1(CoH x1 andl x===(1#2)*x1))")
(assume "x" "CoGx")
(inst-with-to "CoGClause" (pt "x") "CoGx" "CoGClauseInst")
(elim "CoGClauseInst")
(drop "CoGClauseInst")
;; LRCase
(assume "ExHyp")
(intro 0)
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(split)
(use "dx1yProp")
(split)
(use "dx1yProp")
(use "RealEqTrans" (pt "y"))
(use "dx1yProp")
(use "dx1yProp")
;; U Case
(drop "CoGClauseInst")
(assume "ExHyp")
(intro 1)
(by-assume "ExHyp" "x1" "x1Prop")
(by-assume "x1Prop" "y" "x1yProp")
(intro 0 (pt "x1"))
(split)
(use "x1yProp")
(use "RealEqTrans" (pt "y"))
(use "x1yProp")
(use "x1yProp")
;; Proof finished.
;; (cdp)
(save "CoGClosure")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ag][case (DesYprod ag) (InL bg -> InL bg) (InR ah -> InR ah)]

;; (pp neterm)

;; [ag][if (DesYprod ag) (InL (boole yprod ag) ah) (InR ah (boole yprod ag))]

;; (pp (term-to-type (pt "(InL (boole yprod ag) ah)")))
;; boole yprod ag=>boole yprod ag ysum ah
;; (pp (term-to-type (pt "(InR ah (boole yprod ag))")))
;; ah=>boole yprod ag ysum ah

;; Need animation of Lft Rht for (add-sound "CoGClosure")
(animate "Lft")
(animate "Rht")

(add-sound "CoGClosure")

;; ok, CoGClosureSound has been added as a new theorem:

;; allnc x,ag^(
;;  CoGMR x ag^ -> 
;;  (OrDMR (cterm (bg^) 
;;           (ExRTMR int
;;             boole yprod ag
;;             (cterm (d,bg^0) 
;;             (ExRTMR rea
;;               boole yprod ag
;;               (cterm (x0,bg^1) 
;;               (AndDMR (cterm (boole^0) PsdMR d boole^0)
;;                 (cterm (ag^0) 
;;                 (AndLMR (cterm (ag^1) CoGMR x0 ag^1)
;;                   (cterm () x===(1#2)*(x0+IntN 1)* ~d))
;;                 ag^0))
;;               bg^1))
;;             bg^0))
;;           bg^)
;;    (cterm (ah^0) 
;;    (ExRTMR rea
;;      ah
;;      (cterm (x0,ah^1) 
;;      (AndLMR (cterm (ah^2) CoHMR x0 ah^2) (cterm () x===(1#2)*x0))ah^1))
;;    ah^0))
;;  (cCoGClosure ag^))

;; with computation rule

;; cCoGClosure eqd
;; ([ag]
;;   [if (DesYprod ag)
;;     ([bg]
;;      (InL (boole yprod ag) ah)
;;      ([if bg ([boole,ag0]boole)]pair[if bg ([boole,ag0]ag0)]))
;;     (InR ah (boole yprod ag))])

(deanimate "CoGClosure")
(deanimate "Lft")
(deanimate "Rht")

;; CoHClosure
(set-goal "allnc x(CoH x ->
 exr d,x1(Psd d andd CoG x1 andl x===(1#2)*(x1+1)*d) ord 
 exr x1(CoH x1 andl x===(1#2)*x1))")
(assume "x" "CoHx")
(inst-with-to "CoHClause" (pt "x") "CoHx" "CoHClauseInst")
(elim "CoHClauseInst")
(drop "CoHClauseInst")
;; LRCase
(assume "ExHyp")
(intro 0)
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(by-assume "dx1Prop" "y" "dx1yProp")
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(split)
(use "dx1yProp")
(split)
(use "dx1yProp")
(use "RealEqTrans" (pt "y"))
(use "dx1yProp")
(use "dx1yProp")
;; U Case
(drop "CoHClauseInst")
(assume "ExHyp")
(intro 1)
(by-assume "ExHyp" "x1" "x1Prop")
(by-assume "x1Prop" "y" "x1yProp")
(intro 0 (pt "x1"))
(split)
(use "x1yProp")
(use "RealEqTrans" (pt "y"))
(use "x1yProp")
(use "x1yProp")
;; Proof finished.
;; (cdp)
(save "CoHClosure")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ah][case (DesYprod ah) (InL bg -> InL bg) (InR ah -> InR ah)]

;; (pp neterm)

;; [ah][if (DesYprod ah) (InL (boole yprod ag) ah) (InR ah (boole yprod ag))]

;; (pp (term-to-type (pt "(InL (boole yprod ag) ah)")))
;; boole yprod ag=>boole yprod ag ysum ah
;; (pp (term-to-type (pt "(InR ah (boole yprod ag))")))
;; ah=>boole yprod ag ysum ah

;; Need animation of Lft Rht for (add-sound "CoHClosure")
(animate "Lft")
(animate "Rht")

(add-sound "CoHClosure")

;; ok, CoHClosureSound has been added as a new theorem:

;; allnc x,ah^(
;;  CoHMR x ah^ -> 
;;  (OrDMR (cterm (bg^) 
;;           (ExRTMR int
;;             boole yprod ag
;;             (cterm (d,bg^0) 
;;             (ExRTMR rea
;;               boole yprod ag
;;               (cterm (x0,bg^1) 
;;               (AndDMR (cterm (boole^0) PsdMR d boole^0)
;;                 (cterm (ag^0) 
;;                 (AndLMR (cterm (ag^1) CoGMR x0 ag^1)
;;                   (cterm () x===(1#2)*(x0+1)*d))
;;                 ag^0))
;;               bg^1))
;;             bg^0))
;;           bg^)
;;    (cterm (ah^0) 
;;    (ExRTMR rea
;;      ah
;;      (cterm (x0,ah^1) 
;;      (AndLMR (cterm (ah^2) CoHMR x0 ah^2) (cterm () x===(1#2)*x0))ah^1))
;;    ah^0))
;;  (cCoHClosure ah^))

;; with computation rule

;; cCoHClosure eqd
;; ([ah]
;;   [if (DesYprod ah)
;;     ([bg]
;;      (InL (boole yprod ag) ah)
;;      ([if bg ([boole,ag]boole)]pair[if bg ([boole,ag]ag)]))
;;     (InR ah (boole yprod ag))])

;; (cp "CoHClosureSound")

(deanimate "CoHClosure")
(deanimate "Lft")
(deanimate "Rht")

;; CoGLr
(set-goal "allnc d,x(Psd d -> CoG x -> CoG((1#2)*(x+IntN 1)* ~d))")
(assume "d" "x" "Psdd" "CoGx")
(use "CoGClauseInv")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x"))
(intro 0 (pt "(1#2)*(x+IntN 1)* ~d"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
(use "CoGToBd")
(use "CoGx")
(split)
(use "CoGx")
(split)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGLr")

(define eterm (proof-to-extracted-term))
(animate "CoGClauseInv")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [boole,ag](CoRec boole yprod ag ysum ah=>ag boole yprod ag ysum ah=>ah)
;;  (InL(boole pair ag))
;;  ([bgh][case bgh
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah -> InR(InL ah))])
;;  ([bgh][case bgh
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah -> InR(InL ah))])

(deanimate "CoGClauseInv")

(add-sound "CoGLr")

;; ok, CoGLrSound has been added as a new theorem:

;; allnc d,x,boole^(
;;  PsdMR d boole^ -> 
;;  allnc ag^0(CoGMR x ag^0 -> CoGMR((1#2)*(x+IntN 1)* ~d)(cCoGLr boole^ ag^0)))

;; with computation rule

;; cCoGLr eqd
;; ([boole,ag]cCoGClauseInv((InL (boole yprod ag) ah)(boole pair ag)))

(deanimate "CoGLr")

;; CoGU
(set-goal "allnc x(CoH x -> CoG((1#2)*x))")
(assume "x" "CoHx")
(use "CoGClauseInv")
(intro 1)
(intro 0 (pt "x"))
(intro 0 (pt "(1#2)*x"))
(split)
(autoreal)
(split)
(use "CoHToBd")
(use "CoHx")
(split)
(use "CoHx")
(split)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGU")

(define eterm (proof-to-extracted-term))
(animate "CoGClauseInv")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ah](CoRec boole yprod ag ysum ah=>ag boole yprod ag ysum ah=>ah)(InR ah)
;;  ([bgh][case bgh
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah0 -> InR(InL ah0))])
;;  ([bgh][case bgh
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah0 -> InR(InL ah0))])

(deanimate "CoGClauseInv")

(add-sound "CoGU")

;; ok, CoGUSound has been added as a new theorem:

;; allnc x,ah^(CoHMR x ah^ -> CoGMR((1#2)*x)(cCoGU ah^))

;; with computation rule

;; cCoGU eqd([ah]cCoGClauseInv((InR ah (boole yprod ag))ah))

(deanimate "CoGU")

;; CoHLr
(set-goal "allnc d,x(Psd d -> CoG x -> CoH((1#2)*(x+1)*d))")
(assume "d" "x" "Psdd" "CoGx")
(use "CoHClauseInv")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x"))
(intro 0 (pt "(1#2)*(x+1)*d"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
(use "CoGToBd")
(use "CoGx")
(split)
(use "CoGx")
(split)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoHLr")

(define eterm (proof-to-extracted-term))
(animate "CoHClauseInv")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [boole,ag](CoRec boole yprod ag ysum ah=>ah boole yprod ag ysum ah=>ag)
;;  (InL(boole pair ag))
;;  ([bgh][case bgh
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah -> InR(InL ah))])
;;  ([bgh][case bgh
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah -> InR(InL ah))])

(deanimate "CoHClauseInv")

(add-sound "CoHLr")

;; ok, CoHLrSound has been added as a new theorem:

;; allnc d,x,boole^(
;;  PsdMR d boole^ -> 
;;  allnc ag^0(CoGMR x ag^0 -> CoHMR((1#2)*(x+1)*d)(cCoHLr boole^ ag^0)))

;; with computation rule

;; cCoHLr eqd
;; ([boole,ag]cCoHClauseInv((InL (boole yprod ag) ah)(boole pair ag)))

(deanimate "CoHLr")

;; CoHU
(set-goal "allnc x(CoH x -> CoH((1#2)*x))")
(assume "x" "CoHx")
(use "CoHClauseInv")
(intro 1)
(intro 0 (pt "x"))
(intro 0 (pt "(1#2)*x"))
(split)
(autoreal)
(split)
(use "CoHToBd")
(use "CoHx")
(split)
(use "CoHx")
(split)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoHU")

(define eterm (proof-to-extracted-term))
(animate "CoHClauseInv")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ah](CoRec boole yprod ag ysum ah=>ah boole yprod ag ysum ah=>ag)(InR ah)
;;  ([bgh][case bgh
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah0 -> InR(InL ah0))])
;;  ([bgh][case bgh
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah0 -> InR(InL ah0))])

(deanimate "CoHClauseInv")

(add-sound "CoHU")

;; ok, CoHUSound has been added as a new theorem:

;; allnc x,ah^(CoHMR x ah^ -> CoHMR((1#2)*x)(cCoHU ah^))

;; with computation rule

;; cCoHU eqd([ah]cCoHClauseInv((InR ah (boole yprod ag))ah))

(deanimate "CoHU")

;; For CoGUMinus we use the fact that our coinductive definitions are
;; in strengthened form.

;; CoGUMinus
(set-goal "allnc x(CoG(~x) -> CoG x)")
(assume "x" "CoG-x")
(coind "CoG-x" (pf "CoH(~x) -> CoH x"))
(assume "x1" "CoG-x1")
(inst-with-to "CoGClosure" (pt "~x1") "CoG-x1" "Disj")
(elim "Disj")
(drop "Disj")
;; LR generating case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(elim "dx2Prop")
(drop "dx2Prop")
(assume "Psdd" "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoGx2" "EqHyp")
(intro 0)
(intro 0 (pt "~d"))
(intro 0 (pt "x2"))
(intro 0 (pt "x1"))
(split)
(use "PsdUMinus")
(use "Psdd")
(split)
(autoreal)
(split)
(use "CoGToBd")
(use "CoGx2")
(split)
(intro 0)
(use "CoGx2")
(split)
;; ?^39:x1===(1#2)*(x2+IntN 1)* ~ ~d
(use "RealEqTrans" (pt "~ ~x1"))
(use "RealEqSym")
(use "RealUMinusUMinus")
(use "RealUMinusRealInv")
(autoreal)
(use "RealEqTrans" (pt "~((1#2)*(x2+IntN 1)* ~d)"))
(use "RealUMinusCompat")
(use "EqHyp")
(use "RealEqSym")
(use "RealTimesIdRatUMinus")
(autoreal)
(use "RealEqRefl")
(use "RealUMinusRealInv")
(autoreal)
;; 9
;; U case
(drop "Disj")
(assume "ExHyp")
(by-assume "ExHyp" "x2" "x2Prop")
(elim "x2Prop")
(drop "x2Prop")
(assume "CoHx2" "EqHyp")
(intro 1)
(intro 0 (pt "~x2"))
(intro 0 (pt "x1"))
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "CoHToBd")
(use "CoHx2")
(autoreal)
(split)
(intro 1)
;; ?_73:CoH(~ ~x2)
(use "CoHCompat" (pt "x2"))
(use "RealEqSym")
(use "RealUMinusUMinus")
(autoreal)
(use "CoHx2")
(split)
;; ?^78:x1===(1#2)* ~x2
(use "RealEqTrans" (pt "~ ~x1"))
(use "RealEqSym")
(use "RealUMinusUMinus")
(use "RealUMinusRealInv")
(autoreal)
(simpreal "EqHyp")
(use "RealEqSym")
(use "RealTimesIdUMinus")
(use "RealRat")
(autoreal)
(use "RealEqRefl")
(use "RealUMinusRealInv")
(autoreal)
;; 4
(assume "x1" "CoH-x1")
(inst-with-to "CoHClosure" (pt "~x1") "CoH-x1" "Disj")
(elim "Disj")
;; 94,95
(drop "Disj")
;; LR case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(elim "dx2Prop")
(drop "dx2Prop")
(assume "Psdd" "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoGx2" "EqHyp")
(intro 0)
(intro 0 (pt "~d"))
(intro 0 (pt "x2"))
(intro 0 (pt "x1"))
(split)
(use "PsdUMinus")
(use "Psdd")
(split)
(autoreal)
(split)
(use "CoGToBd")
(use "CoGx2")
(split)
(intro 0)
(use "CoGx2")
(split)
;; ?^125:x1===(1#2)*(x2+1)* ~d
(use "RealEqTrans" (pt "~ ~x1"))
(use "RealEqSym")
(use "RealUMinusUMinus")
(use "RealUMinusRealInv")
(autoreal)
(simpreal "EqHyp")
(use "RealEqSym")
(use "RealTimesIdRatUMinus")
(autoreal)
(use "RealEqRefl")
(use "RealUMinusRealInv")
(autoreal)
;; 95
;; U case
(drop "Disj")
(assume "ExHyp")
(by-assume "ExHyp" "x2" "x2Prop")
(elim "x2Prop")
(drop "x2Prop")
(assume "CoHx2" "EqHyp")
(intro 1)
(intro 0 (pt "~x2"))
(intro 0 (pt "x1"))
(split)
(use "RealUMinusReal")
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "CoHToBd")
(use "CoHx2")
(autoreal)
(split)
(intro 1)
(use "CoHCompat" (pt "x2"))
(use "RealEqSym")
(use "RealUMinusUMinus")
(autoreal)
(use "CoHx2")
(split)
(use "RealEqTrans" (pt "~ ~x1"))
(use "RealEqSym")
(use "RealUMinusUMinus")
(use "RealUMinusRealInv")
(autoreal)
(use "RealEqTrans" (pt "~((1#2)*x2)"))
(use "RealUMinusCompat")
(use "EqHyp")
(use "RealEqSym")
(use "RealTimesIdUMinus")
(use "RealRat")
(autoreal)
(use "RealEqRefl")
(use "RealUMinusRealInv")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGUMinus")

(define eterm (proof-to-extracted-term))
(animate "CoGClosure")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ag](CoRec ag=>ag ah=>ah)ag
;;  ([ag0][case (DesYprod ag0)
;;      (InL bg -> [case bg (boole pair ag1 ->
;;                  InL(cPsdUMinus boole pair InL ag1))])
;;      (InR ah -> InR(InR(cCoHCompat ah)))])
;;  ([ah][case (cCoHClosure ah)
;;      (InL bg -> [case bg (boole pair ag0 ->
;;                  InL(cPsdUMinus boole pair InL ag0))])
;;      (InR ah0 -> InR(InR(cCoHCompat ah0)))])

(deanimate "CoGClosure")

(add-sound "CoGUMinus")

;; ok, CoGUMinusSound has been added as a new theorem:

;; allnc x,ag^(CoGMR(~x)ag^ -> CoGMR x(cCoGUMinus ag^))

;; with computation rule

;; cCoGUMinus eqd
;; ([ag]
;;   (CoRec ag=>ag ah=>ah)ag
;;   ([ag0]
;;     [if (cCoGClosure ag0)
;;       ([bg]
;;        [if bg
;;          ([boole,ag1]
;;           (InL (boole yprod(ag ysum ag)) (ah ysum ah))
;;           (cPsdUMinus boole pair(InL ag ag)ag1))])
;;       ([ah]
;;        (InR (ah ysum ah) (boole yprod(ag ysum ag)))
;;        ((InR ah ah)(cCoHCompat ah)))])
;;   ([ah]
;;     [if (cCoHClosure ah)
;;       ([bg]
;;        [if bg
;;          ([boole,ag0]
;;           (InL (boole yprod(ag ysum ag)) (ah ysum ah))
;;           (cPsdUMinus boole pair(InL ag ag)ag0))])
;;       ([ah0]
;;        (InR (ah ysum ah) (boole yprod(ag ysum ag)))
;;        ((InR ah ah)(cCoHCompat ah0)))]))

(deanimate "CoGUMinus")

;; CoGPsdTimes
(set-goal "allnc x,d(CoG x -> Psd d -> CoG(x*d))")
(assume "x" "d" "CoGx" "Psdd")
(elim "Psdd")
;; 3,4
(simpreal "RealTimesOne")
(use "CoGx")
(autoreal)
;; 4
(assert "x* IntUMinus 1=== ~x")
 (simpreal "RealTimesIdRatUMinus")
 (simpreal "RealTimesOne")
 (use "RealEqRefl")
 (autoreal)
(assume "Assertion")
(simpreal "Assertion")
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGx")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGPsdTimes")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (pp neterm)

;; [ag,boole][if boole (cCoGCompat ag) (cCoGCompat(cCoGUMinus(cCoGCompat ag)))]

;; CoHToCoGAux
(set-goal "all d,x(Real x -> (~x+IntN 1)* ~d===(x+1)*d)")
(assert "all d,x (~x+IntN 1)* ~d=+=(x+1)*d")
(assume "d")
(cases)
(assume "as" "M")
(use "RealEqSIntro")
(assume "n")
(ng)
;; ?^9:~((~(as n)+IntN 1)*d)==(as n+1)*d
(simprat "RatTimesPlusDistrLeft")
(simprat "RatTimesPlusDistrLeft")
(ng)
(simp "IntTimesIntNL")
(use "Truth")
;; Assertion proved.
(assume "CoHToCoGAuxEqS" "d" "x" "Rx")
(use "RealEqSToEq")
(autoreal)
(use "CoHToCoGAuxEqS")
;; Proof finished.
;; (cdp)
(save "CoHToCoGAux")

;; CoHToCoG
(set-goal "allnc x(CoH x -> CoG x)")
(assume "x" "CoHx")
(coind "CoHx" (pf "CoG x -> CoH x"))
;; 3,4
(assume "x1" "CoHx1")
(inst-with-to "CoHClosure" (pt "x1") "CoHx1" "CoHClosureInst")
(elim "CoHClosureInst")
;; 8,9
(drop "CoHClosureInst")
;; left case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(assert "CoG x2")
 (use "dx2Prop")
(assume "CoGx2")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "~x2"))
(intro 0 (pt "x1"))
(split)
(use "dx2Prop")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "CoGToBd")
(use "CoGx2")
(autoreal)
(split)
(intro 0)
(use "CoGUMinus")
;; ?_37:CoG(~ ~x2)
(simpreal "RealUMinusUMinus")
(use "CoGx2")
(autoreal)
(split)
;; ?^40:x1===(1#2)*(~x2+IntN 1)* ~d
(simpreal "<-" "RealTimesAssoc")
(simpreal "CoHToCoGAux")
(simpreal "RealTimesAssoc")
(use "dx2Prop")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 9
(drop "CoHClosureInst")
;; middle case
(assume "ExHyp")
(intro 1)
(by-assume "ExHyp" "x2" "x2Prop")
(elim "x2Prop")
(drop "x2Prop")
(assume "CoHx2" "x1Def")
(intro 0 (pt "x2"))
(intro 0 (pt "x1"))
(split)
(autoreal)
(split)
(use "CoHToBd")
(use "CoHx2")
(split)
(intro 0)
(use "CoHx2")
(split)
(use "x1Def")
(use "RealEqRefl")
(autoreal)
;; 4
(assume "x1" "CoGx1")
(inst-with-to "CoGClosure" (pt "x1") "CoGx1" "CoGClosureInst")
(elim "CoGClosureInst")
;; 78,79
(drop "CoGClosureInst")
;; left case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(assert "CoG x2")
 (use "dx2Prop")
(assume "CoGx2")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "~x2"))
(intro 0 (pt "x1"))
(split)
(use "dx2Prop")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "CoGToBd")
(use "CoGx2")
(autoreal)
(split)
(intro 0)
(use "CoGUMinus")
;; ?_107:CoG(~ ~x2)
(simpreal "RealUMinusUMinus")
(use "CoGx2")
(autoreal)
(split)
;; ?^110:x1===(1#2)*(~x2+1)*d
(simpreal "dx2Prop")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusIntNOneDistrLeft")
(simpreal "RealTimesPlusOneDistrLeft")
(simpreal "RealTimesIdRatUMinus")
(simpreal "RealTimesUMinusId")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 79
(drop "CoGClosureInst")
;; middle case
(assume "ExHyp")
(intro 1)
(by-assume "ExHyp" "x2" "x2Prop")
(elim "x2Prop")
(drop "x2Prop")
(assume "CoHx2" "x1Def")
(intro 0 (pt "x2"))
(intro 0 (pt "x1"))
(split)
(autoreal)
(split)
(use "CoHToBd")
(use "CoHx2")
(split)
(intro 0)
(use "CoHx2")
(split)
(use "x1Def")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoHToCoG")

(define eterm (proof-to-extracted-term))
(animate "CoGClosure")
(animate "CoHClosure")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ah](CoRec ah=>ag ag=>ah)ah
;;  ([ah0][case (DesYprod ah0)
;;      (InL bg -> InL(clft bg pair InL(cCoGUMinus(cCoGCompat crht bg))))
;;      (InR ah1 -> InR(InL ah1))])
;;  ([ag][case (DesYprod ag)
;;      (InL bg -> InL(clft bg pair InL(cCoGUMinus(cCoGCompat crht bg))))
;;      (InR ah0 -> InR(InL ah0))])

(deanimate "CoGClosure")
(deanimate "CoHClosure")

(add-sound "CoHToCoG")

;; ok, CoHToCoGSound has been added as a new theorem:

;; allnc x,ah^(CoHMR x ah^ -> CoGMR x(cCoHToCoG ah^))

;; with computation rule

;; cCoHToCoG eqd
;; ([ah]
;;   (CoRec ah=>ag ag=>ah)ah
;;   ([ah0]
;;     [if (cCoHClosure ah0)
;;       ([bg]
;;        (InL (boole yprod(ag ysum ah)) (ah ysum ag))
;;        (clft bg pair(InL ag ah)(cCoGUMinus(cCoGCompat crht bg))))
;;       ([ah1](InR (ah ysum ag) (boole yprod(ag ysum ah)))((InL ah ag)ah1))])
;;   ([ag]
;;     [if (cCoGClosure ag)
;;       ([bg]
;;        (InL (boole yprod(ag ysum ah)) (ah ysum ag))
;;        (clft bg pair(InL ag ah)(cCoGUMinus(cCoGCompat crht bg))))
;;       ([ah0](InR (ah ysum ag) (boole yprod(ag ysum ah)))((InL ah ag)ah0))]))

(deanimate "CoHToCoG")

;; CoGToCoH
(set-goal "allnc x(CoG x -> CoH x)")
(assume "x" "CoGx")
(coind "CoGx" (pf "CoH x -> CoG x"))
;; 3,4
(assume "x1" "CoHx1")
(inst-with-to "CoHClosure" (pt "x1") "CoHx1" "CoHClosureInst")
(elim "CoHClosureInst")
;; 8,9
(drop "CoHClosureInst")
;; left case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(assert "CoG x2")
 (use "dx2Prop")
(assume "CoGx2")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "~x2"))
(intro 0 (pt "x1"))
(split)
(use "dx2Prop")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "CoGToBd")
(use "CoGx2")
(autoreal)
(split)
(intro 0)
(use "CoGUMinus")
;; ?_37:CoG(~ ~x2)
(simpreal "RealUMinusUMinus")
(use "CoGx2")
(autoreal)
(split)
;; ?^40:x1===(1#2)*(~x2+IntN 1)* ~d
(simpreal "<-" "RealTimesAssoc")
(simpreal "CoHToCoGAux")
(simpreal "RealTimesAssoc")
(use "dx2Prop")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 9
(drop "CoHClosureInst")
;; middle case
(assume "ExHyp")
(intro 1)
(by-assume "ExHyp" "x2" "x2Prop")
(elim "x2Prop")
(drop "x2Prop")
(assume "CoHx2" "x1Def")
(intro 0 (pt "x2"))
(intro 0 (pt "x1"))
(split)
(autoreal)
(split)
(use "CoHToBd")
(use "CoHx2")
(split)
(intro 0)
(use "CoHx2")
(split)
(use "x1Def")
(use "RealEqRefl")
(autoreal)
;; 4
(assume "x1" "CoGx1")
(inst-with-to "CoGClosure" (pt "x1") "CoGx1" "CoGClosureInst")
(elim "CoGClosureInst")
;; 78,79
(drop "CoGClosureInst")
;; left case
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(assert "CoG x2")
 (use "dx2Prop")
(assume "CoGx2")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "~x2"))
(intro 0 (pt "x1"))
(split)
(use "dx2Prop")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "CoGToBd")
(use "CoGx2")
(autoreal)
(split)
(intro 0)
(use "CoGUMinus")
;; ?_107:CoG(~ ~x2)
(simpreal "RealUMinusUMinus")
(use "CoGx2")
(autoreal)
(split)
;; ?^110:x1===(1#2)*(~x2+1)*d
(simpreal "dx2Prop")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusIntNOneDistrLeft")
(simpreal "RealTimesPlusOneDistrLeft")
(simpreal "RealTimesIdRatUMinus")
(simpreal "RealTimesUMinusId")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 79
(drop "CoGClosureInst")
;; middle case
(assume "ExHyp")
(intro 1)
(by-assume "ExHyp" "x2" "x2Prop")
(elim "x2Prop")
(drop "x2Prop")
(assume "CoHx2" "x1Def")
(intro 0 (pt "x2"))
(intro 0 (pt "x1"))
(split)
(autoreal)
(split)
(use "CoHToBd")
(use "CoHx2")
(split)
(intro 0)
(use "CoHx2")
(split)
(use "x1Def")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGToCoH")

(define eterm (proof-to-extracted-term))
(animate "CoGClosure")
(animate "CoHClosure")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ag](CoRec ag=>ah ah=>ag)ag
;;  ([ah][case (DesYprod ah)
;;      (InL bg -> InL(clft bg pair InL(cCoGUMinus(cCoGCompat crht bg))))
;;      (InR ah0 -> InR(InL ah0))])
;;  ([ag0][case (DesYprod ag0)
;;      (InL bg -> InL(clft bg pair InL(cCoGUMinus(cCoGCompat crht bg))))
;;      (InR ah -> InR(InL ah))])

(deanimate "CoGClosure")
(deanimate "CoHClosure")

(add-sound "CoGToCoH")

;; ok, CoGToCoHSound has been added as a new theorem:

;; allnc x,ag^(CoGMR x ag^ -> CoHMR x(cCoGToCoH ag^))

;; with computation rule

;; cCoGToCoH eqd
;; ([ag]
;;   (CoRec ag=>ah ah=>ag)ag
;;   ([ah]
;;     [if (cCoHClosure ah)
;;       ([bg]
;;        (InL (boole yprod(ag ysum ah)) (ah ysum ag))
;;        (clft bg pair(InL ag ah)(cCoGUMinus(cCoGCompat crht bg))))
;;       ([ah0](InR (ah ysum ag) (boole yprod(ag ysum ah)))((InL ah ag)ah0))])
;;   ([ag0]
;;     [if (cCoGClosure ag0)
;;       ([bg]
;;        (InL (boole yprod(ag ysum ah)) (ah ysum ag))
;;        (clft bg pair(InL ag ah)(cCoGUMinus(cCoGCompat crht bg))))
;;       ([ah](InR (ah ysum ag) (boole yprod(ag ysum ah)))((InL ah ag)ah))]))

(deanimate "CoGToCoH")

;; Here ends the original file examples/analysis/graycode.scm
;; Additions for use in the Haskell translation.

;; CoGClosureInv
(set-goal "allnc x(
 exr d,x0(Psd d andd CoG x0 andl x===(1#2)*(x0+IntN 1)* ~d) ord 
 exr x0(CoH x0 andl x===(1#2)*x0) -> CoG x)")
(assume "x" "Disj")
(use "CoGClauseInv")
(elim "Disj")
;; 4,5
(drop "Disj")
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(intro 0)
(intro 0 (pt "d"))
(intro 0 (pt "x1"))
(intro 0 (pt "x"))
(split)
(use "dx1Prop")
(split)
(use "CoGToReal")
(use "dx1Prop")
(split)
(use "CoGToBd")
(use "dx1Prop")
(split)
(use "dx1Prop")
(split)
(use "dx1Prop")
(use "RealEqRefl")
(assert "x===(1#2)*(x1+IntN 1)* ~d")
(use "dx1Prop")
(assume "EqHyp")
(realproof)
;; 5
(drop "Disj")
(assume "ExHyp")
(by-assume "ExHyp" "x1" "x1Prop")
(intro 1)
(intro 0 (pt "x1"))
(intro 0 (pt "x"))
(split)
(use "CoHToReal")
(use "x1Prop")
(split)
(use "CoHToBd")
(use "x1Prop")
(split)
(use "x1Prop")
(split)
(use "x1Prop")
(use "RealEqRefl")
(assert "x===(1#2)*x1")
(use "x1Prop")
(assume "EqHyp")
(realproof)
;; Proof finished.
;; (cdp)
(save "CoGClosureInv")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (pp neterm)
;; [bgh]
;; cCoGClauseInv[if bgh (InL (boole yprod ag) ah) (InR ah (boole yprod ag))]
;; (ppc neterm)
;; [bgh]cCoGClauseInv[case bgh (InL bg -> InL bg) (InR ah -> InR ah)]
(animate "CoGClauseInv")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [bgh]
;;  (CoRec boole yprod ag ysum ah=>ag boole yprod ag ysum ah=>ah)
;;  [case bgh (InL bg -> InL bg) (InR ah -> InR ah)]
;;  ([bgh0]
;;    [case bgh0
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah -> InR(InL ah))])
;;  ([bgh0]
;;    [case bgh0
;;      (InL bg -> InL(clft bg pair InL crht bg))
;;      (InR ah -> InR(InL ah))])

(deanimate "CoGClauseInv")

;; ;; RealToCoIAux is renamed into RealToSdPairReal and is to be moved
;; ;; into examples/analysis/digits.scm, together with its auxiliaries
;; ;; ApproxSplitZeroMinusPtFive ApproxSplitZeroPtFive
;; ;; TwoTimesPlusIntReal TwoTimesPlusEq and also SdMRSdToInt

;; 2019-08-05.  New attempt for RealToCoG: use RealToCoI with a new
;; CoIToCoG.

;; SdToPsd
(set-goal "allnc d(Sd d -> Psd d orl d=0)")
(assume "d" "Sdd")
(elim "Sdd")
(intro 0)
(use "InitPsdTrue")
(intro 1)
(use "Truth")
(intro 0)
(use "InitPsdFalse")
;; Proof finished.
;; (cdp)
(save "SdToPsd")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)
;; [s][case s (SdR -> Inl True) (SdM -> DummyR) (SdL -> Inl False)]`

(add-sound "SdToPsd")

;; ok, SdToPsdSound has been added as a new theorem:

;; allnc d,s^(
;;  SdMR d s^ -> 
;;  (OrLMR (cterm (boole^) PsdMR d boole^) (cterm () d=0))(cSdToPsd s^))

;; with computation rule

;; cSdToPsd eqd([s][if s (Inl True) (DummyR boole) (Inl False)])

(deanimate "SdToPsd")

;; PsdToDisj
(set-goal "allnc d(Psd d -> d=1 oru d=IntN 1)")
(assume "d" "Psdd")
(elim "Psdd")
(intro 0)
(use "Truth")
(intro 1)
(use "Truth")
;; Proof finished.
;; (cdp)
(save "PsdToDisj")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (pp neterm)
;; [boole]boole

(add-sound "PsdToDisj")

;; ok, PsdToDisjSound has been added as a new theorem:

;; allnc d,boole^(
;;  PsdMR d boole^ -> 
;;  (OrUMR (cterm () d=1) (cterm () d=IntN 1))(cPsdToDisj boole^))

;; with computation rule

;; cPsdToDisj eqd([boole]boole)

;; (set! COMMENT-FLAG #f)
;; CoIToCoG
(set-goal "allnc x(Real x -> abs x<<=1 -> CoI x -> CoG x)")
(assume "x" "Rx" "xBd" "CoIx")
(coind "CoIx" (pf "CoI x -> CoH x"))
;; 3,4
(assume "x1" "CoIx1")
(inst-with-to "CoIClause" (pt "x1") "CoIx1" "CoIClauseInst")
(by-assume "CoIClauseInst" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(by-assume "dx2Prop" "y2" "dx2y2Prop")
(assert "Real x2")
 (use "dx2y2Prop")
(assume "Rx2")
(assert "Psd d orl d=0")
 (use "SdToPsd")
 (use "dx2y2Prop")
(assume "Disj")
(elim "Disj")
;; 24,25
(drop "Disj")
(assume "Psdd")
(intro 0)
(inst-with-to "PsdToDisj" (pt "d") "Psdd" "dDisj")
(elim "dDisj")
;; 31,32
(drop "dDisj")
(assume "d=1")
(intro 0 (pt "IntP 1"))
;; (intro 0 (pt "IntN 1"))
(intro 0 (pt "~x2"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdTrue")
(split)
(realproof)
(split)
(simpreal "RealAbsUMinus")
(use "dx2y2Prop")
(use "Rx2")
(split)
(intro 1)
(use "CoIUMinus")
(simpreal "RealUMinusUMinus")
(use "dx2y2Prop")
(use "Rx2")
(split)
(simpreal "dx2y2Prop")
(simpreal "dx2y2Prop")
(simpreal "<-" "RealTimesAssoc")
(simpreal "CoHToCoGAux")
(simpreal "RealTimesOne")
(simp "d=1")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(realproof)
;; 32
(drop "dDisj")
(assume "d=IntN 1")
(intro 0 (pt "IntN 1"))
(intro 0 (pt "x2"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdFalse")
(split)
(realproof)
(split)
(use "dx2y2Prop")
(split)
(intro 1)
(use "dx2y2Prop")
(split)
(simpreal "dx2y2Prop")
(simpreal "dx2y2Prop")
(simpreal "<-" "RealTimesAssoc")
(ng #t)
(simpreal "RealTimesOne")
(simp "d=IntN 1")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(realproof)
;; 25
(drop "Disj")
(assume "d=0")
(intro 1)
(intro 0 (pt "2*x1"))
(intro 0 (pt "x1"))
;; To avoid many cCoICompat's in the extracted term (arising from a
;; later proof of CoI(2*x1)) we first prove 2*x1===x2 (idea of
;; F. Wiesnet).
(assert "2*x1===x2")
 (simpreal "dx2y2Prop")
 (simpreal "dx2y2Prop")
 (simpreal "RealTimesAssoc")
 (ng #t)
 (simpreal "RealOneTimes")
 (simp "d=0")
 (simpreal "RealPlusZero")
 (use "RealEqRefl")
 (autoreal)
;; Assertion proved.
(assume "2x1=x2")
(split)
(assert "Real x1")
 (use "CoIToReal")
 (use "CoIx1")
(assume "Rx1")
(realproof)
(split)
(simpreal "2x1=x2")
(use "dx2y2Prop")
(split)
(intro 1)
(simpreal "2x1=x2")
(use "dx2y2Prop")
(split)
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 4
(assume "x1" "CoIx1")
(inst-with-to "CoIClause" (pt "x1") "CoIx1" "CoIClauseInst")
(by-assume "CoIClauseInst" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(by-assume "dx2Prop" "y2" "dx2y2Prop")
(assert "Real x2")
 (use "dx2y2Prop")
(assume "Rx2")
(assert "Psd d orl d=0")
 (use "SdToPsd")
 (use "dx2y2Prop")
(assume "Disj")
(elim "Disj")
;; 165,166
(drop "Disj")
(assume "Psdd")
(intro 0)
(inst-with-to "PsdToDisj" (pt "d") "Psdd" "dDisj")
(elim "dDisj")
;; 172,173
(drop "dDisj")
(assume "d=1")
(intro 0 (pt "IntP 1"))
;; (intro 0 (pt "IntN 1"))
(intro 0 (pt "x2"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdTrue")
(split)
(realproof)
(split)
(use "dx2y2Prop")
(split)
(intro 1)
(use "dx2y2Prop")
(split)
(simpreal "dx2y2Prop")
(simpreal "dx2y2Prop")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesOne")
(simp "d=1")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(realproof)
;; 173
(drop "dDisj")
(assume "d=IntN 1")
(intro 0 (pt "IntN 1"))
(intro 0 (pt "~x2"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdFalse")
(split)
(realproof)
(split)
(simpreal "RealAbsUMinus")
(use "dx2y2Prop")
(use "dx2y2Prop")
(split)
(intro 1)
(use "CoIUMinus")
(simpreal "RealUMinusUMinus")
(use "dx2y2Prop")
(use "Rx2")
(split)
(simpreal "dx2y2Prop")
(simpreal "dx2y2Prop")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusDistrLeft")
(ng #t)
(simpreal "RealTimesUMinusId")
(simpreal "RealTimesIntNOne")
(simpreal "RealUMinusUMinus")
(simp "d=IntN 1")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 166
(assume "d=0")
(intro 1)
(intro 0 (pt "2*x1"))
(intro 0 (pt "x1"))
(assert "2*x1===x2")
 (simpreal "dx2y2Prop")
 (simpreal "dx2y2Prop")
 (simpreal "RealTimesAssoc")
 (ng #t)
 (simpreal "RealOneTimes")
 (simp "d=0")
 (simpreal "RealPlusZero")
 (use "RealEqRefl")
 (autoreal)
;; Assertion proved.
(assume "2x1=x2")
(split)
(assert "Real x1")
 (use "CoIToReal")
 (use "CoIx1")
(assume "Rx1")
(realproof)
(split)
(simpreal "2x1=x2")
(use "dx2y2Prop")
(split)
(intro 1)
(simpreal "2x1=x2")
(use "dx2y2Prop")
(split)
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoIToCoG")
;; (set! COMMENT-FLAG #t)

(define CoIToCoG-eterm (proof-to-extracted-term))
(define CoIToCoG-neterm (rename-variables (nt CoIToCoG-eterm)))
;; (ppc CoIToCoG-neterm)

;; [ai]
;;  (CoRec ai=>ag ai=>ah)ai
;;  ([ai0]
;;    [case (cSdToPsd clft DesYprod ai0)
;;      (Inl boole -> 
;;      InL
;;      [case (cPsdToDisj boole)
;;        (True -> True pair InR(cCoIUMinus(cCoICompat crht DesYprod ai0)))
;;        (False -> False pair InR crht DesYprod ai0)])
;;      (DummyR -> InR(InR(cCoICompat crht DesYprod ai0)))])
;;  ([ai0]
;;    [case (cSdToPsd clft DesYprod ai0)
;;      (Inl boole -> 
;;      InL
;;      [case (cPsdToDisj boole)
;;        (True -> True pair InR crht DesYprod ai0)
;;        (False -> False pair InR(cCoIUMinus(cCoICompat crht DesYprod ai0)))])
;;      (DummyR -> InR(InR(cCoICompat crht DesYprod ai0)))])

(add-sound "CoIToCoG")

;; ok, CoIToCoGSound has been added as a new theorem:

;; allnc x(
;;  Real x -> abs x<<=1 -> allnc ai^(CoIMR x ai^ -> CoGMR x(cCoIToCoG ai^)))

;; with computation rule

;; cCoIToCoG eqd
;; ([ai]
;;   (CoRec ai=>ag ai=>ah)ai
;;   ([ai0]
;;     [if (cSdToPsd clft DesYprod ai0)
;;       ([boole]
;;        (InL (boole yprod(ag ysum ai)) (ah ysum ai))
;;        [if boole
;;          (True pair(InR ai ag)(cCoIUMinus(cCoICompat crht DesYprod ai0)))
;;          (False pair(InR ai ag)crht DesYprod ai0)])
;;       ((InR (ah ysum ai) (boole yprod(ag ysum ai)))
;;       ((InR ai ah)(cCoICompat crht DesYprod ai0)))])
;;   ([ai0]
;;     [if (cSdToPsd clft DesYprod ai0)
;;       ([boole]
;;        (InL (boole yprod(ag ysum ai)) (ah ysum ai))
;;        [if boole
;;          (True pair(InR ai ag)crht DesYprod ai0)
;;          (False pair(InR ai ag)(cCoIUMinus(cCoICompat crht DesYprod ai0)))])
;;       ((InR (ah ysum ai) (boole yprod(ag ysum ai)))
;;       ((InR ai ah)(cCoICompat crht DesYprod ai0)))]))

(deanimate "CoIToCoG")

;; 2019-08-13.  We now prepare for the Haskell translation including a
;; reasonable display of what is returned.

;; Similar to what was done in digits we add a finite algebra gd for
;; Gray digits

(add-algs
 "gd"
 '("GR" "gd") '("GL" "gd") '("GU" "gd") '("HR" "gd") '("HL" "gd") '("HD" "gd"))
(add-totality "gd")

;; GdTotalVar
(set-goal "all gd TotalGd gd")
(use "AllTotalIntro")
(assume "gd^" "Tgd")
(use "Tgd")
;; Proof finished
(save "GdTotalVar")

;; GdEqToEqD
(set-goal "all gd1,gd2(gd1=gd2 -> gd1 eqd gd2)")
(cases)
;; 2-7
(cases)
(assume "Useless")
(use "InitEqD")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
;; 3
(cases)
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Useless")
(use "InitEqD")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
;; 4
(cases)
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Useless")
(use "InitEqD")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
;; 5
(cases)
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Useless")
(use "InitEqD")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
;; 6
(cases)
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Useless")
(use "InitEqD")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
;; 7
(cases)
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Absurd")
(use "EfEqD")
(use "Absurd")
(assume "Useless")
(use "InitEqD")
;; Proof finished.
;; (cdp)
(save "GdEqToEqD")

;; (pp (pt "str gd"))

;; 2019-08-14.  
;; Conversion from ag/ah into str gd

(add-program-constant "GToStrGd" (py "ag=>str gd"))
(add-program-constant "HToStrGd" (py "ah=>str gd"))
(add-computation-rules
 "GToStrGd(LR True ag)" "GR:~:GToStrGd ag"
 "GToStrGd(LR False ag)" "GL:~:GToStrGd ag"
 "GToStrGd(U ah)" "GU:~:HToStrGd ah")

(add-computation-rules
 "HToStrGd(Fin True ag)" "HR:~:GToStrGd ag"
 "HToStrGd(Fin False ag)" "HL:~:GToStrGd ag"
 "HToStrGd(D ah)" "HD:~:HToStrGd ah")

(add-program-constant "TakeG" (py "nat=>ag=>list gd"))
(add-computation-rules
 "TakeG n ag" "n init(GToStrGd ag)") 

;; Conversion from list gd into rat
(add-program-constant "ListGdToRat" (py "list gd=>rat"))
(add-computation-rules
 "ListGdToRat(Nil gd)" "0#1"
 "ListGdToRat(GR::list gd)" "(1#2)*(~(ListGdToRat(list gd))+1)"
 "ListGdToRat(GL::list gd)" "(1#2)*(ListGdToRat(list gd)+IntN 1)"
 "ListGdToRat(GU::list gd)" "(1#2)*ListGdToRat(list gd)"
 "ListGdToRat(HR::list gd)" "(1#2)*(ListGdToRat(list gd)+1)"
 "ListGdToRat(HL::list gd)" "(1#2)*(~(ListGdToRat(list gd))+IntN 1)"
 "ListGdToRat(HD::list gd)" "(1#2)*ListGdToRat(list gd)")

'(
(animate "RealToCoI")
(animate "RealToCoIAux")
(animate "ApproxSplitZeroPtFive")
(animate "ApproxSplitZeroMinusPtFive")
(animate "ApproxSplit")
(animate "SdToPsd")
(animate "Lft")
(animate "Rht")
(animate "PsdToDisj")
(animate "CoIUMinus")
(animate "CoICompat")
(animate "CoIClosure")
(animate "CoIClauseInv")
(animate "SdUMinus")

(terms-to-haskell-program
 "~/temp/graytest.hs"
 (list (list CoIToCoG-eterm "coitocog")
       (list RealToCoI-eterm "realtocoi")
       (list RatToCoI-eterm "rattocoi")
       (list (pt "SdMs") "sdms")
       (list (pt "PtFive") "ptfive")
       (list (pt "MPtFive") "mptfive")
       ;; (list (pt "OneSdR") "onesdr")
       ;; (list (pt "OneSdL") "onesdl")
       ;; (list (pt "SqrtTwoOverTwo") "stot")
       ;; (list (pt "IrrStr") "irrstr")
       (list (pt "TakeStr") "takestr")
       (list (pt "ListSdToRat") "listsdtorat")
       (list (pt "GToStrGd") "gtostrgd")
       (list (pt "HToStrGd") "htostrgd")
       (list (pt "TakeG") "takeg")
       (list (pt "ListGdToRat") "listgdtorat")
       ))

(deanimate "RealToCoI")
(deanimate "RealToCoIAux")
(deanimate "ApproxSplitZeroMinusPtFive")
(deanimate "ApproxSplitZeroPtFive")
(deanimate "ApproxSplit")
(deanimate "SdToPsd")
(deanimate "Lft")
(deanimate "Rht")
(deanimate "PsdToDisj")
(deanimate "CoIUMinus")
(deanimate "CoICompat")
(deanimate "CoIClosure")
(deanimate "CoIClauseInv")
(deanimate "SdUMinus")
)

;; ghci graytest.hs

;; 2019-08-14

;; takestr 18 (rattocoi (1 % 3))
;; [SdR,SdL,SdR,SdL,SdR,SdL,SdR,SdL,SdR,SdL,SdR,SdL,SdR,SdL,SdR,SdL,SdR,SdL]

;; takeg 18 (coitocog (rattocoi (1 % 3)))
;; [GR,GR,GR,GR,GR,GR,GR,GR,GR,GR,GR,GR,GR,GR,GR,GR,GR,GR]

;; CoIToCoG is probably wrongly translated.  Postponed.
