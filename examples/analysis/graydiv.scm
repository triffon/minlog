;; 2019-12-08.  examples/analysis/graydiv.scm

;; (load "~/git/minlog/init.scm")

(set! COMMENT-FLAG #f)
(libload "nat.scm")
(libload "list.scm")
(libload "str.scm")
(libload "pos.scm")
(libload "int.scm")
(libload "rat.scm")
(remove-var-name "x" "y" "z")
(libload "rea.scm")
;; (set! COMMENT-FLAG #t)

(load "~/git/minlog/examples/analysis/digits.scm")
(load "~/git/minlog/examples/analysis/sdcode.scm")
(load "~/git/minlog/examples/analysis/graycode.scm")
(load "~/git/minlog/examples/analysis/JK.scm")
(load "~/git/minlog/examples/analysis/grayavaux.scm")
(load "~/git/minlog/examples/analysis/div.scm")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Division for Gray code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; PMOneToCoG
(set-goal "allnc x(x===1 oru x===IntN 1 -> CoG x)")
(assume "x" "PMOnex")
(coind "PMOnex" (pf "x===1 oru x===IntN 1 -> CoH x"))
(assume "x1" "Disj")
(elim "Disj")
;; 6,7
(assume "x1=1")
(intro 0)
(intro 0 (pt "IntP 1"))
(intro 0 (pt "RealConstr([n](IntN 1#1))([p]Zero)"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdTrue")
(split)
(use "RealRat")
(split)
(use "RealLeRefl")
(use "RealRat")
(split)
(intro 1)
(intro 1)
(use "RealEqRefl")
(use "RealRat")
(split)
(simpreal "x1=1")
(ng #t)
(use "RealEqRefl")
(use "RealRat")
(use "RealEqRefl")
(realproof)
;; 7
(assume "x1=== ~1")
(intro 0)
(intro 0 (pt "IntN 1"))
(intro 0 (pt "RealConstr([n](IntN 1#1))([p]Zero)"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdFalse")
(split)
(use "RealRat")
(split)
(use "RealLeRefl")
(use "RealRat")
(split)
(intro 1)
(intro 1)
(use "RealEqRefl")
(use "RealRat")
(split)
(simpreal "x1=== ~1")
(ng #t)
(use "RealEqRefl")
(use "RealRat")
(use "RealEqRefl")
(realproof)
;; 4
(assume "x1" "Disj")
(elim "Disj")
;; 55,56
(assume "x1=1")
(intro 0)
(intro 0 (pt "IntP 1"))
(intro 0 (pt "RealConstr([n](1#1))([p]Zero)"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdTrue")
(split)
(use "RealRat")
(split)
(use "RealLeRefl")
(use "RealRat")
(split)
(intro 1)
(intro 0)
(use "RealEqRefl")
(use "RealRat")
(split)
(simpreal "x1=1")
(ng #t)
(use "RealEqRefl")
(use "RealRat")
(use "RealEqRefl")
(realproof)
;; 56
(assume "x1=== ~1")
(intro 0)
(intro 0 (pt "IntN 1"))
(intro 0 (pt "RealConstr([n](1#1))([p]Zero)"))
(intro 0 (pt "x1"))
(split)
(use "InitPsdFalse")
(split)
(use "RealRat")
(split)
(use "RealLeRefl")
(use "RealRat")
(split)
(intro 1)
(intro 0)
(use "RealEqRefl")
(use "RealRat")
(split)
(simpreal "x1=== ~1")
(ng #t)
(use "RealEqRefl")
(use "RealRat")
(use "RealEqRefl")
(realproof)
;; Proof finished.
;; (cdp)
(save "PMOneToCoG")

(define eterm (proof-to-extracted-term))
>(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [boole]
;;  (CoRec boole=>ag boole=>ah)boole
;;  ([boole0]
;;    [case boole0
;;      (True -> InL(True pair InR False))
;;      (False -> InL(False pair InR False))])
;;  ([boole0]
;;    [case boole0
;;      (True -> InL(True pair InR True))
;;      (False -> InL(False pair InR True))])

;; CoGOne
(set-goal "CoG 1")
(use "PMOneToCoG")
(intro 0)
(use "RealEqRefl")
(use "RealRat")
;; Proof finished.
;; (cdp)
(save "CoGOne")

(define eterm (proof-to-extracted-term))
(animate "PMOneToCoG")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; (CoRec boole=>ag boole=>ah)True
;; ([boole]
;;   [case boole
;;     (True -> InL(True pair InR False))
;;     (False -> InL(False pair InR False))])
;; ([boole]
;;   [case boole
;;     (True -> InL(True pair InR True))
;;     (False -> InL(False pair InR True))])

(deanimate "PMOneToCoG")

;; CoGIntNOne
(set-goal "CoG(IntN 1)")
(use "PMOneToCoG")
(intro 1)
(use "RealEqRefl")
(use "RealRat")
;; Proof finished.
;; (cdp)
(save "CoGIntNOne")

(define eterm (proof-to-extracted-term))
(animate "PMOneToCoG")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; (CoRec boole=>ag boole=>ah)False
;; ([boole]
;;   [case boole
;;     (True -> InL(True pair InR False))
;;     (False -> InL(False pair InR False))])
;; ([boole]
;;   [case boole
;;     (True -> InL(True pair InR True))
;;     (False -> InL(False pair InR True))])

(deanimate "PMOneToCoG")

;; CoGShiftAux1
(set-goal "all x,y(Real x -> 
 abs x<<=1 -> y===(1#2)*(x+IntN 1)* ~1 -> y<<=0 -> y===0)")
(assume "x" "y" "Rx" "xBd" "yDef" "y<=0")
(use "RealLeAntiSym")
(use "y<=0")
;; ?_4:0<<=y
(assert "x===1")
 (use "RealLeAntiSym")
 ;; 7,8
 (use "RealLeTrans" (pt "abs x"))
 (use "RealLeAbsId")
 (autoreal)
 (use "xBd")
 ;; 8
 (assert "x===2* ~y+1")
  (simpreal "yDef")
  (simpreal "RealTimesIdRatUMinus")
  (simpreal "RealTimesOne")
  (simpreal "RealUMinusUMinus")
  (simpreal "RealTimesAssoc")
  (ng #t)
  (simpreal "RealOneTimes")
  (simpreal "<-" "RealPlusAssoc")
  (ng #t)
  (simpreal "RealPlusZero")
  (use "RealEqRefl")
  (autoreal)
 (assume "xEq")
 (simpreal "xEq")
 (use "RealLeTrans" (pt "2* RealUMinus 0+1"))
 (ng #t)
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeUMinus")
 (use "y<=0")
 (use "RatLeToRealLe")
 (use "Truth")
(assume "x=1")
(simpreal "yDef")
(simpreal "x=1")
(use "RatLeToRealLe")
(use "Truth")
;; Proof finished.
;; (cdp)
(save "CoGShiftAux1")

;; CoGShiftAux2
(set-goal "all x,y(Real x -> 
 abs x<<=1 -> y===(1#2)*(x+1)*1 -> y<<=0 -> y===0)")
(assume "x" "y" "Rx" "xBd" "yDef" "y<=0")
(use "RealLeAntiSym")
(use "y<=0")
;; ?_4:0<<=y
(assert "x=== RealUMinus 1")
 (use "RealLeAntiSym")
 ;; 7,8
 (assert "x===2*y+ IntN 1")
  (simpreal "yDef")
  (simpreal "<-" "RealTimesAssoc")
  (simpreal "RealTimesOne")
  (simpreal "RealTimesAssoc")
  (ng #t)
  (simpreal "RealOneTimes")
  (simpreal "<-" "RealPlusAssoc")
  (ng #t)
  (simpreal "RealPlusZero")
  (use "RealEqRefl")
  (autoreal)
 (assume "xEq")
 (simpreal "xEq")
 (use "RealLeTrans" (pt "2* RealUMinus 0+IntN 1"))
 (use "RealLeMonPlus")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "y<=0")
 (use "RatLeToRealLe")
 (use "Truth")
 (ng #t)
 (use "RatLeToRealLe")
 (use "Truth")
;; ?_8:~1<<=x
 (simpreal (pf "x=== ~ ~x"))
 (use "RealLeUMinus")
 (use "RealLeTrans" (pt "abs ~x"))
 (use "RealLeAbsId")
 (autoreal)
 (simpreal "RealAbsUMinus")
 (use "xBd")
 (autoreal)
 (use "RealEqSym")
 (use "RealUMinusUMinus")
 (autoreal)
(assume "x= ~1")
(simpreal "yDef")
(simpreal "x= ~1")
(use "RatLeToRealLe")
(use "Truth")
;; Proof finished.
;; (cdp)
(save "CoGShiftAux2")

;; CoGShiftAux3
(set-goal "all x,y(Real x -> y===(1#2)*x -> y<<=0 -> x<<=0)")
(assume "x" "y" "Rx" "yDef" "y<=0")
(simpreal (pf "x===2*((1#2)*x)"))
(simpreal (pf "0===RealTimes 2 0"))
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(simpreal "<-" "yDef")
(use "y<=0")
(use "RatEqvToRealEq")
(use "Truth")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGShiftAux3")

;; CoGShiftAux4
(set-goal
 "all x,y(Real x -> abs x<<=1 -> y===(1#2)*x -> y<<=0 -> abs(x+1)<<=1)")
(assume "x" "y" "Rx" "xBd" "yDef" "y<=0")
(use "RealLeAbs")
;; ?_3:x+1<<=1
(use "RealLeTrans" (pt "RealPlus 0 1"))
(use "RealLeMonPlus")
(use "CoGShiftAux3" (pt "y"))
(use "Rx")
(use "yDef")
(use "y<=0")
(use "RatLeToRealLe")
(use "Truth") 
(use "RatLeToRealLe")
(use "Truth") 
;; ?_4:~(x+1)<<=1
(use "RealLeTrans" (pt "~(RealUMinus 1)"))
(use "RealLeUMinus")
(use "RealLeTrans" (pt "(RealUMinus 1)+1"))
(use "RatLeToRealLe")
(use "Truth")
(use "RealLeMonPlus")
(use "RealLeAbsInv")
(use "Rx")
(use "xBd")
(use "RatLeToRealLe")
(use "Truth")
(use "RatLeToRealLe")
(use "Truth")
;; Proof finished.
;; (cdp)
(save "CoGShiftAux4")

;; (set! COMMENT-FLAG #f)
;; CoGShift
(set-goal "allnc x(
 exr y,d(CoG y andi Psd d andi y<<=0 andi
         (d=IntP 1 andnc x===y+1 ornc d=IntN 1 andnc x=== ~(y+1))) -> CoG x)")
(assume "x" "Shift")
(coind "Shift"
     (pf "exr y,d(CoH y andi Psd d andi y<<=0 andi
         (d=IntP 1 andnc x===y+1 ornc d=IntN 1 andnc x=== ~(y+1))) -> CoH x"))
;; 3,4
(drop "Shift")
(assume "x0" "ExHyp")
(by-assume "ExHyp" "y" "yProp")
(by-assume "yProp" "d" "dyProp")
(elim "dyProp")
(drop "dyProp")
(assume "CoGy" "Conj")
(elim "Conj")
(drop "Conj")
(assume "Psdd" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "y<=0" "Disj")
;; 
(inst-with-to "CoGClosure" (pt "y") "CoGy" "CoGClosureInst")
(elim "CoGClosureInst")
;; 24,25
(drop "CoGClosureInst")
(assume "ExHypez")
(intro 0)
(by-assume "ExHypez" "e" "eProp")
(by-assume "eProp" "z" "ezProp")
(elim "ezProp")
(drop "ezProp")
(assume "Psde" "Conj2")
(elim "Conj2")
(drop "Conj2")
(elim "Psde")
;; 40,41
;; Case e=1
(assume "CoGz" "yDef")
(assert "y===0")
 (use "CoGShiftAux1" (pt "z"))
 (autoreal)
 (use "CoGToBd")
 (use "CoGz")
 (use "yDef")
 (use "y<=0")
(assume "y=0")
(intro 0 (pt "d"))
(intro 0 (pt "RealUMinus 1"))
(intro 0 (pt "x0"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
(use "RatLeToRealLe")
(use "Truth")
(split)
(intro 0)
(use "CoGIntNOne")
(elim "Disj")
;; 64,65
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "d=1" "x0Def")
(split)
(simp "d=1")
(ng #t)
(simpreal "x0Def")
(simpreal "y=0")
(ng #t)
(use "RatEqvToRealEq")
(use "Truth")
(use "RealEqRefl")
(autoreal)
;; 65
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "d=-1" "x0Def")
(split)
(simp "d=-1")
(ng #t)
(simpreal "x0Def")
(simpreal "y=0")
(ng #t)
(use "RatEqvToRealEq")
(use "Truth")
(use "RealEqRefl")
(autoreal)
;; 41
;; Case e=-1
(assume "CoGz" "yDef")
(intro 0 (pt "d"))
(intro 0 (pt "~z"))
(intro 0 (pt "x0"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "CoGToBd")
(use "CoGz")
(autoreal)
(split)
(intro 0)
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGz")
(autoreal)
(elim "Disj")
;; 111,112
(drop "Disj")
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "d=1" "x0Def")
(split)
(simpreal "x0Def")
(simpreal (pf "y+1===y+RealTimes(1#2)2"))
(simpreal "yDef")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesPlusDistr")
(ng #t)
(simpreal "RealTimesOne")
(simpreal "<-" "RealTimesAssoc")
(simp "d=1")
(ng #t)
(simpreal "RealTimesIntNOne")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealUMinusPlusRat")
(simpreal "RealUMinusUMinus")
(use "RealEqRefl")
(autoreal)
(ng #t)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 112
(drop "Disj")
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "d=-1" "x0Def")
(split)
(simpreal "x0Def")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusDistrLeft")
(ng #t)
(simp "d=-1")
(ng #t)
(simpreal "RealTimesOne")
(simpreal (pf "~(y+1)=== ~(y+RealTimes(1#2)2)"))
(simpreal "yDef")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesPlusDistr")
(ng #t)
(simpreal "RealTimesOne")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "<-" "RealTimesIdUMinus")
(simpreal "RealUMinusPlusRat")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 25
(drop "CoGClosureInst")
(assume "ExHypz")
(intro 0)
(by-assume "ExHypz" "z" "zProp")
(elim "zProp")
(drop "zProp")
(assume "CoHz" "yDef")
(assert "z<<=0")
 (use "CoGShiftAux3" (pt "y"))
 (autoreal)
 (use "yDef")
 (use "y<=0")
(assume "z<=0")
(assert "abs(z+1)<<=1")
 (use "CoGShiftAux4" (pt "y"))
 (autoreal)
 (use "CoHToBd")
 (use "CoHz")
 (use "yDef")
 (use "y<=0")
(assume "abs(z+1)<=1")
;; Go for x=-(z+1)
(intro 0 (pt "d"))
(intro 0 (pt "~(z+1)"))
(intro 0 (pt "x0"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "abs(z+1)<=1")
(autoreal)
(split)
(intro 1)
(intro 0 (pt "z"))
(intro 0 (pt "IntN 1"))
(split)
(use "CoHToCoG")
(use "CoHz")
(split)
(use "InitPsdFalse")
(split)
(use "z<=0")
(intro 1)
(split)
(use "Truth")
(use "RealEqRefl")
(autoreal)
;; ?^239:x0===(1#2)*(~(z+1)+IntN 1)* ~d andnc x0===x0
(elim "Disj")
;; 254,255
(drop "Disj")
(assume "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "d=1" "x0Def")
(simp "d=1")
(split)
(simpreal "x0Def")
;; ?^264:y+1===(1#2)*(~(z+1)+IntN 1)* ~1
(simpreal "<-" "RealTimesAssoc")
(ng #t)
(simpreal "RealTimesIntNOne")
(simpreal "RealUMinusPlusRat")
(simpreal "RealUMinusUMinus")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealTimesPlusDistr")
(ng #t)
(simpreal "yDef")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 255
(drop "Disj")
(assume "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "d=-1" "x0Def")
(simp "d=-1")
(split)
(simpreal "x0Def")
;; ?^297:~(y+1)===(1#2)*(~(z+1)+IntN 1)* ~IntN 1
(ng #t)
(simpreal "RealTimesOne")
(simpreal (pf "~(y+1)=== ~(y+RealTimes(1#2)2)"))
(simpreal "yDef")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "RealUMinusPlusRat")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "<-" "RealTimesIdUMinus")
(simpreal "RealUMinusPlusRat")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 4
(drop "Shift")
(assume "x0" "ExHyp")
(by-assume "ExHyp" "y" "yProp")
(by-assume "yProp" "d" "dyProp")
(elim "dyProp")
(drop "dyProp")
(assume "CoHy" "Conj")
(elim "Conj")
(drop "Conj")
(assume "Psdd" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "y<=0" "Disj")
(inst-with-to "CoHClosure" (pt "y") "CoHy" "CoHClosureInst")
(elim "CoHClosureInst")
;; 342,343
(drop "CoHClosureInst")
(assume "ExHypez")
(intro 0)
(by-assume "ExHypez" "e" "eProp")
(by-assume "eProp" "z" "ezProp")
(elim "ezProp")
(drop "ezProp")
(assume "Psde" "Conj2")
(elim "Conj2")
(drop "Conj2")
(elim "Psde")
;; 358,359
;; Case e=1
(assume "CoGz" "yDef")
(assert "y===0")
 (use "CoGShiftAux2" (pt "z"))
 (autoreal)
 (use "CoGToBd")
 (use "CoGz")
 (simpreal "yDef")
 (use "RealEqRefl")
 (autoreal)
 (use "y<=0")
(assume "y=0")
;; Go for x=1
(intro 0 (pt "d"))
(intro 0 (pt "RealConstr([n]1#1)([p]Zero)"))
(intro 0 (pt "x0"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
(use "RatLeToRealLe")
(use "Truth")
(split)
(intro 0)
(use "CoGOne")
(elim "Disj")
;; 384,385
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "d=1" "x0Def")
(split)
(simp "d=1")
(ng #t)
(simpreal "x0Def")
(simpreal "y=0")
(use "RatEqvToRealEq")
(use "Truth")
(use "RealEqRefl")
(autoreal)
;; 385
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "d=-1" "x0Def")
(split)
(simp "d=-1")
(ng #t)
(simpreal "x0Def")
(simpreal "y=0")
(use "RatEqvToRealEq")
(use "Truth")
(use "RealEqRefl")
(autoreal)
;; 359
;; Case e=-1
(assume "CoGz" "yDef")
;; Go for x=-z
(intro 0 (pt "d"))
(intro 0 (pt "~z"))
(intro 0 (pt "x0"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
(simpreal "RealAbsUMinus")
(use "CoGToBd")
(use "CoGz")
(autoreal)
(split)
(intro 0)
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGz")
(autoreal)
(elim "Disj")
;; 429,430
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "d=1" "x0Def")
(split)
(simp "d=1")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesOne")
(simpreal "x0Def")
(simpreal (pf "y+1===y+RealTimes(1#2)2"))
(simpreal "yDef")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "RealTimesIntNOne")
(simpreal "RealUMinusPlusRat")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(simpreal "x0Def")
(use "RealEqRefl")
(autoreal)
;; 430
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "d=-1" "x0Def")
(split)
(simp "d=-1")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesIntNOne")
(simpreal "x0Def")
(simpreal (pf "y+1===y+RealTimes(1#2)2"))
(simpreal "yDef")
(simpreal "<-" "RealTimesAssoc")
(simpreal "<-" "RealTimesPlusDistr")
(simpreal "RealTimesIntNOne")
(simpreal "RealUMinusPlusRat")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealTimesIdUMinus")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
(simpreal "x0Def")
(use "RealEqRefl")
(autoreal)
;; 343
(drop "CoHClosureInst")
(assume "ExHypz")
(by-assume "ExHypz" "z" "zProp")
(elim "zProp")
(drop "zProp")
(assume "CoHz" "yDef")
(assert "z<<=0")
 (use "CoGShiftAux3" (pt "y"))
 (autoreal)
 (use "yDef")
 (use "y<=0")
(assume "z<=0")
(assert "abs(z+1)<<=1")
 (use "CoGShiftAux4" (pt "y"))
 (autoreal)
 (use "CoHToBd")
 (use "CoHz")
 (use "yDef")
 (use "y<=0")
(assume "abs(z+1)<=1")
(intro 0)
;; Go for x=-(z+1)
(intro 0 (pt "d"))
(intro 0 (pt "z+1"))
(intro 0 (pt "x0"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
(use "abs(z+1)<=1")
(split)
(intro 1)
(intro 0 (pt "z"))
(intro 0 (pt "IntP 1"))
(split)
(use "CoHToCoG")
(use "CoHz")
(split)
(use "InitPsdTrue")
(split)
(use "z<=0")
(intro 0)
(split)
(use "Truth")
(use "RealEqRefl")
(autoreal)
;; ?_543:x0===(1#2)*(~(z+1)+1)*d andnc x0===x0
(elim "Disj")
;; 558,559
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "d=1" "x0Def")
(split)
(simp "d=1")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesOne")
(simpreal "x0Def")
(simpreal "yDef")
(simpreal "<-" "RealPlusAssoc")
(simpreal "RealTimesPlusDistr")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 559
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "d=-1" "x0Def")
(split)
(simp "d=-1")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesIntNOne")
(simpreal "x0Def")
(simpreal "yDef")
(simpreal "<-" "RealPlusAssoc")
(simpreal "RealTimesIdUMinus")
(simpreal "RealTimesPlusDistr")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGShift")
;; (set! COMMENT-FLAG #t)

(add-var-name "gb" (py "ag yprod boole"))
(add-var-name "hb" (py "ah yprod boole"))

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [gb](CoRec ag yprod boole=>ag ah yprod boole=>ah)gb
;;  ([gb0][case gb0 (ag pair boole -> [case (DesYprod ag)
;;        (InL bg -> InL[case bg
;;          (boole0 pair ag0 -> [case boole0
;;            (True -> boole pair InL cCoGIntNOne)
;;            (False -> boole pair InL(cCoGUMinus(cCoGCompat ag0)))])])
;;        (InR ah -> InL(boole pair InR(cCoHToCoG ah pair False)))])])
;;  ([hb][case hb (ah pair boole -> [case (DesYprod ah)
;;        (InL bg -> InL[case bg (boole0 pair ag -> [case boole0
;;            (True -> boole pair InL cCoGOne)
;;            (False -> boole pair InL(cCoGUMinus(cCoGCompat ag)))])])
;;        (InR ah0 -> InL(boole pair InR(cCoHToCoG ah0 pair True)))])])

(animate "CoGClosure")
(animate "CoHClosure")

(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [gb](CoRec ag yprod boole=>ag ah yprod boole=>ah)gb
;;  ([gb0][case gb0
;;      (ag pair boole -> 
;;      [case (DesYprod ag)
;;        (InL bg -> InL[case bg
;;          (boole0 pair ag0 -> 
;;          [case boole0
;;            (True -> boole pair InL cCoGIntNOne)
;;            (False -> boole pair InL(cCoGUMinus(cCoGCompat ag0)))])])
;;        (InR ah -> InL(boole pair InR(cCoHToCoG ah pair False)))])])
;;  ([hb][case hb
;;      (ah pair boole -> 
;;      [case (DesYprod ah)
;;        (InL bg -> InL[case bg
;;          (boole0 pair ag -> 
;;          [case boole0
;;            (True -> boole pair InL cCoGOne)
;;            (False -> boole pair InL(cCoGUMinus(cCoGCompat ag)))])])
;;        (InR ah0 -> InL(boole pair InR(cCoHToCoG ah0 pair True)))])])

(deanimate "CoGClosure")
(deanimate "CoHClosure")

;; As corollaries we obtain
;; CoGNegToCoGPlusOne
(set-goal "allnc x(exr y(CoG y andi y<<=0 andi x===y+1) -> CoG x)")
(assume "x" "ExHyp")
(by-assume "ExHyp" "y" "yProp")
(elim "yProp")
(drop "yProp")
(assume "CoGy" "Conj")
(elim "Conj")
(drop "Conj")
(assume "y<=0" "x=y+1")
(use "CoGShift")
(intro 0 (pt "y"))
(intro 0 (pt "IntP 1"))
(split)
(use "CoGy")
(split)
(use "InitPsdTrue")
(split)
(use "y<=0")
(intro 0)
(split)
(use "Truth")
(use "x=y+1")
;; Proof finished.
;; (cdp)
(save "CoGNegToCoGPlusOne")

(define eterm (proof-to-extracted-term))
(animate "CoGShift")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

(deanimate "CoGShift")

;; As for CoGShift, but with (ag pair True) rather than (ag pair boole)
;; as CoRec argument

;; CoGPosToCoGMinusOne
(set-goal "allnc x(exr y(CoG y andi 0<<=y andi x===y+ ~1) -> CoG x)")
(assume "x" "ExHyp")
(by-assume "ExHyp" "y" "yProp")
(elim "yProp")
(drop "yProp")
(assume "CoGy" "Conj")
(elim "Conj")
(drop "Conj")
(assume "y<=0" "x=y+ ~1")
(use "CoGShift")
(intro 0 (pt "~y"))
(intro 0 (pt "IntN 1"))
(split)
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGy")
(autoreal)
(split)
(use "InitPsdFalse")
(split)
(use "RealLeUMinusInv")
(simpreal "RealUMinusUMinus")
(use "y<=0")
(autoreal)
(intro 1)
(split)
(use "Truth")
(simpreal "RealUMinusPlusRat")
(simpreal "RealUMinusUMinus")
(use "x=y+ ~1")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGPosToCoGMinusOne")

(define eterm (proof-to-extracted-term))
(animate "CoGShift")
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)
(deanimate "CoGShift")

;; As for CoGShift, but with (cCoGUMinus(cCoGCompat ag)pair False)
;; rather than ag as CoRec argument

;; CoGToCoGDouble
(set-goal "allnc x(CoG x -> abs x<<=(1#2) -> CoG(2*x))")
(assume "x" "CoGx" "LeHyp")
(inst-with-to "CoGClosure" (pt "x") "CoGx" "CoGClosureInst")
(elim "CoGClosureInst")
;; 5,6
(drop "CoGClosureInst")
(assume "ExHyp")
(by-assume "ExHyp" "d" "dProp")
(by-assume "dProp" "x1" "dx1Prop")
(elim "dx1Prop")
(drop "dx1Prop")
(assume "Psdd")
(elim "Psdd")
;; 18,19
;; Case d=1
(assume "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoGx1" "xDef")
(assert "2*x=== ~x1+1")
 (simpreal "xDef")
 (ng #t)
 (simpreal "RealTimesIntNOne")
 (simpreal "<-" "RealTimesIdUMinus")
 (simpreal "RealTimesAssoc")
 (simpreal "RealUMinusPlusRat")
 (ng #t)
 (simpreal "RealOneTimes")
 (use "RealEqRefl")
 (autoreal)
(assume "EqHyp")
(simpreal "EqHyp")
(use "CoGNegToCoGPlusOne")
(intro 0 (pt "~x1"))
(split)
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGx1")
(autoreal)
(split)
;; ?^52:~x1<<=0
(use "RealLeTrans" (pt "2*((1#2)*(x1+IntN 1)* ~1)+ ~1"))
;; 54,55
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusDistrLeft")
(simpreal "RealTimesIdRatUMinus")
(simpreal "RealTimesAssoc")
(simpreal "RealTimesOne")
(ng #t)
(simpreal "RealOneTimes")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealPlusZero")
(use "RealLeRefl")
(autoreal)
;; 55
(simpreal "<-" "xDef")
(use "RealLeTrans" (pt "2*abs x+ ~1"))
(use "RealLeMonPlus")
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "RealLeAbsId")
(autoreal)
(use "RatLeToRealLe")
(use "Truth")
(use "RealLeTrans" (pt "RealTimes 2(1#2)+ ~1"))
(use "RealLeMonPlus")
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "LeHyp")
(use "RatLeToRealLe")
(use "Truth")
(ng #t)
(use "RatLeToRealLe")
(use "Truth")
(use "RealEqRefl")
(autoreal)
;; ?_19:CoG x1 andl x===(1#2)*(x1+IntN 1)* ~IntN 1 -> CoG(2*x)
(drop "Psdd")
(ng #t)
(assume "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoGx1" "xDef")
(assert "2*x===x1+ ~1")
 (simpreal "xDef")
 (simpreal "RealTimesOne")
 (simpreal "RealTimesAssoc")
 (ng #t)
 (simpreal "RealOneTimes")
 (use "RealEqRefl")
 (autoreal)
(assume "EqHyp")
(simpreal "EqHyp")
(use "CoGPosToCoGMinusOne")
(intro 0 (pt "x1"))
(split)
(use "CoGx1")
(split)
;; ?^129: 0<<=x1
(use "RealLeTrans" (pt "2*((1#2)*(x1+IntN 1)*1)+ 1"))
;; 131,132
(simpreal "<-" "xDef")
(use "RealLeTrans" (pt "2*RealUMinus(1#2)+1"))
(ng #t)
(use "RatLeToRealLe")
(use "Truth")
(use "RealLeMonPlus")
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "RealLeAbsInv")
(autoreal)
(use "LeHyp")
(use "RatLeToRealLe")
(use "Truth")
;; 132
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesOne")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(simpreal "<-" "RealPlusAssoc")
(ng #t)
(simpreal "RealPlusZero")
(use "RealLeRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 6
(drop "CoGClosureInst")
(assume "ExHyp")
(by-assume "ExHyp" "x1" "Conj")
(elim "Conj")
(assume "CoHx1" "xDef")
(drop "Conj")
(assert "2*x===x1")
 (simpreal "xDef")
 (simpreal "RealTimesAssoc")
 (ng #t)
 (simpreal "RealOneTimes")
 (use "RealEqRefl")
 (autoreal)
(assume "EqHyp")
(simpreal "EqHyp")
(use "CoHToCoG")
(use "CoHx1")
;; Proof finished.
;; (cdp)
(save "CoGToCoGDouble")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ag][case (DesYprod ag)
;;    (InL bg -> [case bg (boole pair ag0 -> [case boole
;;        (True -> cCoGCompat(
;;                  cCoGNegToCoGPlusOne(cCoGUMinus(cCoGCompat ag0))))
;;        (False -> cCoGCompat(cCoGPosToCoGMinusOne ag0))])])
;;    (InR ah -> cCoGCompat(cCoHToCoG ah))]

;; CoGToCoGQuad
(set-goal "allnc x(CoG x -> abs x<<=(1#4) -> CoG(4*x))")
(assume "x" "CoGx" "LeHyp")
(assert "4*x===2*(2*x)")
(simpreal "RealTimesAssoc")
(ng #t)
(use "RealEqRefl")
(autoreal)
;; Assertion proved
(assume "EqHyp")
(simpreal "EqHyp")
(use "CoGToCoGDouble")
(use "CoGToCoGDouble")
(use "CoGx")
(use "RealLeTrans" (pt "RealPlus 0(1#4)"))
(ng #t)
(use "LeHyp")
(ng #t)
(use "RatLeToRealLe")
(use "Truth")
(simpreal "RealAbsTimes")
(ng #t)
(use "RealLeTrans" (pt "RealTimes 2(1#4)"))
(use "RealLeMonTimes")
(use "RealNNegPos")
(use "LeHyp")
(use "RatLeToRealLe")
(use "Truth")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGToCoGQuad")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (pp neterm)

;; [ag]cCoGCompat(cCoGToCoGDouble(cCoGToCoGDouble ag))

;; CoGDivSatCoIClAuxR
(set-goal "allnc x,y(CoG x -> CoG y -> (1#4)<<=y -> abs x<<=y -> 0<<=x -> 
 CoG(4*((1#2)*(x+ ~((1#2)*y)))))")
(assume "x" "y" "CoGx" "CoGy" "yLBd" "xBd" "0<<=x")
(use "CoGToCoGQuad")
(use "CoGAverage")
(use "CoGx")
(use "CoGUMinus")
(simpreal "RealUMinusUMinus")
(use "CoGU")
(use "CoGToCoH")
(use "CoGy")
(autoreal)
;; ?^4:abs((1#2)*(x+ ~((1#2)*y)))<<=(1#4)
(simpreal (pf "((1#2)*(x+ ~((1#2)*y)))===(1#4)*(4*((1#2)*(x+ ~((1#2)*y))))"))
(simpreal "RealAbsTimes")
(use "RealLeTrans" (pt "abs(1#4)*y"))
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "DivAuxBdR")
(use "0<<=x")
(use "RealLeTrans" (pt "abs x"))
(use "RealLeAbsId")
(autoreal)
(use "xBd")
(ng #t)
(use "RealLeTrans" (pt "RealTimes(1#4)1"))
(use "RealLeMonTimes")
(use "RealNNegPos")
(use "RealLeTrans" (pt "abs y"))
(use "RealLeAbsId")
(autoreal)
(use "CoGToBd")
(use "CoGy")
(use "RatLeToRealLe")
(use "Truth")
(autoreal)
;; ?^13:(1#2)*(x+ ~((1#2)*y))===(1#4)*(4*((1#2)*(x+ ~((1#2)*y))))
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGDivSatCoIClAuxR")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (pp neterm)

;; [ag,ag0]
;;  cCoGToCoGQuad(cCoGAverage ag(cCoGUMinus(cCoGCompat(cCoGU(cCoGToCoH ag0)))))

;; CoGDivSatCoIClAuxL
(set-goal "allnc x,y(CoG x -> CoG y -> (1#4)<<=y -> abs x<<=y -> x<<=0 -> 
 CoG(4*((1#2)*(x+(1#2)*y))))")
(assume "x" "y" "CoGx" "CoGy" "yLBd" "xBd" "x<<=0")
(use "CoGToCoGQuad")
(use "CoGAverage")
(use "CoGx")
(use "CoGU")
(use "CoGToCoH")
(use "CoGy")
;; ?^4:abs((1#2)*(x+(1#2)*y))<<=(1#4)
(simpreal (pf "((1#2)*(x+(1#2)*y))===(1#4)*(4*((1#2)*(x+(1#2)*y)))"))
(simpreal "RealAbsTimes")
(use "RealLeTrans" (pt "abs(1#4)*y"))
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "DivAuxBdL")
(use "x<<=0")
(use "xBd")
(ng #t)
(use "RealLeTrans" (pt "RealTimes(1#4)1"))
(use "RealLeMonTimes")
(use "RealNNegPos")
(use "RealLeTrans" (pt "abs y"))
(use "RealLeAbsId")
(autoreal)
(use "CoGToBd")
(use "CoGy")
(use "RatLeToRealLe")
(use "Truth")
(autoreal)
;; ?^10:(1#2)*(x+(1#2)*y)===(1#4)*(4*((1#2)*(x+(1#2)*y)))
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGDivSatCoIClAuxL")

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (pp neterm)

;; [ag,ag0]cCoGToCoGQuad(cCoGAverage ag(cCoGU(cCoGToCoH ag0)))

;; (set! COMMENT-FLAG #f)
;; CoGDivSatCoICl
(set-goal "allnc x,y(CoG x -> CoG y -> (1#4)<<=y -> abs x<<=y ->
 exr d0,x0(Sd d0 andi CoG x0 andi abs x0<<=y andi
 x*RealUDiv y 3===(1#2)*(x0*RealUDiv y 3+d0)))")
(assume "x" "y" "CoGx" "CoGy" "yLBd" "xBd")
;; Let d1,d2,d3 be the first three digits of x.
;; We first distinguish cases on the most significant digit d1
(inst-with-to "CoGClosure" (pt "x") "CoGx" "CoGClosureInst1")
(elim "CoGClosureInst1")
;; 5,6
(drop "CoGClosureInst1")
(assume "ExHyp1")
(by-assume "ExHyp1" "d1" "d1Prop")
(by-assume "d1Prop" "x1" "d1x1Prop")
(elim "d1x1Prop")
(drop "d1x1Prop")
(assume "Psdd1")
(elim "Psdd1")
;; 18,19
;; Case d1=1
(assume "Conj11")
(elim "Conj11")
(drop "Conj11")
(assume "CoGx1")
(assert "abs x1<<=1")
 (use "CoGToBd")
 (use "CoGx1")
(assume "x1Bd" "Eq1")
(drop "d1x1Prop" "Conj11")
;; Next we show 0<<=x from x===(1#2)*(x1+1)* ~1 using x1Bd
(assert "0<<=x")
 (simpreal "Eq1")
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesPlusDistrLeft")
 (ng #t)
 (simpreal "RealTimesIntNOne")
 (use "RealLeTrans" (pt "(1#2)*(RealUMinus 1+1)"))
 (ng #t)
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeAbsInv")
 (autoreal)
 (simpreal "RealAbsUMinus")
 (use "x1Bd")
 (autoreal)
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "0<<=x")
(intro 0 (pt "IntP 1"))
(intro 0 (pt "4*((1#2)*(x+ ~((1#2)*y)))"))
(split)
(use "InitSdSdR")
(split)
(use "CoGDivSatCoIClAuxR")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "0<<=x")
(split)
(use "DivAuxBdR")
(use "0<<=x")
(use "RealLeTrans" (pt "abs x"))
(use "RealLeAbsId")
(autoreal)
(use "xBd")
(use "DivAuxEqR")
(autoreal)
(use "yLBd")
;; 19
;; Case d1=IntN 1
(assume "Conj11")
(elim "Conj11")
(drop "Conj11")
(assume "CoGx1")
(assert "abs x1<<=1")
 (use "CoGToBd")
 (use "CoGx1")
(assume "x1Bd" "Eq1")
;; Next we show x<<=0 from x===(1#2)*(x1+IntN 1)* ~IntN 1 using x1Bd
(assert "x<<=0")
 (simpreal "Eq1")
 (ng #t)
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesOne")
 (use "RealLeTrans" (pt "(1#2)*(RealPlus 1 IntN 1)"))
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeTrans" (pt "abs x1"))
 (use "RealLeAbsId")
 (autoreal)
 (use "x1Bd")
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "x<<=0")
(intro 0 (pt "IntN 1"))
(intro 0 (pt "4*((1#2)*(x+(1#2)*y))"))
(split)
(use "InitSdSdL")
(split)
(use "CoGDivSatCoIClAuxL")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "x<<=0")
(split)
(use "DivAuxBdL")
(use "x<<=0")
(use "xBd")
;; ?^122:x*RealUDiv y 3===(1#2)*(4*((1#2)*(x+(1#2)*y))*RealUDiv y 3+IntN 1)
(use "DivAuxEqL")
(autoreal)
(use "yLBd")
;; 6
(drop "CoGClosureInst1")
(assume "ExHyp")
(by-assume "ExHyp" "x1" "Conj")
(elim "Conj")
(drop "Conj")
(assume "CoHx1")
(assert "abs x1<<=1")
 (use "CoHToBd")
 (use "CoHx1")
(assume "x1Bd" "Eq1")
(inst-with-to "CoHClosure" (pt "x1") "CoHx1" "CoHClosureInst2")
(elim "CoHClosureInst2")
;; 142,143
(drop "CoHClosureInst2")
(assume "ExHyp2")
(by-assume "ExHyp2" "d2" "d2Prop")
(by-assume "d2Prop" "x2" "d2x2Prop")
(elim "d2x2Prop")
(assume "Psdd2")
;; We now distinguish cases on d2
(elim "Psdd2")
;; 153,154
;; Case d1=0, d2=1
(assume "Conj21")
(elim "Conj21")
(drop "Conj21")
(assume "CoGx2")
(assert "abs x2<<=1")
 (use "CoGToBd")
 (use "CoGx2")
(assume "x2Bd" "Eq2")
(drop "d2x2Prop")
;; Next we show 0<<=x from x===(1#2)*(x1+0) and x1===(1#2)*(x2+1)
(assert "0<<=x")
 (simpreal "Eq1")
 (simpreal "Eq2")
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesOne")
 (use "RealLeTrans" (pt "(1#2)*((1#2)*(RealUMinus 1+1))"))
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeAbsInv")
 (autoreal)
 (use "x2Bd")
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "0<<=x")
;; Now we define d and x0
(intro 0 (pt "IntP 1"))
(intro 0 (pt "4*((1#2)*(x+ ~((1#2)*y)))"))
(split)
(use "InitSdSdR")
(split)
(use "CoGDivSatCoIClAuxR")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "0<<=x")
(split)
;; ?^201:abs(4*((1#2)*(x+ ~((1#2)*y))))<<=y
(use "DivAuxBdR")
(use "0<<=x")
(use "RealLeTrans" (pt "abs x"))
(use "RealLeAbsId")
(autoreal)
(use "xBd")
;; ?^202:x*RealUDiv y 3===(1#2)*(4*((1#2)*(x+ ~((1#2)*y)))*RealUDiv y 3+1)
(use "DivAuxEqR")
(autoreal)
(use "yLBd")
;; 154
(drop "CoHClosureInst2" "d2x2Prop")
;; Case d1=0, d2=IntN 1
(assume "Conj21")
(elim "Conj21")
(drop "Conj21")
(assume "CoGx2")
(assert "abs x2<<=1")
 (use "CoGToBd")
 (use "CoGx2")
(assume "x2Bd" "Eq2")
;; Next we show x<<=0 from x===(1#2)*x1 and x1===(1#2)*(x2+1)*IntN 1
(assert "x<<=0")
 (simpreal "Eq1")
 (simpreal "Eq2")
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesIntNOne")
 (simpreal "RealUMinusPlusRat")
 (use "RealLeTrans" (pt "(1#2)*((1#2)*(RealPlus 1 IntN 1))"))
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeTrans" (pt "abs ~x2"))
 (use "RealLeAbsId")
 (autoreal)
 (simpreal "RealAbsUMinus")
 (use "x2Bd")
 (autoreal)
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "x<<=0")
;; Now we define d and x0
(intro 0 (pt "IntN 1"))
(intro 0 (pt "4*((1#2)*(x+(1#2)*y))"))
(split)
(use "InitSdSdL")
(split)
(use "CoGDivSatCoIClAuxL")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "x<<=0")
(split)
;; ?^261:abs(4*((1#2)*(x+(1#2)*y)))<<=y
(use "DivAuxBdL")
(use "x<<=0")
(use "xBd")
(use "DivAuxEqL")
(autoreal)
(use "yLBd")
;; 143
(drop "CoHClosureInst2")
;; Case d1=0, d2=0
(assume "ExHyp2")
(by-assume "ExHyp2" "x2" "Conj21")
(elim "Conj21")
(drop "Conj21")
(assume "CoHx2")
(assert "abs x2<<=1")
 (use "CoHToBd")
 (use "CoHx2")
(assume "x2Bd" "Eq2")
(inst-with-to "CoHClosure" (pt "x2") "CoHx2" "CoHClosureInst3")
(elim "CoHClosureInst3")
;; 282,283
(drop "CoHClosureInst3")
(assume "ExHyp3")
(by-assume "ExHyp3" "d3" "d3Prop")
(by-assume "d3Prop" "x3" "d3x3Prop")
(elim "d3x3Prop")
(drop "d3x3Prop")
(assume "Psdd3")
;; We now distinguish cases on d3
(elim "Psdd3")
;; 295,296
(drop "Psdd3")
;; Case d1=0, d2=0, d3=1
(assume "Conj31")
(elim "Conj31")
(drop "Conj31")
(assume "CoGx3")
(assert "abs x3<<=1")
 (use "CoGToBd")
 (use "CoGx3")
(assume "x3Bd" "Eq3")
;; Next we show 0<<=x from x===(1#2)*x1, x1===(1#2)*x2, x2===(1#2)*(x3+1)*1
(assert "0<<=x")
 (simpreal "Eq1")
 (simpreal "Eq2")
 (simpreal "Eq3")
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesOne")
 (use "RealLeTrans" (pt "(1#2)*((1#2)*((1#2)*(RealUMinus 1+1)))"))
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeAbsInv")
 (autoreal)
 (use "x3Bd")
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "0<<=x")
;; Now we define d and x0
(intro 0 (pt "IntP 1"))
(intro 0 (pt "4*((1#2)*(x+ ~((1#2)*y)))"))
(split)
(use "InitSdSdR")
(split)
(use "CoGDivSatCoIClAuxR")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "0<<=x")
(split)
;; ?^346:abs(4*((1#2)*(x+ ~((1#2)*y))))<<=y
(use "DivAuxBdR")
(use "0<<=x")
(use "RealLeTrans" (pt "abs x"))
(use "RealLeAbsId")
(autoreal)
(use "xBd")
;; ?^347:x*RealUDiv y 3===(1#2)*(4*((1#2)*(x+ ~((1#2)*y)))*RealUDiv y 3+1)
(use "DivAuxEqR")
(autoreal)
(use "yLBd")
;; 296
;; Case d1=0, d2=0, d3=IntN 1
(assume "Conj32")
(elim "Conj32")
(drop "Conj32")
(assume "CoGx3")
(assert "abs x3<<=1")
 (use "CoGToBd")
 (use "CoGx3")
(assume "x3Bd" "Eq3")
;; Next we show x<<=0 from x===(1#2)*x1, x1===(1#2)*x2, x2===(1#2)*(x3+1)*IntN 1
(assert "x<<=0")
 (simpreal "Eq1")
 (simpreal "Eq2")
 (simpreal "Eq3")
 (simpreal "<-" "RealTimesAssoc")
 (simpreal "RealTimesIntNOne")
 (simpreal "RealUMinusPlusRat")
 (use "RealLeTrans" (pt "(1#2)*((1#2)*((1#2)*(RealPlus 1 IntN 1)))"))
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonTimes")
 (use "RatNNegToRealNNeg")
 (use "Truth")
 (use "RealLeMonPlus")
 (use "RealLeTrans" (pt "abs ~x3"))
 (use "RealLeAbsId")
 (autoreal)
 (simpreal "RealAbsUMinus")
 (use "x3Bd")
 (autoreal)
 (use "RatLeToRealLe")
 (use "Truth")
 (use "RatLeToRealLe")
 (use "Truth")
 (autoreal)
(assume "x<<=0")
;; Now we define d and x0
(intro 0 (pt "IntN 1"))
(intro 0 (pt "4*((1#2)*(x+(1#2)*y))"))
(split)
(use "InitSdSdL")
(split)
(use "CoGDivSatCoIClAuxL")
(use "CoGx")
(use "CoGy")
(use "yLBd")
(use "xBd")
(use "x<<=0")
(split)
;; ?^409:abs(4*((1#2)*(x+(1#2)*y)))<<=y
(use "DivAuxBdL")
(use "x<<=0")
(use "xBd")
(use "DivAuxEqL")
(autoreal)
(use "yLBd")
;; 283
(drop "CoHClosureInst3")
(assume "ExHyp3")
(by-assume "ExHyp3" "x3" "Conj31")
(elim "Conj31")
(drop "Conj31")
(assume "CoHx3")
(assert "abs x3<<=1")
 (use "CoHToBd")
 (use "CoHx3")
(assume "x3Bd" "Eq3")
;; We can now pick d=0 and x0 as 2*x
(intro 0 (pt "0"))
(intro 0 (pt "2*x"))
(split)
(use "InitSdSdM")
(split)
(use "CoGToCoGDouble")
(use "CoGx")
(simpreal "Eq1")
(simpreal "RealAbsTimes")
(ng #t)
(use "RealLeTrans" (pt "RealTimes(1#2)1"))
(use "RealLeMonTimes")
(use"RatNNegToRealNNeg")
(use "Truth")
(use "x1Bd")
(use "RatLeToRealLe")
(use "Truth")
(autoreal)
(split)
;; ?^447:abs(2*x)<<=y
(simpreal "RealAbsTimes")
(ng #t)
(simpreal "Eq1")
(simpreal "RealAbsTimes")
(ng #t)
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(simpreal "Eq2")
(simpreal "RealAbsTimes")
(ng #t)
(simpreal "Eq3")
(simpreal "RealAbsTimes")
(ng #t)
(simpreal "RealTimesAssoc")
(ng #t)
(use "RealLeTrans" (pt "RealTimes(1#4)1"))
(use "RealLeMonTimes")
(use "RatNNegToRealNNeg")
(use "Truth")
(use "x3Bd")
(use "yLBd")
(autoreal)
;; ?^448:x*RealUDiv y 3===(1#2)*(2*x*RealUDiv y 3+0)
(assert "Real(RealUDiv y 3)")
 (use "RealUDivReal")
 (autoreal)
 (simp (pf "3=PosS 2"))
 (use "RealLeToPos")
 (use "RealLeTrans" (pt "y")) 
 (use "yLBd")
 (use "RealLeAbsId")
 (autoreal)
 (use "Truth")
(assume "R1/y")
(simpreal "RealPlusZero")
(simpreal "RealTimesAssoc")
(simpreal "RealTimesAssoc")
(ng #t)
(simpreal "RealOneTimes")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGDivSatCoICl")
;; (set! COMMENT-FLAG #t)

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

(animate "CoGClosure")
(animate "CoHClosure")

(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ag,ag0][case (DesYprod ag)
;;    (InL bg -> [case bg (boole pair ag1 -> [case boole
;;        (True -> SdR pair cCoGDivSatCoIClAuxR ag ag0)
;;        (False -> SdL pair cCoGDivSatCoIClAuxL ag ag0)])])
;;    (InR ah -> [case (DesYprod ah)
;;      (InL bg -> [case bg (boole pair ag1 -> [case boole
;;          (True -> SdR pair cCoGDivSatCoIClAuxR ag ag0)
;;          (False -> SdL pair cCoGDivSatCoIClAuxL ag ag0)])])
;;      (InR ah0 -> [case (DesYprod ah0)
;;        (InL bg -> [case bg (boole pair ag1 -> [case boole
;;            (True -> SdR pair cCoGDivSatCoIClAuxR ag ag0)
;;            (False -> SdL pair cCoGDivSatCoIClAuxL ag ag0)])])
;;        (InR ah1 -> SdM pair cCoGToCoGDouble ag)])])]

(deanimate "CoGClosure")
(deanimate "CoHClosure")

;; (set! COMMENT-FLAG #f)
;; CoGDivAux
(set-goal "allnc y(CoG y -> (1#4)<<=y -> allnc z(
 exr x(CoG x andi abs x<<=y andi z===x*RealUDiv y 3) -> CoG z))")
(assume "y" "CoGy" "yLBd")
(assert "RealPos y 3")
 (simp (pf "3=PosS 2"))
 (use "RealLeToPos")
 (use "yLBd")
 (use "Truth")
(assume "0<y")
(assert "Real(RealUDiv y 3)")
 (use "RealUDivReal")
 (realproof)
 (simp (pf "3=PosS 2"))
 (use "RealLeToPos")
 (use "RealLeTrans" (pt "y")) 
 (use "yLBd")
 (use "RealLeAbsId")
 (autoreal)
 (use "Truth")
(assume "R1/y" "x" "ExHyp")
(coind "ExHyp"
       (pf "exr x(CoH x andi abs x<<=y andi z===x*RealUDiv y 3) -> CoH z"))
;; 20,21
(drop "ExHyp")
(assume "x0" "x0Prop")
(by-assume "x0Prop" "x1" "x0x1Prop")
(elim "x0x1Prop")
(drop "x0x1Prop")
(assume "CoGx1" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "x1Bd" "x0Def")
(inst-with-to "CoGDivSatCoICl"
	      (pt "x1") (pt "y") "CoGx1" "CoGy" "yLBd" "x1Bd"
	      "CoGDivInst")
(by-assume "CoGDivInst" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(elim "dx2Prop")
(drop "dx2Prop")
(assume "Sdd")
(assume "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "CoGx2")
(assume "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "x2Bd")
(assert "abs(x2*RealUDiv y 3)<<=1")
 (simpreal "RealAbsTimes")
 (use "RealLeTrans" (pt "y*abs(RealUDiv y 3)"))
 (use "RealLeMonTimesL")
 (use "RealNNegAbs")
 (autoreal)
 (use "x2Bd")
 (simpreal "RealAbsUDiv")
 (simpreal "RealNNegToUDivAbs")
 (simpreal "RealTimesUDiv")
 (use "RatLeToRealLe")
 (use "Truth")
 (use "0<y")
 (autoreal)
 (use "RealPosAbs")
 (use "0<y")
 (use "RealPosToNNeg" (pt "3"))
 (autoreal)
 (use "0<y")
 (use "0<y")
 (autoreal)
(assume "x2/yBd")
(assert "d=0 orr Psd d")
 (use-with "SdDisj" (pt "d") "Sdd")
(assume "Disj")
(elim "Disj")
;; 79,80
;; Case d=0
(drop "Disj")
(assume "d=0")
(simp "d=0")
(assume "Eq")
(intro 1) ;go for the r.h.s of the disjunction
(intro 0 (pt "x2*RealUDiv y 3"))
(intro 0 (pt "x0"))
(split)
(autoreal)
(split)
;; ?^90:abs(x2*RealUDiv y 3)<<=1
(use "x2/yBd")
(split)
(intro 1)
(intro 0 (pt "x2"))
(split)
(use "CoGToCoH")
(use "CoGx2")
(split)
(use "x2Bd")
(use "RealEqRefl")
(autoreal)
(split)
(simpreal "x0Def")
(simpreal "Eq")
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 80
;; Case Psd d
(drop "Disj")
(assume "Psdd" "Eq")
(intro 0) ;go for the l.h.s of the disjunction
(intro 0 (pt "d"))
(intro 0 (pt "(x2*RealUDiv y 3)*RealUMinus d"))
(intro 0 (pt "x0"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
;; ?^120:abs(x2*RealUDiv y 3* ~d)<<=1
(simpreal "RealAbsTimes")
(simpreal "RealAbsUMinus")
(simpreal (pf "RealAbs d===1"))
(simpreal "RealTimesOne")
(use "x2/yBd")
(autoreal)
(use "RatEqvToRealEq")
(ng #t)
(use "PsdToAbsOne")
(use "Psdd")
(autoreal)
(split)
(intro 1)
(intro 0 (pt "x2*RealUMinus d"))
(split)
(use "CoGPsdTimes")
(use "CoGx2")
(use "PsdUMinus")
(use "Psdd")
(split)
(simpreal "RealAbsTimes")
(simpreal "RealAbsUMinus")
(use "RealLeTrans" (pt "y*1"))
(use "RealLeMonTimesTwo")
(use "RealNNegAbs")
(autoreal)
(use "RealNNegAbs")
(autoreal)
(use "x2Bd")
(use "RatLeToRealLe")
(ng #t)
(simp "PsdToAbsOne")
(use "Truth")
(use "Psdd")
(simpreal "RealTimesOne")
(use "RealLeRefl")
(autoreal)
(simpreal "RealTimesComm")
(simpreal (pf "x2*RealUMinus d===RealUMinus d*x2"))
(use "RealTimesAssoc")
(autoreal)
(use "RealTimesComm")
(autoreal)
(split)
(simpreal "x0Def")
(simpreal "Eq")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusIntNOneDistrLeft")
(ng #t)
(simpreal "RealTimesPsdPsd")
(use "RealEqRefl")
(autoreal)
(use "PsdUMinus")
(use "Psdd")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 21
(drop "ExHyp")
(assume "x0" "x0Prop")
(by-assume "x0Prop" "x1" "x0x1Prop")
(elim "x0x1Prop")
(drop "x0x1Prop")
(assume "CoHx1" "Conj1")
(elim "Conj1")
(drop "Conj1")
(assume "x1Bd" "x0Def")
(assert "CoG x1")
 (use "CoHToCoG")
 (use "CoHx1")
(assume "CoGx1")
(inst-with-to "CoGDivSatCoICl"
	      (pt "x1") (pt "y") "CoGx1" "CoGy" "yLBd" "x1Bd"
	      "CoGDivInst")
(by-assume "CoGDivInst" "d" "dProp")
(by-assume "dProp" "x2" "dx2Prop")
(elim "dx2Prop")
(drop "dx2Prop")
(assume "Sdd")
(assume "Conj2")
(elim "Conj2")
(drop "Conj2")
(assume "CoGx2" "Conj3")
(elim "Conj3")
(drop "Conj3")
(assume "x2Bd")
(assert "abs(x2*RealUDiv y 3)<<=1")
 (simpreal "RealAbsTimes")
 (use "RealLeTrans" (pt "y*abs(RealUDiv y 3)"))
 (use "RealLeMonTimesL")
 (use "RealNNegAbs")
 (autoreal)
 (use "x2Bd")
 (simpreal "RealAbsUDiv")
 (simpreal "RealNNegToUDivAbs")
 (simpreal "RealTimesUDiv")
 (use "RatLeToRealLe")
 (use "Truth")
 (use "0<y")
 (autoreal)
 (use "RealPosAbs")
 (use "0<y")
 (use "RealPosToNNeg" (pt "3"))
 (autoreal)
 (use "0<y")
 (use "0<y")
 (autoreal)
(assume "x2/yBd")
(assert "d=0 orr Psd d")
 (use-with "SdDisj" (pt "d") "Sdd")
(assume "Disj")
(elim "Disj")
;; 252,253
;; Case d=0
(drop "Disj")
(assume "d=0")
(simp "d=0")
(assume "Eq")
(intro 1) ;go for the r.h.s of the disjunction
(intro 0 (pt "x2*RealUDiv y 3"))
(intro 0 (pt "x0"))
(split)
(autoreal)
(split)
;; ?^263:abs(x2*RealUDiv y 3)<<=1
(use "x2/yBd")
(split)
(intro 1)
(intro 0 (pt "x2"))
(split)
(use "CoGToCoH")
(use "CoGx2")
(split)
(use "x2Bd")
(use "RealEqRefl")
(autoreal)
(split)
(simpreal "x0Def")
(simpreal "Eq")
(simpreal "RealPlusZero")
(use "RealEqRefl")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; 253
;; Case Psd d
(drop "Disj")
(assume "Psdd" "Eq")
(intro 0) ;go for the l.h.s of the disjunction
(intro 0 (pt "d"))
(intro 0 (pt "(x2*RealUDiv y 3)*d"))
(intro 0 (pt "x0"))
(split)
(use "Psdd")
(split)
(autoreal)
(split)
;; ?^293:abs(x2*RealUDiv y 3*d)<<=1
(simpreal "RealAbsTimes")
(simpreal (pf "RealAbs d===1"))
(simpreal "RealTimesOne")
(use "x2/yBd")
(autoreal)
(use "RatEqvToRealEq")
(ng #t)
(use "PsdToAbsOne")
(use "Psdd")
(autoreal)
(split)
(intro 1)
(intro 0 (pt "x2*d"))
(split)
(use "CoGPsdTimes")
(use "CoGx2")
(use "Psdd")
(split)
(simpreal "RealAbsTimes")
(use "RealLeTrans" (pt "y*1"))
(use "RealLeMonTimesTwo")
(use "RealNNegAbs")
(autoreal)
(use "RealNNegAbs")
(autoreal)
(use "x2Bd")
(use "RatLeToRealLe")
(ng #t)
(simp "PsdToAbsOne")
(use "Truth")
(use "Psdd")
(simpreal "RealTimesOne")
(use "RealLeRefl")
(autoreal)
(simpreal "RealTimesComm")
(simpreal (pf "x2*d===d*x2"))
(use "RealTimesAssoc")
(autoreal)
(use "RealTimesComm")
(autoreal)
(split)
(simpreal "x0Def")
(simpreal "Eq")
(simpreal "<-" "RealTimesAssoc")
(simpreal "RealTimesPlusOneDistrLeft")
(simpreal "RealTimesPsdPsd")
(use "RealEqRefl")
(autoreal)
(use "Psdd")
(autoreal)
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGDivAux")
;; (set! COMMENT-FLAG #t)

(define eterm (proof-to-extracted-term))
(define neterm (rename-variables (nt eterm)))
;; (ppc neterm)

;; [ag,ag0](CoRec ag=>ag ah=>ah)ag0
;;  ([ag1][case (cCoGDivSatCoICl ag1 ag)
;;      (s pair ag2 -> [case (cSdDisj s)
;;        (DummyL -> InR(InR(cCoGToCoH ag2)))
;;        (Inr boole ->
;;          InL(boole pair
;;              InR(cCoGPsdTimes ag2(cPsdUMinus boole))))])])
;;  ([ah][case (cCoGDivSatCoICl(cCoHToCoG ah)ag)
;;      (s pair ag1 -> [case (cSdDisj s)
;;        (DummyL -> InR(InR(cCoGToCoH ag1)))
;;        (Inr boole -> InL(boole pair
;;                          InR(cCoGPsdTimes ag1 boole)))])])

;; CoGDiv
(set-goal
 "allnc x,y(CoG x -> CoG y -> (1#4)<<=y -> abs x<<=y -> CoG(x*RealUDiv y 3))")
(assume "x" "y" "CoGx" "CoGy" "yLBd" "xBd")
(assert "Real(RealUDiv y 3)")
 (use "RealUDivReal")
 (realproof)
 (simp (pf "3=PosS 2"))
 (use "RealLeToPos")
 (use "RealLeTrans" (pt "y")) 
 (use "yLBd")
 (use "RealLeAbsId")
 (autoreal)
 (use "Truth")
(assume "R1/y")
(use "CoGDivAux" (pt "y"))
(use "CoGy")
(use "yLBd")
(intro 0 (pt "x"))
(split)
(use "CoGx")
(split)
(use "xBd")
(use "RealEqRefl")
(autoreal)
;; Proof finished.
;; (cdp)
(save "CoGDiv")

(define CoGDiv-eterm (proof-to-extracted-term))
(define CoGDiv-neterm (rename-variables (nt eterm)))
;; (ppc CoGDiv-neterm)

;; [ag,ag0](CoRec ag=>ag ah=>ah)ag0
;;  ([ag1][case (cCoGDivSatCoICl ag1 ag)
;;      (s pair ag2 -> [case (cSdDisj s)
;;        (DummyL -> InR(InR(cCoGToCoH ag2)))
;;        (Inr boole ->
;; 	    InL(boole pair InR(cCoGPsdTimes ag2(cPsdUMinus boole))))])])
;;  ([ah][case (cCoGDivSatCoICl(cCoHToCoG ah)ag)
;;      (s pair ag1 -> [case (cSdDisj s)
;;        (DummyL -> InR(InR(cCoGToCoH ag1)))
;;        (Inr boole -> InL(boole pair InR(cCoGPsdTimes ag1 boole)))])])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Haskell translation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; terms-to-haskell-program (written by Fredrik Nordvall-Forsberg)
;; generates a Haskell file (here graydivtest.hs).  To run it, in a
;; terminal type ghci sddivtest.hs.  In *Main> one can evaluate the
;; Haskell functions in graydivtest.hs .  Time mesurement by :set +s .
;; To quit type *Main> :q .

;; Theorems of high level optimized first.
;; Can we use util/reftree.el for this?

;; (proof-to-expr (theorem-name-to-proof "CoGAverage"))
;; [ag,ag0]cCoGDivAux ag0 ag

;; (display-animation)

'(
(animate "CoGDivAux")
(animate "CoGDivSatCoICl")
(animate "CoGDivSatCoIClAuxR")
(animate "CoGDivSatCoIClAuxL")
(animate "CoGToCoGQuad")
(animate "CoGToCoGDouble")
(animate "CoGNegToCoGPlusOne")
(animate "CoGPosToCoGMinusOne")
(animate "CoGShift")
(animate "CoGAverage")
(animate "CoGAvcToCoG")
(animate "CoGAvcSatCoICl")
(animate "CoGAvToAvc")
;; From now on we animate what is left
(animate "CoHToCoG")
(animate "CoGToCoH")
(animate "CoGU")
(animate "IntPlusPsdToSdtwo")
(animate "CoGClosure")
(animate "CoHClosure")
(animate "CoGPsdTimes")
(animate "Lft")
(animate "Rht")
(animate "PsdUMinus")
(animate "PsdToSdtwo")
(animate "CoGAvcSatCoIClAuxJ")
(animate "CoGAvcSatCoIClAuxK")
(animate "SdtwoPsdToSdK")
(animate "IntTimesSdtwoPsdToSdtwo")
(animate "SdDisj")
(animate "CoGCompat")
(animate "CoGUMinus")
(animate "CoGIntNOne")
(animate "CoGOne")
(animate "CoICompat")
(animate "CoIUMinus")
(animate "SdToPsd")
(animate "PsdToDisj")
(animate "RealToCoI")
(animate "RealToCoIAux")
;; Second round.
(animate "CoGClauseInv")
(animate "SdtwoPsdToSdtwoJ")
(animate "SdtwoToSdK")
(animate "SdtwoToSdtwoJ")
(animate "CoHCompat")
(animate "PMOneToCoG")
(animate "CoIClauseInv")
(animate "CoIClosure")
(animate "SdUMinus")
(animate "ApproxSplitZeroMinusPtFive")
(animate "ApproxSplitZeroPtFive")
(animate "ApproxSplit")
(animate "CoHClauseInv")

(terms-to-haskell-program
 "~/temp/graydivtest.hs"
 (list (list CoGDiv-eterm "cogdiv")
       (list CoIToCoG-eterm "coitocog")
       (list RealToCoI-eterm "realtocoi")
       (list RatToCoI-eterm "rattocoi")
       (list (pt "TakeG") "takeg")
       (list (pt "ListGdToRat") "listgdtorat")))

(deanimate "CoGDivAux")
(deanimate "CoGDivSatCoICl")
(deanimate "CoGDivSatCoIClAuxR")
(deanimate "CoGDivSatCoIClAuxL")
(deanimate "CoGToCoGQuad")
(deanimate "CoGToCoGDouble")
(deanimate "CoGNegToCoGPlusOne")
(deanimate "CoGPosToCoGMinusOne")
(deanimate "CoGShift")
(deanimate "CoGAverage")
(deanimate "CoGAvcToCoG")
(deanimate "CoGAvcSatCoICl")
(deanimate "CoGAvToAvc")
;; From now on we animate what is left
(deanimate "CoHToCoG")
(deanimate "CoGToCoH")
(deanimate "CoGU")
(deanimate "IntPlusPsdToSdtwo")
(deanimate "CoGClosure")
(deanimate "CoHClosure")
(deanimate "CoGPsdTimes")
(deanimate "Lft")
(deanimate "Rht")
(deanimate "PsdUMinus")
(deanimate "PsdToSdtwo")
(deanimate "CoGAvcSatCoIClAuxJ")
(deanimate "CoGAvcSatCoIClAuxK")
(deanimate "SdtwoPsdToSdK")
(deanimate "IntTimesSdtwoPsdToSdtwo")
(deanimate "SdDisj")
(deanimate "CoGCompat")
(deanimate "CoGUMinus")
(deanimate "CoGIntNOne")
(deanimate "CoGOne")
(deanimate "CoICompat")
(deanimate "CoIUMinus")
(deanimate "SdToPsd")
(deanimate "PsdToDisj")
(deanimate "RealToCoI")
(deanimate "RealToCoIAux")
;; Second round.
(deanimate "CoGClauseInv")
(deanimate "SdtwoPsdToSdtwoJ")
(deanimate "SdtwoToSdK")
(deanimate "SdtwoToSdtwoJ")
(deanimate "CoHCompat")
(deanimate "PMOneToCoG")
(deanimate "CoIClauseInv")
(deanimate "CoIClosure")
(deanimate "SdUMinus")
(deanimate "ApproxSplitZeroMinusPtFive")
(deanimate "ApproxSplitZeroPtFive")
(deanimate "ApproxSplit")
(deanimate "CoHClauseInv")
)

;; In a terminal type
;; ghci graydivtest.hs
;; In Main> (for time measurement):
;; :set +s

;; *Main> takeg 19 (cogdiv (coitocog (rattocoi (1001 % 3001))) (coitocog (rattocoi (10001 % 20001))))

;; GR,GL,GR,GR,GR,GR,GR,GR,GR,GR,GU,HL,GL,GL,GR,GR,GR,GL,GR
;; (0.06 secs, 25,331,680 bytes)

;; Similarly we have
;; number of digits  runtime in seconds
;; 25                0.06
;; 50                0.14
;; 75                0.27
;; 100               0.47
;; 250               2.61
;; 500               9.62
;; 750              23.77
;; 1000             41,79
